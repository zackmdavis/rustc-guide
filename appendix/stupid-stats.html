<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Appendix A: Stupid Stats - Guide to Rustc Development</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A guide to developing rustc ">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="../">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="_FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="about-this-guide.html"><strong aria-hidden="true">1.</strong> About this guide</a></li><li><a href="how-to-build-and-run.html"><strong aria-hidden="true">2.</strong> How to build the compiler and run what you built</a></li><li><a href="conventions.html"><strong aria-hidden="true">3.</strong> Coding conventions</a></li><li><a href="tests/intro.html"><strong aria-hidden="true">4.</strong> The compiler testing framework</a></li><li><ol class="section"><li><a href="tests/running.html"><strong aria-hidden="true">4.1.</strong> Running tests</a></li><li><a href="tests/adding.html"><strong aria-hidden="true">4.2.</strong> Adding new tests</a></li><li><a href="compiletest.html"><strong aria-hidden="true">4.3.</strong> Using compiletest + commands to control testexecution</a></li></ol></li><li><a href="compiler-debugging.html"><strong aria-hidden="true">5.</strong> Debugging the Compiler</a></li><li><a href="walkthrough.html"><strong aria-hidden="true">6.</strong> Walkthrough: a typical contribution</a></li><li><a href="high-level-overview.html"><strong aria-hidden="true">7.</strong> High-level overview of the compiler source</a></li><li><a href="rustc-driver.html"><strong aria-hidden="true">8.</strong> The Rustc Driver</a></li><li><ol class="section"><li><a href="rustdoc.html"><strong aria-hidden="true">8.1.</strong> Rustdoc</a></li></ol></li><li><a href="query.html"><strong aria-hidden="true">9.</strong> Queries: demand-driven compilation</a></li><li><ol class="section"><li><a href="incremental-compilation.html"><strong aria-hidden="true">9.1.</strong> Incremental compilation</a></li><li><a href="incrcomp-debugging.html"><strong aria-hidden="true">9.2.</strong> Debugging and Testing</a></li></ol></li><li><a href="the-parser.html"><strong aria-hidden="true">10.</strong> The parser</a></li><li><a href="macro-expansion.html"><strong aria-hidden="true">11.</strong> Macro expansion</a></li><li><a href="name-resolution.html"><strong aria-hidden="true">12.</strong> Name resolution</a></li><li><a href="hir.html"><strong aria-hidden="true">13.</strong> The HIR (High-level IR)</a></li><li><a href="ty.html"><strong aria-hidden="true">14.</strong> The ty module: representing types</a></li><li><a href="type-inference.html"><strong aria-hidden="true">15.</strong> Type inference</a></li><li><a href="traits/resolution.html"><strong aria-hidden="true">16.</strong> Trait solving (old-style)</a></li><li><ol class="section"><li><a href="traits/hrtb.html"><strong aria-hidden="true">16.1.</strong> Higher-ranked trait bounds</a></li><li><a href="traits/caching.html"><strong aria-hidden="true">16.2.</strong> Caching subtleties</a></li><li><a href="traits/specialization.html"><strong aria-hidden="true">16.3.</strong> Specialization</a></li></ol></li><li><a href="traits/index.html"><strong aria-hidden="true">17.</strong> Trait solving (new-style)</a></li><li><ol class="section"><li><a href="traits/lowering-to-logic.html"><strong aria-hidden="true">17.1.</strong> Lowering to logic</a></li><li><ol class="section"><li><a href="traits/goals-and-clauses.html"><strong aria-hidden="true">17.1.1.</strong> Goals and clauses</a></li><li><a href="traits/associated-types.html"><strong aria-hidden="true">17.1.2.</strong> Equality and associated types</a></li><li><a href="traits/implied-bounds.html"><strong aria-hidden="true">17.1.3.</strong> Implied bounds</a></li><li><a href="traits/regions.html"><strong aria-hidden="true">17.1.4.</strong> Region constraints</a></li></ol></li><li><a href="traits/canonical-queries.html"><strong aria-hidden="true">17.2.</strong> Canonical queries</a></li><li><ol class="section"><li><a href="traits/canonicalization.html"><strong aria-hidden="true">17.2.1.</strong> Canonicalization</a></li></ol></li><li><a href="traits/lowering-rules.html"><strong aria-hidden="true">17.3.</strong> Lowering rules</a></li><li><ol class="section"><li><a href="traits/lowering-module.html"><strong aria-hidden="true">17.3.1.</strong> The lowering module in rustc</a></li></ol></li><li><a href="traits/wf.html"><strong aria-hidden="true">17.4.</strong> Well-formedness checking</a></li><li><a href="traits/slg.html"><strong aria-hidden="true">17.5.</strong> The SLG solver</a></li><li><a href="traits/chalk-overview.html"><strong aria-hidden="true">17.6.</strong> An Overview of Chalk</a></li><li><a href="traits/bibliography.html"><strong aria-hidden="true">17.7.</strong> Bibliography</a></li></ol></li><li><a href="type-checking.html"><strong aria-hidden="true">18.</strong> Type checking</a></li><li><ol class="section"><li><a href="method-lookup.html"><strong aria-hidden="true">18.1.</strong> Method Lookup</a></li><li><a href="variance.html"><strong aria-hidden="true">18.2.</strong> Variance</a></li></ol></li><li><a href="mir/index.html"><strong aria-hidden="true">19.</strong> The MIR (Mid-level IR)</a></li><li><ol class="section"><li><a href="mir/construction.html"><strong aria-hidden="true">19.1.</strong> MIR construction</a></li><li><a href="mir/visitor.html"><strong aria-hidden="true">19.2.</strong> MIR visitor and traversal</a></li><li><a href="mir/passes.html"><strong aria-hidden="true">19.3.</strong> MIR passes: getting the MIR for a function</a></li><li><a href="mir/borrowck.html"><strong aria-hidden="true">19.4.</strong> MIR borrowck</a></li><li><ol class="section"><li><a href="mir/regionck.html"><strong aria-hidden="true">19.4.1.</strong> MIR-based region checking (NLL)</a></li></ol></li><li><a href="mir/optimizations.html"><strong aria-hidden="true">19.5.</strong> MIR optimizations</a></li></ol></li><li><a href="const-eval.html"><strong aria-hidden="true">20.</strong> Constant evaluation</a></li><li><ol class="section"><li><a href="miri.html"><strong aria-hidden="true">20.1.</strong> miri const evaluator</a></li></ol></li><li><a href="param_env.html"><strong aria-hidden="true">21.</strong> Parameter Environments</a></li><li><a href="trans.html"><strong aria-hidden="true">22.</strong> Generating LLVM IR</a></li><li><a href="diag.html"><strong aria-hidden="true">23.</strong> Emitting Diagnostics</a></li><li class="spacer"></li><li><a href="appendix/stupid-stats.html" class="active"><strong aria-hidden="true">25.</strong> Appendix A: Stupid Stats</a></li><li><a href="appendix/background.html"><strong aria-hidden="true">26.</strong> Appendix B: Background material</a></li><li><a href="appendix/glossary.html"><strong aria-hidden="true">27.</strong> Appendix C: Glossary</a></li><li><a href="appendix/code-index.html"><strong aria-hidden="true">28.</strong> Appendix D: Code Index</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Guide to Rustc Development</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="appendix/stupid-stats.html#appendix-a-a-tutorial-on-creating-a-drop-in-replacement-for-rustc" id="appendix-a-a-tutorial-on-creating-a-drop-in-replacement-for-rustc"><h1>Appendix A: A tutorial on creating a drop-in replacement for rustc</h1></a>
<blockquote>
<p><strong>Note:</strong> This is a copy of <code>@nrc</code>'s amazing <a href="https://github.com/nrc/stupid-stats">stupid-stats</a>. You should find
a copy of the code on the GitHub repository although due to the compiler's
constantly evolving nature, there is no guarantee it'll compile on the first
go.</p>
</blockquote>
<p>Many tools benefit from being a drop-in replacement for a compiler. By this, I
mean that any user of the tool can use <code>mytool</code> in all the ways they would
normally use <code>rustc</code> - whether manually compiling a single file or as part of a
complex make project or Cargo build, etc. That could be a lot of work;
rustc, like most compilers, takes a large number of command line arguments which
can affect compilation in complex and interacting ways. Emulating all of this
behaviour in your tool is annoying at best, especically if you are making many
of the same calls into librustc that the compiler is.</p>
<p>The kind of things I have in mind are tools like rustdoc or a future rustfmt.
These want to operate as closely as possible to real compilation, but have
totally different outputs (documentation and formatted source code,
respectively). Another use case is a customised compiler. Say you want to add a
custom code generation phase after macro expansion, then creating a new tool
should be easier than forking the compiler (and keeping it up to date as the
compiler evolves).</p>
<p>I have gradually been trying to improve the API of librustc to make creating a
drop-in tool easier to produce (many others have also helped improve these
interfaces over the same time frame). It is now pretty simple to make a tool
which is as close to rustc as you want it to be. In this tutorial I'll show
how.</p>
<p>Note/warning, everything I talk about in this tutorial is internal API for
rustc. It is all extremely unstable and likely to change often and in
unpredictable ways. Maintaining a tool which uses these APIs will be non-
trivial, although hopefully easier than maintaining one that does similar things
without using them.</p>
<p>This tutorial starts with a very high level view of the rustc compilation
process and of some of the code that drives compilation. Then I'll describe how
that process can be customised. In the final section of the tutorial, I'll go
through an example - stupid-stats - which shows how to build a drop-in tool.</p>
<a class="header" href="appendix/stupid-stats.html#overview-of-the-compilation-process" id="overview-of-the-compilation-process"><h2>Overview of the compilation process</h2></a>
<p>Compilation using rustc happens in several phases. We start with parsing, this
includes lexing. The output of this phase is an AST (abstract syntax tree).
There is a single AST for each crate (indeed, the entire compilation process
operates over a single crate). Parsing abstracts away details about individual
files which will all have been read in to the AST in this phase. At this stage
the AST includes all macro uses, attributes will still be present, and nothing
will have been eliminated due to <code>cfg</code>s.</p>
<p>The next phase is configuration and macro expansion. This can be thought of as a
function over the AST. The unexpanded AST goes in and an expanded AST comes out.
Macros and syntax extensions are expanded, and <code>cfg</code> attributes will cause some
code to disappear. The resulting AST won't have any macros or macro uses left
in.</p>
<p>The code for these first two phases is in <a href="https://github.com/rust-lang/rust/tree/master/src/libsyntax">libsyntax</a>.</p>
<p>After this phase, the compiler allocates ids to each node in the AST
(technically not every node, but most of them). If we are writing out
dependencies, that happens now.</p>
<p>The next big phase is analysis. This is the most complex phase and
uses the bulk of the code in rustc. This includes name resolution, type
checking, borrow checking, type and lifetime inference, trait selection, method
selection, linting, and so forth. Most error detection is done in this phase
(although parse errors are found during parsing). The 'output' of this phase is
a bunch of side tables containing semantic information about the source program.
The analysis code is in <a href="https://github.com/rust-lang/rust/tree/master/src/librustc">librustc</a>
and a bunch of other crates with the 'librustc_' prefix.</p>
<p>Next is translation, this translates the AST (and all those side tables) into
LLVM IR (intermediate representation). We do this by calling into the LLVM
libraries, rather than actually writing IR directly to a file. The code for
this is in <a href="https://github.com/rust-lang/rust/tree/master/src/librustc_trans">librustc_trans</a>.</p>
<p>The next phase is running the LLVM backend. This runs LLVM's optimisation passes
on the generated IR and then generates machine code. The result is object files.
This phase is all done by LLVM, it is not really part of the rust compiler. The
interface between LLVM and rustc is in <a href="https://github.com/rust-lang/rust/tree/master/src/librustc_llvm">librustc_llvm</a>.</p>
<p>Finally, we link the object files into an executable. Again we outsource this to
other programs and it's not really part of the rust compiler. The interface is
in <a href="https://github.com/rust-lang/rust/tree/master/src/librustc_back">librustc_back</a>
(which also contains some things used primarily during translation).</p>
<p>All these phases are coordinated by the driver. To see the exact sequence, look
at <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_driver/driver/fn.compile_input.html">the <code>compile_input</code> function in <code>librustc_driver</code></a>.
The driver handles all the highest level coordination of compilation -
1. handling command-line arguments
2. maintaining compilation state (primarily in the <code>Session</code>)
3. calling the appropriate code to run each phase of compilation
4. handles high level coordination of pretty printing and testing.
To create a drop-in compiler replacement or a compiler replacement,
we leave most of compilation alone and customise the driver using its APIs.</p>
<a class="header" href="appendix/stupid-stats.html#the-driver-customisation-apis" id="the-driver-customisation-apis"><h2>The driver customisation APIs</h2></a>
<p>There are two primary ways to customise compilation - high level control of the
driver using <code>CompilerCalls</code> and controlling each phase of compilation using a
<code>CompileController</code>. The former lets you customise handling of command line
arguments etc., the latter lets you stop compilation early or execute code
between phases.</p>
<a class="header" href="appendix/stupid-stats.html#compilercalls" id="compilercalls"><h3><code>CompilerCalls</code></h3></a>
<p><code>CompilerCalls</code> is a trait that you implement in your tool. It contains a fairly
ad-hoc set of methods to hook in to the process of processing command line
arguments and driving the compiler. For details, see the comments in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_driver/index.html">librustc_driver/lib.rs</a>.
I'll summarise the methods here.</p>
<p><code>early_callback</code> and <code>late_callback</code> let you call arbitrary code at different
points - early is after command line arguments have been parsed, but before
anything is done with them; late is pretty much the last thing before
compilation starts, i.e., after all processing of command line arguments, etc.
is done. Currently, you get to choose whether compilation stops or continues at
each point, but you don't get to change anything the driver has done. You can
record some info for later, or perform other actions of your own.</p>
<p><code>some_input</code> and <code>no_input</code> give you an opportunity to modify the primary input
to the compiler (usually the input is a file containing the top module for a
crate, but it could also be a string). You could record the input or perform
other actions of your own.</p>
<p>Ignore <code>parse_pretty</code>, it is unfortunate and hopefully will get improved. There
is a default implementation, so you can pretend it doesn't exist.</p>
<p><code>build_controller</code> returns a <code>CompileController</code> object for more fine-grained
control of compilation, it is described next.</p>
<p>We might add more options in the future.</p>
<a class="header" href="appendix/stupid-stats.html#compilercontroller" id="compilercontroller"><h3><code>CompilerController</code></h3></a>
<p><code>CompilerController</code> is a struct consisting of <code>PhaseController</code>s and flags.
Currently, there is only flag, <code>make_glob_map</code> which signals whether to produce
a map of glob imports (used by save-analysis and potentially other tools). There
are probably flags in the session that should be moved here.</p>
<p>There is a <code>PhaseController</code> for each of the phases described in the above
summary of compilation (and we could add more in the future for finer-grained
control). They are all <code>after_</code> a phase because they are checked at the end of a
phase (again, that might change), e.g., <code>CompilerController::after_parse</code>
controls what happens immediately after parsing (and before macro expansion).</p>
<p>Each <code>PhaseController</code> contains a flag called <code>stop</code> which indicates whether
compilation should stop or continue, and a callback to be executed at the point
indicated by the phase. The callback is called whether or not compilation
continues.</p>
<p>Information about the state of compilation is passed to these callbacks in a
<code>CompileState</code> object. This contains all the information the compiler has. Note
that this state information is immutable - your callback can only execute code
using the compiler state, it can't modify the state. (If there is demand, we
could change that). The state available to a callback depends on where during
compilation the callback is called. For example, after parsing there is an AST
but no semantic analysis (because the AST has not been analysed yet). After
translation, there is translation info, but no AST or analysis info (since these
have been consumed/forgotten).</p>
<a class="header" href="appendix/stupid-stats.html#an-example---stupid-stats" id="an-example---stupid-stats"><h2>An example - stupid-stats</h2></a>
<p>Our example tool is very simple, it simply collects some simple and not very
useful statistics about a program; it is called stupid-stats. You can find
the (more heavily commented) complete source for the example on <a href="https://github.com/nick29581/stupid-stats/blob/master/src">Github</a>.
To build, just do <code>cargo build</code>. To run on a file <code>foo.rs</code>, do <code>cargo run foo.rs</code> (assuming you have a Rust program called <code>foo.rs</code>. You can also pass any
command line arguments that you would normally pass to rustc). When you run it
you'll see output similar to</p>
<pre><code class="language-text">In crate: foo,

Found 12 uses of `println!`;
The most common number of arguments is 1 (67% of all functions);
25% of functions have four or more arguments.
</code></pre>
<p>To make things easier, when we talk about functions, we're excluding methods and
closures.</p>
<p>You can also use the executable as a drop-in replacement for rustc, because
after all, that is the whole point of this exercise. So, however you use rustc
in your makefile setup, you can use <code>target/stupid</code> (or whatever executable you
end up with) instead. That might mean setting an environment variable or it
might mean renaming your executable to <code>rustc</code> and setting your PATH. Similarly,
if you're using Cargo, you'll need to rename the executable to rustc and set the
PATH. Alternatively, you should be able to use
<a href="https://github.com/brson/multirust">multirust</a> to get around all the PATH stuff
(although I haven't actually tried that).</p>
<p>(Note that this example prints to stdout. I'm not entirely sure what Cargo does
with stdout from rustc under different circumstances. If you don't see any
output, try inserting a <code>panic!</code> after the <code>println!</code>s to error out, then Cargo
should dump stupid-stats' stdout to Cargo's stdout).</p>
<p>Let's start with the <code>main</code> function for our tool, it is pretty simple:</p>
<pre><code class="language-rust ignore">fn main() {
    let args: Vec&lt;_&gt; = std::env::args().collect();
    rustc_driver::run_compiler(&amp;args, &amp;mut StupidCalls::new());
    std::env::set_exit_status(0);
}
</code></pre>
<p>The first line grabs any command line arguments. The second line calls the
compiler driver with those arguments. The final line sets the exit code for the
program.</p>
<p>The only interesting thing is the <code>StupidCalls</code> object we pass to the driver.
This is our implementation of the <code>CompilerCalls</code> trait and is what will make
this tool different from rustc.</p>
<p><code>StupidCalls</code> is a mostly empty struct:</p>
<pre><code class="language-rust ignore">struct StupidCalls {
    default_calls: RustcDefaultCalls,
}
</code></pre>
<p>This tool is so simple that it doesn't need to store any data here, but usually
you would. We embed a <code>RustcDefaultCalls</code> object to delegate to in our impl when
we want exactly the same behaviour as the Rust compiler. Mostly you don't want
to do that (or at least don't need to) in a tool. However, Cargo calls rustc
with the <code>--print file-names</code>, so we delegate in <code>late_callback</code> and <code>no_input</code>
to keep Cargo happy.</p>
<p>Most of the rest of the impl of <code>CompilerCalls</code> is trivial:</p>
<pre><code class="language-rust ignore">impl&lt;'a&gt; CompilerCalls&lt;'a&gt; for StupidCalls {
    fn early_callback(&amp;mut self,
                        _: &amp;getopts::Matches,
                        _: &amp;config::Options,
                        _: &amp;diagnostics::registry::Registry,
                        _: ErrorOutputType)
                      -&gt; Compilation {
        Compilation::Continue
    }

    fn late_callback(&amp;mut self,
                     t: &amp;TransCrate,
                     m: &amp;getopts::Matches,
                     s: &amp;Session,
                     c: &amp;CrateStore,
                     i: &amp;Input,
                     odir: &amp;Option&lt;PathBuf&gt;,
                     ofile: &amp;Option&lt;PathBuf&gt;)
                     -&gt; Compilation {
        self.default_calls.late_callback(t, m, s, c, i, odir, ofile);
        Compilation::Continue
    }

    fn some_input(&amp;mut self,
                  input: Input,
                  input_path: Option&lt;Path&gt;)
                  -&gt; (Input, Option&lt;Path&gt;) {
        (input, input_path)
    }

    fn no_input(&amp;mut self,
                m: &amp;getopts::Matches,
                o: &amp;config::Options,
                odir: &amp;Option&lt;Path&gt;,
                ofile: &amp;Option&lt;Path&gt;,
                r: &amp;diagnostics::registry::Registry)
                -&gt; Option&lt;(Input, Option&lt;Path&gt;)&gt; {
        self.default_calls.no_input(m, o, odir, ofile, r);

        // This is not optimal error handling.
        panic!(&quot;No input supplied to stupid-stats&quot;);
    }

    fn build_controller(&amp;mut self, _: &amp;Session) -&gt; driver::CompileController&lt;'a&gt; {
        ...
    }
}
</code></pre>
<p>We don't do anything for either of the callbacks, nor do we change the input if
the user supplies it. If they don't, we just <code>panic!</code>, this is the simplest way
to handle the error, but not very user-friendly, a real tool would give a
constructive message or perform a default action.</p>
<p>In <code>build_controller</code> we construct our <code>CompileController</code>. We only want to
parse, and we want to inspect macros before expansion, so we make compilation
stop after the first phase (parsing). The callback after that phase is where the
tool does it's actual work by walking the AST. We do that by creating an AST
visitor and making it walk the AST from the top (the crate root). Once we've
walked the crate, we print the stats we've collected:</p>
<pre><code class="language-rust ignore">fn build_controller(&amp;mut self, _: &amp;Session) -&gt; driver::CompileController&lt;'a&gt; {
    // We mostly want to do what rustc does, which is what basic() will return.
    let mut control = driver::CompileController::basic();
    // But we only need the AST, so we can stop compilation after parsing.
    control.after_parse.stop = Compilation::Stop;

    // And when we stop after parsing we'll call this closure.
    // Note that this will give us an AST before macro expansions, which is
    // not usually what you want.
    control.after_parse.callback = box |state| {
        // Which extracts information about the compiled crate...
        let krate = state.krate.unwrap();

        // ...and walks the AST, collecting stats.
        let mut visitor = StupidVisitor::new();
        visit::walk_crate(&amp;mut visitor, krate);

        // And finally prints out the stupid stats that we collected.
        let cratename = match attr::find_crate_name(&amp;krate.attrs[]) {
            Some(name) =&gt; name.to_string(),
            None =&gt; String::from_str(&quot;unknown_crate&quot;),
        };
        println!(&quot;In crate: {},\n&quot;, cratename);
        println!(&quot;Found {} uses of `println!`;&quot;, visitor.println_count);

        let (common, common_percent, four_percent) = visitor.compute_arg_stats();
        println!(&quot;The most common number of arguments is {} ({:.0}% of all functions);&quot;,
                 common, common_percent);
        println!(&quot;{:.0}% of functions have four or more arguments.&quot;, four_percent);
    };

    control
}
</code></pre>
<p>That is all it takes to create your own drop-in compiler replacement or custom
compiler! For the sake of completeness I'll go over the rest of the stupid-stats
tool.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct StupidVisitor {
    println_count: usize,
    arg_counts: Vec&lt;usize&gt;,
}
#}</code></pre></pre>
<p>The <code>StupidVisitor</code> struct just keeps track of the number of <code>println!</code>s it has
seen and the count for each number of arguments. It implements
<code>syntax::visit::Visitor</code> to walk the AST. Mostly we just use the default
methods, these walk the AST taking no action. We override <code>visit_item</code> and
<code>visit_mac</code> to implement custom behaviour when we walk into items (items include
functions, modules, traits, structs, and so forth, we're only interested in
functions) and macros:</p>
<pre><code class="language-rust ignore">impl&lt;'v&gt; visit::Visitor&lt;'v&gt; for StupidVisitor {
    fn visit_item(&amp;mut self, i: &amp;'v ast::Item) {
        match i.node {
            ast::Item_::ItemFn(ref decl, _, _, _, _) =&gt; {
                // Record the number of args.
                self.increment_args(decl.inputs.len());
            }
            _ =&gt; {}
        }

        // Keep walking.
        visit::walk_item(self, i)
    }

    fn visit_mac(&amp;mut self, mac: &amp;'v ast::Mac) {
        // Find its name and check if it is &quot;println&quot;.
        let ast::Mac_::MacInvocTT(ref path, _, _) = mac.node;
        if path_to_string(path) == &quot;println&quot; {
            self.println_count += 1;
        }

        // Keep walking.
        visit::walk_mac(self, mac)
    }
}
</code></pre>
<p>The <code>increment_args</code> method increments the correct count in
<code>StupidVisitor::arg_counts</code>. After we're done walking, <code>compute_arg_stats</code> does
some pretty basic maths to come up with the stats we want about arguments.</p>
<a class="header" href="appendix/stupid-stats.html#what-next" id="what-next"><h2>What next?</h2></a>
<p>These APIs are pretty new and have a long way to go until they're really good.
If there are improvements you'd like to see or things you'd like to be able to
do, let me know in a comment or <a href="https://github.com/rust-lang/rust/issues">GitHub issue</a>.
In particular, it's not clear to me exactly what extra flexibility is required.
If you have an existing tool that would be suited to this setup, please try it
out and let me know if you have problems.</p>
<p>It'd be great to see Rustdoc converted to using these APIs, if that is possible
(although long term, I'd prefer to see Rustdoc run on the output from save-
analysis, rather than doing its own analysis). Other parts of the compiler
(e.g., pretty printing, testing) could be refactored to use these APIs
internally (I already changed save-analysis to use <code>CompilerController</code>). I've
been experimenting with a prototype rustfmt which also uses these APIs.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="diag.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="appendix/background.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="diag.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="appendix/background.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

    </body>
</html>
