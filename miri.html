<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>miri const evaluator - Guide to Rustc Development</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A guide to developing rustc ">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="_FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="about-this-guide.html"><strong aria-hidden="true">1.</strong> About this guide</a></li><li><a href="how-to-build-and-run.html"><strong aria-hidden="true">2.</strong> How to build the compiler and run what you built</a></li><li><a href="conventions.html"><strong aria-hidden="true">3.</strong> Coding conventions</a></li><li><a href="tests/intro.html"><strong aria-hidden="true">4.</strong> The compiler testing framework</a></li><li><ol class="section"><li><a href="tests/running.html"><strong aria-hidden="true">4.1.</strong> Running tests</a></li><li><a href="tests/adding.html"><strong aria-hidden="true">4.2.</strong> Adding new tests</a></li><li><a href="compiletest.html"><strong aria-hidden="true">4.3.</strong> Using compiletest + commands to control testexecution</a></li></ol></li><li><a href="compiler-debugging.html"><strong aria-hidden="true">5.</strong> Debugging the Compiler</a></li><li><a href="walkthrough.html"><strong aria-hidden="true">6.</strong> Walkthrough: a typical contribution</a></li><li><a href="high-level-overview.html"><strong aria-hidden="true">7.</strong> High-level overview of the compiler source</a></li><li><a href="rustc-driver.html"><strong aria-hidden="true">8.</strong> The Rustc Driver</a></li><li><ol class="section"><li><a href="rustdoc.html"><strong aria-hidden="true">8.1.</strong> Rustdoc</a></li></ol></li><li><a href="query.html"><strong aria-hidden="true">9.</strong> Queries: demand-driven compilation</a></li><li><ol class="section"><li><a href="incremental-compilation.html"><strong aria-hidden="true">9.1.</strong> Incremental compilation</a></li><li><a href="incrcomp-debugging.html"><strong aria-hidden="true">9.2.</strong> Debugging and Testing</a></li></ol></li><li><a href="the-parser.html"><strong aria-hidden="true">10.</strong> The parser</a></li><li><a href="macro-expansion.html"><strong aria-hidden="true">11.</strong> Macro expansion</a></li><li><a href="name-resolution.html"><strong aria-hidden="true">12.</strong> Name resolution</a></li><li><a href="hir.html"><strong aria-hidden="true">13.</strong> The HIR (High-level IR)</a></li><li><a href="ty.html"><strong aria-hidden="true">14.</strong> The ty module: representing types</a></li><li><a href="type-inference.html"><strong aria-hidden="true">15.</strong> Type inference</a></li><li><a href="traits/resolution.html"><strong aria-hidden="true">16.</strong> Trait solving (old-style)</a></li><li><ol class="section"><li><a href="traits/hrtb.html"><strong aria-hidden="true">16.1.</strong> Higher-ranked trait bounds</a></li><li><a href="traits/caching.html"><strong aria-hidden="true">16.2.</strong> Caching subtleties</a></li><li><a href="traits/specialization.html"><strong aria-hidden="true">16.3.</strong> Specialization</a></li></ol></li><li><a href="traits/index.html"><strong aria-hidden="true">17.</strong> Trait solving (new-style)</a></li><li><ol class="section"><li><a href="traits/lowering-to-logic.html"><strong aria-hidden="true">17.1.</strong> Lowering to logic</a></li><li><ol class="section"><li><a href="traits/goals-and-clauses.html"><strong aria-hidden="true">17.1.1.</strong> Goals and clauses</a></li><li><a href="traits/associated-types.html"><strong aria-hidden="true">17.1.2.</strong> Equality and associated types</a></li><li><a href="traits/implied-bounds.html"><strong aria-hidden="true">17.1.3.</strong> Implied bounds</a></li><li><a href="traits/regions.html"><strong aria-hidden="true">17.1.4.</strong> Region constraints</a></li></ol></li><li><a href="traits/canonical-queries.html"><strong aria-hidden="true">17.2.</strong> Canonical queries</a></li><li><ol class="section"><li><a href="traits/canonicalization.html"><strong aria-hidden="true">17.2.1.</strong> Canonicalization</a></li></ol></li><li><a href="traits/lowering-rules.html"><strong aria-hidden="true">17.3.</strong> Lowering rules</a></li><li><ol class="section"><li><a href="traits/lowering-module.html"><strong aria-hidden="true">17.3.1.</strong> The lowering module in rustc</a></li></ol></li><li><a href="traits/wf.html"><strong aria-hidden="true">17.4.</strong> Well-formedness checking</a></li><li><a href="traits/slg.html"><strong aria-hidden="true">17.5.</strong> The SLG solver</a></li><li><a href="traits/chalk-overview.html"><strong aria-hidden="true">17.6.</strong> An Overview of Chalk</a></li><li><a href="traits/bibliography.html"><strong aria-hidden="true">17.7.</strong> Bibliography</a></li></ol></li><li><a href="type-checking.html"><strong aria-hidden="true">18.</strong> Type checking</a></li><li><ol class="section"><li><a href="method-lookup.html"><strong aria-hidden="true">18.1.</strong> Method Lookup</a></li><li><a href="variance.html"><strong aria-hidden="true">18.2.</strong> Variance</a></li></ol></li><li><a href="mir/index.html"><strong aria-hidden="true">19.</strong> The MIR (Mid-level IR)</a></li><li><ol class="section"><li><a href="mir/construction.html"><strong aria-hidden="true">19.1.</strong> MIR construction</a></li><li><a href="mir/visitor.html"><strong aria-hidden="true">19.2.</strong> MIR visitor and traversal</a></li><li><a href="mir/passes.html"><strong aria-hidden="true">19.3.</strong> MIR passes: getting the MIR for a function</a></li><li><a href="mir/borrowck.html"><strong aria-hidden="true">19.4.</strong> MIR borrowck</a></li><li><ol class="section"><li><a href="mir/regionck.html"><strong aria-hidden="true">19.4.1.</strong> MIR-based region checking (NLL)</a></li></ol></li><li><a href="mir/optimizations.html"><strong aria-hidden="true">19.5.</strong> MIR optimizations</a></li></ol></li><li><a href="const-eval.html"><strong aria-hidden="true">20.</strong> Constant evaluation</a></li><li><ol class="section"><li><a href="miri.html" class="active"><strong aria-hidden="true">20.1.</strong> miri const evaluator</a></li></ol></li><li><a href="param_env.html"><strong aria-hidden="true">21.</strong> Parameter Environments</a></li><li><a href="trans.html"><strong aria-hidden="true">22.</strong> Generating LLVM IR</a></li><li><a href="diag.html"><strong aria-hidden="true">23.</strong> Emitting Diagnostics</a></li><li class="spacer"></li><li><a href="appendix/stupid-stats.html"><strong aria-hidden="true">25.</strong> Appendix A: Stupid Stats</a></li><li><a href="appendix/background.html"><strong aria-hidden="true">26.</strong> Appendix B: Background material</a></li><li><a href="appendix/glossary.html"><strong aria-hidden="true">27.</strong> Appendix C: Glossary</a></li><li><a href="appendix/code-index.html"><strong aria-hidden="true">28.</strong> Appendix D: Code Index</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Guide to Rustc Development</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="miri.html#miri" id="miri"><h1>Miri</h1></a>
<p>Miri (<strong>MIR</strong> <strong>I</strong>nterpreter) is a virtual machine for executing MIR without
compiling to machine code. It is usually invoked via <code>tcx.const_eval</code>.</p>
<p>If you start out with a constant</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
const FOO: usize = 1 &lt;&lt; 12;
#}</code></pre></pre>
<p>rustc doesn't actually invoke anything until the constant is either used or
placed into metadata.</p>
<p>Once you have a use-site like</p>
<pre><code class="language-rust ignore">type Foo = [u8; FOO - 42];
</code></pre>
<p>The compiler needs to figure out the length of the array before being able to
create items that use the type (locals, constants, function arguments, ...).</p>
<p>To obtain the (in this case empty) parameter environment, one can call
<code>let param_env = tcx.param_env(length_def_id);</code>. The <code>GlobalId</code> needed is</p>
<pre><code class="language-rust ignore">let gid = GlobalId {
    promoted: None,
    instance: Instance::mono(length_def_id),
};
</code></pre>
<p>Invoking <code>tcx.const_eval(param_env.and(gid))</code> will now trigger the creation of
the MIR of the array length expression. The MIR will look something like this:</p>
<pre><code class="language-mir">const Foo::{{initializer}}: usize = {
    let mut _0: usize;                   // return pointer
    let mut _1: (usize, bool);

    bb0: {
        _1 = CheckedSub(const Unevaluated(FOO, Slice([])), const 42usize);
        assert(!(_1.1: bool), &quot;attempt to subtract with overflow&quot;) -&gt; bb1;
    }

    bb1: {
        _0 = (_1.0: usize);
        return;
    }
}
</code></pre>
<p>Before the evaluation, a virtual memory location (in this case essentially a
<code>vec![u8; 4]</code> or <code>vec![u8; 8]</code>) is created for storing the evaluation result.</p>
<p>At the start of the evaluation, <code>_0</code> and <code>_1</code> are
<code>Value::ByVal(PrimVal::Undef)</code>. When the initialization of <code>_1</code> is invoked, the
value of the <code>FOO</code> constant is required, and triggers another call to
<code>tcx.const_eval</code>, which will not be shown here. If the evaluation of FOO is
successful, 42 will be subtracted by its value <code>4096</code> and the result stored in
<code>_1</code> as <code>Value::ByValPair(PrimVal::Bytes(4054), PrimVal::Bytes(0))</code>. The first
part of the pair is the computed value, the second part is a bool that's true if
an overflow happened.</p>
<p>The next statement asserts that said boolean is <code>0</code>. In case the assertion
fails, its error message is used for reporting a compile-time error.</p>
<p>Since it does not fail, <code>Value::ByVal(PrimVal::Bytes(4054))</code> is stored in the
virtual memory was allocated before the evaluation. <code>_0</code> always refers to that
location directly.</p>
<p>After the evaluation is done, the virtual memory allocation is interned into the
<code>TyCtxt</code>. Future evaluations of the same constants will not actually invoke
miri, but just extract the value from the interned allocation.</p>
<p>The <code>tcx.const_eval</code> function has one additional feature: it will not return a
<code>ByRef(interned_allocation_id)</code>, but a <code>ByVal(computed_value)</code> if possible. This
makes using the result much more convenient, as no further queries need to be
executed in order to get at something as simple as a <code>usize</code>.</p>
<a class="header" href="miri.html#datastructures" id="datastructures"><h2>Datastructures</h2></a>
<p>Miri's core datastructures can be found in
<a href="https://github.com/rust-lang/rust/blob/master/src/librustc/mir/interpret">librustc/mir/interpret</a>.
This is mainly the error enum and the <code>Value</code> and <code>PrimVal</code> types. A <code>Value</code> can
be either <code>ByVal</code> (a single <code>PrimVal</code>), <code>ByValPair</code> (two <code>PrimVal</code>s, usually fat
pointers or two element tuples) or <code>ByRef</code>, which is used for anything else and
refers to a virtual allocation. These allocations can be accessed via the
methods on <code>tcx.interpret_interner</code>.</p>
<p>If you are expecting a numeric result, you can use <code>unwrap_u64</code> (panics on
anything that can't be representad as a <code>u64</code>) or <code>to_raw_bits</code> which results
in an <code>Option&lt;u128&gt;</code> yielding the <code>ByVal</code> if possible.</p>
<a class="header" href="miri.html#allocations" id="allocations"><h2>Allocations</h2></a>
<p>A miri allocation is either a byte sequence of the memory or an <code>Instance</code> in
the case of function pointers. Byte sequences can additionally contain
relocations that mark a group of bytes as a pointer to another allocation. The
actual bytes at the relocation refer to the offset inside the other allocation.</p>
<p>These allocations exist so that references and raw pointers have something to
point to. There is no global linear heap in which things are allocated, but each
allocation (be it for a local variable, a static or a (future) heap allocation)
gets its own little memory with exactly the required size. So if you have a
pointer to an allocation for a local variable <code>a</code>, there is no possible (no
matter how unsafe) operation that you can do that would ever change said pointer
to a pointer to <code>b</code>.</p>
<a class="header" href="miri.html#interpretation" id="interpretation"><h2>Interpretation</h2></a>
<p>Although the main entry point to constant evaluation is the <code>tcx.const_eval</code>
query, there are additional functions in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/interpret/const_eval/">librustc_mir/interpret/const_eval.rs</a>
that allow accessing the fields of a <code>Value</code> (<code>ByRef</code> or otherwise). You should
never have to access an <code>Allocation</code> directly except for translating it to the
compilation target (at the moment just LLVM).</p>
<p>Miri starts by creating a virtual stack frame for the current constant that is
being evaluated. There's essentially no difference between a constant and a
function with no arguments, except that constants do not allow local (named)
variables at the time of writing this guide.</p>
<p>A stack frame is defined by the <code>Frame</code> type in
<a href="https://github.com/rust-lang/rust/blob/master/src/librustc_mir/interpret/eval_context.rs">librustc_mir/interpret/eval_context.rs</a>
and contains all the local
variables memory (<code>None</code> at the start of evaluation). Each frame refers to the
evaluation of either the root constant or subsequent calls to <code>const fn</code>. The
evaluation of another constant simply calls <code>tcx.const_eval</code>, which produces an
entirely new and independent stack frame.</p>
<p>The frames are just a <code>Vec&lt;Frame&gt;</code>, there's no way to actually refer to a
<code>Frame</code>'s memory even if horrible shenigans are done via unsafe code. The only
memory that can be referred to are <code>Allocation</code>s.</p>
<p>Miri now calls the <code>step</code> method (in
<a href="https://github.com/rust-lang/rust/blob/master/src/librustc_mir/interpret/step.rs">librustc_mir/interpret/step.rs</a>
) until it either returns an error or has no further statements to execute. Each
statement will now initialize or modify the locals or the virtual memory
referred to by a local. This might require evaluating other constants or
statics, which just recursively invokes <code>tcx.const_eval</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="const-eval.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="param_env.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="const-eval.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="param_env.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

    </body>
</html>
