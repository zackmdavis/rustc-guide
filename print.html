<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Guide to Rustc Development</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A guide to developing rustc ">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="_FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="about-this-guide.html"><strong aria-hidden="true">1.</strong> About this guide</a></li><li><a href="how-to-build-and-run.html"><strong aria-hidden="true">2.</strong> How to build the compiler and run what you built</a></li><li><a href="conventions.html"><strong aria-hidden="true">3.</strong> Coding conventions</a></li><li><a href="tests/intro.html"><strong aria-hidden="true">4.</strong> The compiler testing framework</a></li><li><ol class="section"><li><a href="tests/running.html"><strong aria-hidden="true">4.1.</strong> Running tests</a></li><li><a href="tests/adding.html"><strong aria-hidden="true">4.2.</strong> Adding new tests</a></li><li><a href="compiletest.html"><strong aria-hidden="true">4.3.</strong> Using compiletest + commands to control testexecution</a></li></ol></li><li><a href="compiler-debugging.html"><strong aria-hidden="true">5.</strong> Debugging the Compiler</a></li><li><a href="walkthrough.html"><strong aria-hidden="true">6.</strong> Walkthrough: a typical contribution</a></li><li><a href="high-level-overview.html"><strong aria-hidden="true">7.</strong> High-level overview of the compiler source</a></li><li><a href="rustc-driver.html"><strong aria-hidden="true">8.</strong> The Rustc Driver</a></li><li><ol class="section"><li><a href="rustdoc.html"><strong aria-hidden="true">8.1.</strong> Rustdoc</a></li></ol></li><li><a href="query.html"><strong aria-hidden="true">9.</strong> Queries: demand-driven compilation</a></li><li><ol class="section"><li><a href="incremental-compilation.html"><strong aria-hidden="true">9.1.</strong> Incremental compilation</a></li><li><a href="incrcomp-debugging.html"><strong aria-hidden="true">9.2.</strong> Debugging and Testing</a></li></ol></li><li><a href="the-parser.html"><strong aria-hidden="true">10.</strong> The parser</a></li><li><a href="macro-expansion.html"><strong aria-hidden="true">11.</strong> Macro expansion</a></li><li><a href="name-resolution.html"><strong aria-hidden="true">12.</strong> Name resolution</a></li><li><a href="hir.html"><strong aria-hidden="true">13.</strong> The HIR (High-level IR)</a></li><li><a href="ty.html"><strong aria-hidden="true">14.</strong> The ty module: representing types</a></li><li><a href="type-inference.html"><strong aria-hidden="true">15.</strong> Type inference</a></li><li><a href="traits/resolution.html"><strong aria-hidden="true">16.</strong> Trait solving (old-style)</a></li><li><ol class="section"><li><a href="traits/hrtb.html"><strong aria-hidden="true">16.1.</strong> Higher-ranked trait bounds</a></li><li><a href="traits/caching.html"><strong aria-hidden="true">16.2.</strong> Caching subtleties</a></li><li><a href="traits/specialization.html"><strong aria-hidden="true">16.3.</strong> Specialization</a></li></ol></li><li><a href="traits/index.html"><strong aria-hidden="true">17.</strong> Trait solving (new-style)</a></li><li><ol class="section"><li><a href="traits/lowering-to-logic.html"><strong aria-hidden="true">17.1.</strong> Lowering to logic</a></li><li><ol class="section"><li><a href="traits/goals-and-clauses.html"><strong aria-hidden="true">17.1.1.</strong> Goals and clauses</a></li><li><a href="traits/associated-types.html"><strong aria-hidden="true">17.1.2.</strong> Equality and associated types</a></li><li><a href="traits/implied-bounds.html"><strong aria-hidden="true">17.1.3.</strong> Implied bounds</a></li><li><a href="traits/regions.html"><strong aria-hidden="true">17.1.4.</strong> Region constraints</a></li></ol></li><li><a href="traits/canonical-queries.html"><strong aria-hidden="true">17.2.</strong> Canonical queries</a></li><li><ol class="section"><li><a href="traits/canonicalization.html"><strong aria-hidden="true">17.2.1.</strong> Canonicalization</a></li></ol></li><li><a href="traits/lowering-rules.html"><strong aria-hidden="true">17.3.</strong> Lowering rules</a></li><li><ol class="section"><li><a href="traits/lowering-module.html"><strong aria-hidden="true">17.3.1.</strong> The lowering module in rustc</a></li></ol></li><li><a href="traits/wf.html"><strong aria-hidden="true">17.4.</strong> Well-formedness checking</a></li><li><a href="traits/slg.html"><strong aria-hidden="true">17.5.</strong> The SLG solver</a></li><li><a href="traits/chalk-overview.html"><strong aria-hidden="true">17.6.</strong> An Overview of Chalk</a></li><li><a href="traits/bibliography.html"><strong aria-hidden="true">17.7.</strong> Bibliography</a></li></ol></li><li><a href="type-checking.html"><strong aria-hidden="true">18.</strong> Type checking</a></li><li><ol class="section"><li><a href="method-lookup.html"><strong aria-hidden="true">18.1.</strong> Method Lookup</a></li><li><a href="variance.html"><strong aria-hidden="true">18.2.</strong> Variance</a></li></ol></li><li><a href="mir/index.html"><strong aria-hidden="true">19.</strong> The MIR (Mid-level IR)</a></li><li><ol class="section"><li><a href="mir/construction.html"><strong aria-hidden="true">19.1.</strong> MIR construction</a></li><li><a href="mir/visitor.html"><strong aria-hidden="true">19.2.</strong> MIR visitor and traversal</a></li><li><a href="mir/passes.html"><strong aria-hidden="true">19.3.</strong> MIR passes: getting the MIR for a function</a></li><li><a href="mir/borrowck.html"><strong aria-hidden="true">19.4.</strong> MIR borrowck</a></li><li><ol class="section"><li><a href="mir/regionck.html"><strong aria-hidden="true">19.4.1.</strong> MIR-based region checking (NLL)</a></li></ol></li><li><a href="mir/optimizations.html"><strong aria-hidden="true">19.5.</strong> MIR optimizations</a></li></ol></li><li><a href="const-eval.html"><strong aria-hidden="true">20.</strong> Constant evaluation</a></li><li><ol class="section"><li><a href="miri.html"><strong aria-hidden="true">20.1.</strong> miri const evaluator</a></li></ol></li><li><a href="param_env.html"><strong aria-hidden="true">21.</strong> Parameter Environments</a></li><li><a href="trans.html"><strong aria-hidden="true">22.</strong> Generating LLVM IR</a></li><li><a href="diag.html"><strong aria-hidden="true">23.</strong> Emitting Diagnostics</a></li><li class="spacer"></li><li><a href="appendix/stupid-stats.html"><strong aria-hidden="true">25.</strong> Appendix A: Stupid Stats</a></li><li><a href="appendix/background.html"><strong aria-hidden="true">26.</strong> Appendix B: Background material</a></li><li><a href="appendix/glossary.html"><strong aria-hidden="true">27.</strong> Appendix C: Glossary</a></li><li><a href="appendix/code-index.html"><strong aria-hidden="true">28.</strong> Appendix D: Code Index</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Guide to Rustc Development</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="print.html#about-this-guide" id="about-this-guide"><h1>About this guide</h1></a>
<p>This guide is meant to help document how rustc – the Rust compiler –
works, as well as to help new contributors get involved in rustc
development. It is not meant to replace code documentation – each
chapter gives only high-level details – the kinds of things that
(ideally) don't change frequently.</p>
<p>The guide itself is of course open-source as well, and the sources can
be found at the <a href="https://github.com/rust-lang-nursery/rustc-guide/">GitHub repository</a>. If you find any mistakes in the
guide, please file an issue about it, or even better, open a PR
with a correction!</p>
<a class="header" href="print.html#how-to-build-the-compiler-and-run-what-you-built" id="how-to-build-the-compiler-and-run-what-you-built"><h1>How to build the compiler and run what you built</h1></a>
<p>The compiler is built using a tool called <code>x.py</code>. You will need to
have Python installed to run it. But before we get to that, if you're going to
be hacking on <code>rustc</code>, you'll want to tweak the configuration of the compiler.
The default configuration is oriented towards running the compiler as a user,
not a developer.</p>
<a class="header" href="print.html#create-a-configtoml" id="create-a-configtoml"><h3>Create a config.toml</h3></a>
<p>To start, copy <a href="https://github.com/rust-lang/rust/blob/master/config.toml.example"><code>config.toml.example</code></a> to <code>config.toml</code>:</p>
<pre><code class="language-bash">&gt; cd $RUST_CHECKOUT
&gt; cp config.toml.example config.toml
</code></pre>
<p>Then you will want to open up the file and change the following
settings (and possibly others, such as <code>llvm.ccache</code>):</p>
<pre><code class="language-toml">[llvm]
# Enables LLVM assertions, which will check that the LLVM bitcode generated
# by the compiler is internally consistent. These are particularly helpful
# if you edit `trans`.
assertions = true

[rust]
# This enables some assertions, but more importantly it enables the `debug!`
# logging macros that are essential for debugging rustc.
debug-assertions = true

# This will make your build more parallel; it costs a bit of runtime
# performance perhaps (less inlining) but it's worth it.
codegen-units = 0

# I always enable full debuginfo, though debuginfo-lines is more important.
debuginfo = true

# Gives you line numbers for backtraces.
debuginfo-lines = true

# Using the system allocator (instead of jemalloc) means that tools
# like valgrind and memcache work better.
use-jemalloc = false
</code></pre>
<a class="header" href="print.html#running-xpy-and-building-a-stage1-compiler" id="running-xpy-and-building-a-stage1-compiler"><h3>Running x.py and building a stage1 compiler</h3></a>
<p>One thing to keep in mind is that <code>rustc</code> is a <em>bootstrapping</em> compiler. That
is, since <code>rustc</code> is written in Rust, we need to use an older version of the
compiler to compile the newer version. In particular, the newer version of the
compiler, <code>libstd</code>, and other tooling may use some unstable features
internally. The result is the compiling <code>rustc</code> is done in stages.</p>
<ul>
<li><strong>Stage 0:</strong> the stage0 compiler can be your existing
(perhaps older version of)
Rust compiler, the current <em>beta</em> compiler or you may download the binary
from the internet.</li>
<li><strong>Stage 1:</strong> the code in your clone (for new version)
is then compiled with the stage0
compiler to produce the stage1 compiler.
However, it was built with an older compiler (stage0),
so to optimize the stage1 compiler we go to next stage.</li>
<li><strong>Stage 2:</strong> we rebuild our stage1 compiler with itself
to produce the stage2 compiler (i.e. it builds
itself) to have all the <em>latest optimizations</em>.</li>
<li><em>(Optional)</em> <strong>Stage 3</strong>: to sanity check of our new compiler,
we can build it again
with stage2 compiler which must be identical to itself,
unless something has broken.</li>
</ul>
<p>For hacking, often building the stage 1 compiler is enough, but for
final testing and release, the stage 2 compiler is used.</p>
<p><code>./x.py check</code> is really fast to build the rust compiler.
It is, in particular, very useful when you're doing some kind of
&quot;type-based refactoring&quot;, like renaming a method, or changing the
signature of some function.</p>
<p>Once you've created a config.toml, you are now ready to run
<code>x.py</code>. There are a lot of options here, but let's start with what is
probably the best &quot;go to&quot; command for building a local rust:</p>
<pre><code class="language-bash">&gt; ./x.py build -i --stage 1 src/libstd
</code></pre>
<p>What this command will do is the following:</p>
<ul>
<li>Using the beta compiler (also called stage 0), it will build the
standard library and rustc from the <code>src</code> directory. The resulting
compiler is called the &quot;stage 1&quot; compiler.
<ul>
<li>During this build, the <code>-i</code> (or <code>--incremental</code>) switch enables incremental
compilation, so that if you later rebuild after editing things in
<code>src</code>, you can save a bit of time.</li>
</ul>
</li>
<li>Using this stage 1 compiler, it will build the standard library.
(this is what the <code>src/libstd</code>) means.</li>
</ul>
<p>This is just a subset of the full rustc build. The <strong>full</strong> rustc build
(what you get if you just say <code>./x.py build</code>) has quite a few more steps:</p>
<ul>
<li>Build stage1 rustc with stage0 compiler.</li>
<li>Build libstd with stage1 compiler (up to here is the same).</li>
<li>Build rustc from <code>src</code> again, this time with the stage1 compiler
(this part is new).
<ul>
<li>The resulting compiler here is called the &quot;stage2&quot; compiler.</li>
</ul>
</li>
<li>Build libstd with stage2 compiler.</li>
<li>Build librustdoc and a bunch of other things.</li>
</ul>
<a class="header" href="print.html#creating-a-rustup-toolchain" id="creating-a-rustup-toolchain"><h3>Creating a rustup toolchain</h3></a>
<p>Once you have successfully built rustc, you will have created a bunch
of files in your <code>build</code> directory. In order to actually run the
resulting rustc, we recommend creating rustup toolchains. The first
one will run the stage1 compiler (which we built above). The second
will execute the stage2 compiler (which we did not build, but which
you will likely need to build at some point; for example, if you want
to run the entire test suite).</p>
<pre><code class="language-bash">&gt; rustup toolchain link stage1 build/&lt;host-triple&gt;/stage1
&gt; rustup toolchain link stage2 build/&lt;host-triple&gt;/stage2
</code></pre>
<p>Now you can run the rustc you built with. If you run with <code>-vV</code>, you
should see a version number ending in <code>-dev</code>, indicating a build from
your local environment:</p>
<pre><code class="language-bash">&gt; rustc +stage1 -vV
rustc 1.25.0-dev
binary: rustc
commit-hash: unknown
commit-date: unknown
host: x86_64-unknown-linux-gnu
release: 1.25.0-dev
LLVM version: 4.0
</code></pre>
<a class="header" href="print.html#other-xpy-commands" id="other-xpy-commands"><h3>Other x.py commands</h3></a>
<p>Here are a few other useful x.py commands. We'll cover some of them in detail
in other sections:</p>
<ul>
<li>Building things:
<ul>
<li><code>./x.py clean</code> – clean up the build directory (<code>rm -rf build</code> works too,
but then you have to rebuild LLVM)</li>
<li><code>./x.py build --stage 1</code> – builds everything using the stage 1 compiler,
not just up to libstd</li>
<li><code>./x.py build</code> – builds the stage2 compiler</li>
</ul>
</li>
<li>Running tests (see the <a href="./tests/running.html">section on running tests</a> for
more details):
<ul>
<li><code>./x.py test --stage 1 src/libstd</code> – runs the <code>#[test]</code> tests from libstd</li>
<li><code>./x.py test --stage 1 src/test/run-pass</code> – runs the <code>run-pass</code> test suite</li>
</ul>
</li>
</ul>
<p>This file offers some tips on the coding conventions for rustc.  This
chapter covers <a href="print.html#formatting">formatting</a>, <a href="print.html#cc">coding for correctness</a>,
<a href="print.html#cio">using crates from crates.io</a>, and some tips on
<a href="print.html#er">structuring your PR for easy review</a>.</p>
<p><a name="formatting"></a></p>
<a class="header" href="print.html#formatting-and-the-tidy-script" id="formatting-and-the-tidy-script"><h1>Formatting and the tidy script</h1></a>
<p>rustc is slowly moving towards the <a href="https://github.com/rust-lang-nursery/fmt-rfcs">Rust standard coding style</a>;
at the moment, however, it follows a rather more <em>chaotic</em> style.  We
do have some mandatory formatting conventions, which are automatically
enforced by a script we affectionately call the &quot;tidy&quot; script.  The
tidy script runs automatically when you do <code>./x.py test</code> and can be run
in isolation with <code>./x.py test src/tools/tidy</code>.</p>
<p><a name="copyright"></a></p>
<a class="header" href="print.html#copyright-notice" id="copyright-notice"><h3>Copyright notice</h3></a>
<p>All files must begin with the following copyright notice:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT
// file at the top-level directory of this distribution and at
// http://rust-lang.org/COPYRIGHT.
//
// Licensed under the Apache License, Version 2.0 &lt;LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0&gt; or the MIT license
// &lt;LICENSE-MIT or http://opensource.org/licenses/MIT&gt;, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.
#}</code></pre></pre>
<p>The year at the top is not meaningful: copyright protections are in
fact automatic from the moment of authorship. We do not typically edit
the years on existing files. When creating a new file, you can use the
current year if you like, but you don't have to.</p>
<a class="header" href="print.html#line-length" id="line-length"><h2>Line length</h2></a>
<p>Lines should be at most 100 characters. It's even better if you can
keep things to 80.</p>
<p><strong>Ignoring the line length limit.</strong> Sometimes -- in particular for
tests -- it can be necessary to exempt yourself from this limit. In
that case, you can add a comment towards the top of the file (after
the copyright notice) like so:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// ignore-tidy-linelength
#}</code></pre></pre>
<a class="header" href="print.html#tabs-vs-spaces" id="tabs-vs-spaces"><h2>Tabs vs spaces</h2></a>
<p>Prefer 4-space indent.</p>
<p><a name="cc"></a></p>
<a class="header" href="print.html#coding-for-correctness" id="coding-for-correctness"><h1>Coding for correctness</h1></a>
<p>Beyond formatting, there are a few other tips that are worth
following.</p>
<a class="header" href="print.html#prefer-exhaustive-matches" id="prefer-exhaustive-matches"><h2>Prefer exhaustive matches</h2></a>
<p>Using <code>_</code> in a match is convenient, but it means that when new
variants are added to the enum, they may not get handled correctly.
Ask yourself: if a new variant were added to this enum, what's the
chance that it would want to use the <code>_</code> code, versus having some
other treatment?  Unless the answer is &quot;low&quot;, then prefer an
exhaustive match. (The same advice applies to <code>if let</code> and <code>while let</code>, which are effectively tests for a single variant.)</p>
<a class="header" href="print.html#use-todo-comments-for-things-you-dont-want-to-forget" id="use-todo-comments-for-things-you-dont-want-to-forget"><h2>Use &quot;TODO&quot; comments for things you don't want to forget</h2></a>
<p>As a useful tool to yourself, you can insert a <code>// TODO</code> comment
for something that you want to get back to before you land your PR:</p>
<pre><code class="language-rust ignore">fn do_something() {
    if something_else {
        unimplemented!(): // TODO write this
    }
}
</code></pre>
<p>The tidy script will report an error for a <code>// TODO</code> comment, so this
code would not be able to land until the TODO is fixed (or removed).</p>
<p>This can also be useful in a PR as a way to signal from one commit that you are
leaving a bug that a later commit will fix:</p>
<pre><code class="language-rust ignore">if foo {
    return true; // TODO wrong, but will be fixed in a later commit
}
</code></pre>
<p><a name="cio"></a></p>
<a class="header" href="print.html#using-crates-from-cratesio" id="using-crates-from-cratesio"><h1>Using crates from crates.io</h1></a>
<p>It is allowed to use crates from crates.io, though external
dependencies should not be added gratuitously. All such crates must
have a suitably permissive license. There is an automatic check which
inspects the Cargo metadata to ensure this.</p>
<p><a name="er"></a></p>
<a class="header" href="print.html#how-to-structure-your-pr" id="how-to-structure-your-pr"><h1>How to structure your PR</h1></a>
<p>How you prepare the commits in your PR can make a big difference for the
reviewer.  Here are some tips.</p>
<p><strong>Isolate &quot;pure refactorings&quot; into their own commit.</strong> For example, if
you rename a method, then put that rename into its own commit, along
with the renames of all the uses.</p>
<p><strong>More commits is usually better.</strong> If you are doing a large change,
it's almost always better to break it up into smaller steps that can
be independently understood. The one thing to be aware of is that if
you introduce some code following one strategy, then change it
dramatically (versus adding to it) in a later commit, that
'back-and-forth' can be confusing.</p>
<p><strong>If you run rustfmt and the file was not already formatted, isolate
that into its own commit.</strong> This is really the same as the previous
rule, but it's worth highlighting. It's ok to rustfmt files, but since
we do not currently run rustfmt all the time, that can introduce a lot
of noise into your commit. Please isolate that into its own
commit. This also makes rebases a lot less painful, since rustfmt
tends to cause a lot of merge conflicts, and having those isolated
into their own commit makes them easier to resolve.</p>
<p><strong>No merges.</strong> We do not allow merge commits into our history, other
than those by bors. If you get a merge conflict, rebase instead via a
command like <code>git rebase -i rust-lang/master</code> (presuming you use the
name <code>rust-lang</code> for your remote).</p>
<p><strong>Individual commits do not have to build (but it's nice).</strong> We do not
require that every intermediate commit successfully builds -- we only
expect to be able to bisect at a PR level. However, if you <em>can</em> make
individual commits build, that is always helpful.</p>
<a class="header" href="print.html#the-compiler-testing-framework" id="the-compiler-testing-framework"><h1>The compiler testing framework</h1></a>
<p>The Rust project runs a wide variety of different tests, orchestrated
by the build system (<code>x.py test</code>).  The main test harness for testing
the compiler itself is a tool called compiletest (sources in the
<a href="https://github.com/rust-lang/rust/tree/master/src/tools/compiletest"><code>src/tools/compiletest</code></a>). This section gives a brief overview of how
the testing framework is setup, and then gets into some of the details
on <a href="./tests/running.html#ui">how to run tests</a> as well as
<a href="./tests/adding.html">how to add new tests</a>.</p>
<a class="header" href="print.html#compiletest-test-suites" id="compiletest-test-suites"><h2>Compiletest test suites</h2></a>
<p>The compiletest tests are located in the tree in the <a href="https://github.com/rust-lang/rust/tree/master/src/test"><code>src/test</code></a>
directory. Immediately within you will see a series of subdirectories
(e.g. <code>ui</code>, <code>run-make</code>, and so forth). Each of those directories is
called a <strong>test suite</strong> -- they house a group of tests that are run in
a distinct mode.</p>
<p>Here is a brief summary of the test suites as of this writing and what
they mean. In some cases, the test suites are linked to parts of the manual
that give more details.</p>
<ul>
<li><a href="./tests/adding.html#ui"><code>ui</code></a> -- tests that check the exact
stdout/stderr from compilation and/or running the test</li>
<li><code>run-pass</code> -- tests that are expected to compile and execute
successfully (no panics)
<ul>
<li><code>run-pass-valgrind</code> -- tests that ought to run with valgrind</li>
</ul>
</li>
<li><code>run-fail</code> -- tests that are expected to compile but then panic
during execution</li>
<li><code>compile-fail</code> -- tests that are expected to fail compilation.</li>
<li><code>parse-fail</code> -- tests that are expected to fail to parse</li>
<li><code>pretty</code> -- tests targeting the Rust &quot;pretty printer&quot;, which
generates valid Rust code from the AST</li>
<li><code>debuginfo</code> -- tests that run in gdb or lldb and query the debug info</li>
<li><code>codegen</code> -- tests that compile and then test the generated LLVM
code to make sure that the optimizations we want are taking effect.</li>
<li><code>mir-opt</code> -- tests that check parts of the generated MIR to make
sure we are building things correctly or doing the optimizations we
expect.</li>
<li><code>incremental</code> -- tests for incremental compilation, checking that
when certain modifications are performed, we are able to reuse the
results from previous compilations.</li>
<li><code>run-make</code> -- tests that basically just execute a <code>Makefile</code>; the
ultimate in flexibility but quite annoying to write.</li>
<li><code>rustdoc</code> -- tests for rustdoc, making sure that the generated files
contain the expected documentation.</li>
<li><code>*-fulldeps</code> -- same as above, but indicates that the test depends
on things other than <code>libstd</code> (and hence those things must be built)</li>
</ul>
<a class="header" href="print.html#other-tests" id="other-tests"><h2>Other Tests</h2></a>
<p>The Rust build system handles running tests for various other things,
including:</p>
<ul>
<li>
<p><strong>Tidy</strong> -- This is a custom tool used for validating source code
style and formatting conventions, such as rejecting long lines.
There is more information in the
<a href="./conventions.html#formatting">section on coding conventions</a>.</p>
<p>Example: <code>./x.py test src/tools/tidy</code></p>
</li>
<li>
<p><strong>Unittests</strong> -- The Rust standard library and many of the Rust packages
include typical Rust <code>#[test]</code> unittests.  Under the hood, <code>x.py</code> will run
<code>cargo test</code> on each package to run all the tests.</p>
<p>Example: <code>./x.py test src/libstd</code></p>
</li>
<li>
<p><strong>Doctests</strong> -- Example code embedded within Rust documentation is executed
via <code>rustdoc --test</code>.  Examples:</p>
<p><code>./x.py test src/doc</code> -- Runs <code>rustdoc --test</code> for all documentation in
<code>src/doc</code>.</p>
<p><code>./x.py test --doc src/libstd</code> -- Runs <code>rustdoc --test</code> on the standard
library.</p>
</li>
<li>
<p><strong>Linkchecker</strong> -- A small tool for verifying <code>href</code> links within
documentation.</p>
<p>Example: <code>./x.py test src/tools/linkchecker</code></p>
</li>
<li>
<p><strong>Distcheck</strong> -- This verifies that the source distribution tarball created
by the build system will unpack, build, and run all tests.</p>
<p>Example: <code>./x.py test distcheck</code></p>
</li>
<li>
<p><strong>Tool tests</strong> -- Packages that are included with Rust have all of their
tests run as well (typically by running <code>cargo test</code> within their
directory).  This includes things such as cargo, clippy, rustfmt, rls, miri,
bootstrap (testing the Rust build system itself), etc.</p>
</li>
<li>
<p><strong>Cargotest</strong> -- This is a small tool which runs <code>cargo test</code> on a few
significant projects (such as <code>servo</code>, <code>ripgrep</code>, <code>tokei</code>, etc.) just to
ensure there aren't any significant regressions.</p>
<p>Example: <code>./x.py test src/tools/cargotest</code></p>
</li>
</ul>
<a class="header" href="print.html#testing-infrastructure" id="testing-infrastructure"><h2>Testing infrastructure</h2></a>
<p>When a Pull Request is opened on Github, <a href="https://travis-ci.org/rust-lang/rust">Travis</a> will automatically launch a
build that will run all tests on a single configuration (x86-64 linux). In
essence, it runs <code>./x.py test</code> after building.</p>
<p>The integration bot <a href="https://github.com/servo/homu">bors</a> is used for coordinating merges to the master
branch. When a PR is approved, it goes into a <a href="https://buildbot2.rust-lang.org/homu/queue/rust">queue</a> where merges are tested
one at a time on a wide set of platforms using Travis and <a href="https://ci.appveyor.com/project/rust-lang/rust">Appveyor</a>
(currently over 50 different configurations).  Most platforms only run the
build steps, some run a restricted set of tests, only a subset run the full
suite of tests (see Rust's <a href="https://forge.rust-lang.org/platform-support.html">platform tiers</a>).</p>
<a class="header" href="print.html#testing-with-docker-images" id="testing-with-docker-images"><h2>Testing with Docker images</h2></a>
<p>The Rust tree includes <a href="https://www.docker.com/">Docker</a> image definitions for the platforms used on
Travis in <a href="https://github.com/rust-lang/rust/tree/master/src/ci/docker">src/ci/docker</a>.  The script <a href="https://github.com/rust-lang/rust/blob/master/src/ci/docker/run.sh">src/ci/docker/run.sh</a> is used to build
the Docker image, run it, build Rust within the image, and run the tests.</p>
<blockquote>
<p>TODO: What is a typical workflow for testing/debugging on a platform that
you don't have easy access to?  Do people build Docker images and enter them
to test things out?</p>
</blockquote>
<a class="header" href="print.html#testing-on-emulators" id="testing-on-emulators"><h2>Testing on emulators</h2></a>
<p>Some platforms are tested via an emulator for architectures that aren't
readily available.  There is a set of tools for orchestrating running the
tests within the emulator.  Platforms such as <code>arm-android</code> and
<code>arm-unknown-linux-gnueabihf</code> are set up to automatically run the tests under
emulation on Travis.  The following will take a look at how a target's tests
are run under emulation.</p>
<p>The Docker image for <a href="https://github.com/rust-lang/rust/tree/master/src/ci/docker/armhf-gnu">armhf-gnu</a> includes <a href="https://www.qemu.org/">QEMU</a> to emulate the ARM CPU
architecture.  Included in the Rust tree are the tools <a href="https://github.com/rust-lang/rust/tree/master/src/tools/remote-test-client">remote-test-client</a>
and <a href="https://github.com/rust-lang/rust/tree/master/src/tools/remote-test-server">remote-test-server</a> which are programs for sending test programs and
libraries to the emulator, and running the tests within the emulator, and
reading the results.  The Docker image is set up to launch
<code>remote-test-server</code> and the build tools use <code>remote-test-client</code> to
communicate with the server to coordinate running tests (see
<a href="https://github.com/rust-lang/rust/tree/master/src/bootstrap/test.rs">src/bootstrap/test.rs</a>).</p>
<blockquote>
<p>TODO: What are the steps for manually running tests within an emulator?
<code>./src/ci/docker/run.sh armhf-gnu</code> will do everything, but takes hours to
run and doesn't offer much help with interacting within the emulator.</p>
<p>Is there any support for emulating other (non-Android) platforms, such as
running on an iOS emulator?</p>
<p>Is there anything else interesting that can be said here about running tests
remotely on real hardware?</p>
<p>It's also unclear to me how the wasm or asm.js tests are run.</p>
</blockquote>
<a class="header" href="print.html#crater" id="crater"><h2>Crater</h2></a>
<p>TODO</p>
<a class="header" href="print.html#further-reading" id="further-reading"><h2>Further reading</h2></a>
<p>The following blog posts may also be of interest:</p>
<ul>
<li>brson's classic <a href="https://brson.github.io/2017/07/10/how-rust-is-tested">&quot;How Rust is tested&quot;</a></li>
</ul>
<a class="header" href="print.html#running-tests" id="running-tests"><h1>Running tests</h1></a>
<p>You can run the tests using <code>x.py</code>. The most basic command -- which
you will almost never want to use! -- is as follows:</p>
<pre><code class="language-bash">&gt; ./x.py test
</code></pre>
<p>This will build the full stage 2 compiler and then run the whole test
suite. You probably don't want to do this very often, because it takes
a very long time, and anyway bors / travis will do it for you. (Often,
I will run this command in the background after opening a PR that I
think is done, but rarely otherwise. -nmatsakis)</p>
<p>The test results are cached and previously successful tests are
<code>ignored</code> during testing. The stdout/stderr contents as well as a
timestamp file for every test can be found under <code>build/ARCH/test/</code>.
To force-rerun a test (e.g. in case the test runner fails to notice
a change) you can simply remove the timestamp file.</p>
<a class="header" href="print.html#running-a-subset-of-the-test-suites" id="running-a-subset-of-the-test-suites"><h2>Running a subset of the test suites</h2></a>
<p>When working on a specific PR, you will usually want to run a smaller
set of tests, and with a stage 1 build. For example, a good &quot;smoke
test&quot; that can be used after modifying rustc to see if things are
generally working correctly would be the following:</p>
<pre><code class="language-bash">&gt; ./x.py test --stage 1 src/test/{ui,compile-fail,run-pass}
</code></pre>
<p>This will run the <code>ui</code>, <code>compile-fail</code>, and <code>run-pass</code> test suites,
and only with the stage 1 build. Of course, the choice of test suites
is somewhat arbitrary, and may not suit the task you are doing. For
example, if you are hacking on debuginfo, you may be better off with
the debuginfo test suite:</p>
<pre><code class="language-bash">&gt; ./x.py test --stage 1 src/test/debuginfo
</code></pre>
<p><strong>Warning:</strong> Note that bors only runs the tests with the full stage 2
build; therefore, while the tests <strong>usually</strong> work fine with stage 1,
there are some limitations. In particular, the stage1 compiler doesn't
work well with procedural macros or custom derive tests.</p>
<a class="header" href="print.html#running-an-individual-test" id="running-an-individual-test"><h2>Running an individual test</h2></a>
<p>Another common thing that people want to do is to run an <strong>individual
test</strong>, often the test they are trying to fix. One way to do this is
to invoke <code>x.py</code> with the <code>--test-args</code> option:</p>
<pre><code class="language-bash">&gt; ./x.py test --stage 1 src/test/ui --test-args issue-1234
</code></pre>
<p>Under the hood, the test runner invokes the standard rust test runner
(the same one you get with <code>#[test]</code>), so this command would wind up
filtering for tests that include &quot;issue-1234&quot; in the name.</p>
<p>Often, though, it's easier to just run the test by hand. Most tests are
just <code>rs</code> files, so you can do something like</p>
<pre><code class="language-bash">&gt; rustc +stage1 src/test/ui/issue-1234.rs
</code></pre>
<p>This is much faster, but doesn't always work. For example, some tests
include directives that specify specific compiler flags, or which rely
on other crates, and they may not run the same without those options.</p>
<a class="header" href="print.html#adding-new-tests" id="adding-new-tests"><h1>Adding new tests</h1></a>
<p><strong>In general, we expect every PR that fixes a bug in rustc to come
accompanied by a regression test of some kind.</strong> This test should fail
in master but pass after the PR. These tests are really useful for
preventing us from repeating the mistakes of the past.</p>
<p>To add a new test, the first thing you generally do is to create a
file, typically a Rust source file. Test files have a particular
structure:</p>
<ul>
<li>They always begin with the <a href="./conventions.html#copyright">copyright notice</a>;</li>
<li>then they should have some kind of
<a href="print.html#explanatory_comment">comment explaining what the test is about</a>;</li>
<li>next, they can have one or more <a href="print.html#header_commands">header commands</a>, which
are special comments that the test interpreter knows how to interpret.</li>
<li>finally, they have the Rust source. This may have various <a href="print.html#error_annotations">error
annotations</a> which indicate expected compilation errors or
warnings.</li>
</ul>
<p>Depending on the test suite, there may be some other details to be aware of:</p>
<ul>
<li>For <a href="print.html#ui">the <code>ui</code> test suite</a>, you need to generate reference output files.</li>
</ul>
<a class="header" href="print.html#what-kind-of-test-should-i-add" id="what-kind-of-test-should-i-add"><h2>What kind of test should I add?</h2></a>
<p>It can be difficult to know what kind of test to use. Here are some
rough heuristics:</p>
<ul>
<li>Some tests have specialized needs:
<ul>
<li>need to run gdb or lldb? use the <code>debuginfo</code> test suite</li>
<li>need to inspect LLVM IR or MIR IR? use the <code>codegen</code> or <code>mir-opt</code> test
suites</li>
<li>need to run rustdoc? Prefer a <code>rustdoc</code> test</li>
<li>need to inspect the resulting binary in some way? Then use <code>run-make</code></li>
</ul>
</li>
<li>For most other things, <a href="print.html#ui">a <code>ui</code> (or <code>ui-fulldeps</code>) test</a> is to be
preferred:
<ul>
<li><code>ui</code> tests subsume both run-pass, compile-fail, and parse-fail tests</li>
<li>in the case of warnings or errors, <code>ui</code> tests capture the full output,
which makes it easier to review but also helps prevent &quot;hidden&quot; regressions
in the output</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#naming-your-test" id="naming-your-test"><h2>Naming your test</h2></a>
<p>We have not traditionally had a lot of structure in the names of
tests.  Moreover, for a long time, the rustc test runner did not
support subdirectories (it now does), so test suites like
<a href="https://github.com/rust-lang/rust/tree/master/src/test/run-pass/"><code>src/test/run-pass</code></a> have a huge mess of files in them. This is not
considered an ideal setup.</p>
<p>For regression tests -- basically, some random snippet of code that
came in from the internet -- we often just name the test after the
issue. For example, <code>src/test/run-pass/issue-12345.rs</code>. If possible,
though, it is better if you can put the test into a directory that
helps identify what piece of code is being tested here (e.g.,
<code>borrowck/issue-12345.rs</code> is much better), or perhaps give it a more
meaningful name. Still, <strong>do include the issue number somewhere</strong>.</p>
<p>When writing a new feature, <strong>create a subdirectory to store your
tests</strong>. For example, if you are implementing RFC 1234 (&quot;Widgets&quot;),
then it might make sense to put the tests in directories like:</p>
<ul>
<li><code>src/test/ui/rfc1234-widgets/</code></li>
<li><code>src/test/run-pass/rfc1234-widgets/</code></li>
<li>etc</li>
</ul>
<p>In other cases, there may already be a suitable directory. (The proper
directory structure to use is actually an area of active debate.)</p>
<p><a name="explanatory_comment"></a></p>
<a class="header" href="print.html#comment-explaining-what-the-test-is-about" id="comment-explaining-what-the-test-is-about"><h2>Comment explaining what the test is about</h2></a>
<p>When you create a test file, <strong>include a comment summarizing the point
of the test immediately after the copyright notice</strong>. This should
highlight which parts of the test are more important, and what the bug
was that the test is fixing.  Citing an issue number is often very
helpful.</p>
<p>This comment doesn't have to be super extensive. Just something like
&quot;Regression test for #18060: match arms were matching in the wrong
order.&quot;  might already be enough.</p>
<p>These comments are very useful to others later on when your test
breaks, since they often can highlight what the problem is. They are
also useful if for some reason the tests need to be refactored, since
they let others know which parts of the test were important (often a
test must be rewritten because it no longer tests what is was meant to
test, and then it's useful to know what it <em>was</em> meant to test
exactly).</p>
<p><a name="header_commands"></a></p>
<a class="header" href="print.html#header-commands-configuring-rustc" id="header-commands-configuring-rustc"><h2>Header commands: configuring rustc</h2></a>
<p>Header commands are special comments that the test runner knows how to
interpret.  They must appear before the Rust source in the test. They
are normally put after the short comment that explains the point of
this test. For example, this test uses the <code>// compile-flags</code> command
to specify a custom flag to give to rustc when the test is compiled:</p>
<pre><code class="language-rust ignore">// Copyright 2017 The Rust Project Developers. blah blah blah.
// ...
// except according to those terms.

// Test the behavior of `0 - 1` when overflow checks are disabled.

// compile-flags: -Coverflow-checks=off

fn main() {
    let x = 0 - 1;
    ...
}
</code></pre>
<a class="header" href="print.html#ignoring-tests" id="ignoring-tests"><h3>Ignoring tests</h3></a>
<p>These are used to ignore the test in some situations, which means the test won't
be compiled or run.</p>
<ul>
<li><code>ignore-X</code> where <code>X</code> is a target detail or stage will ignore the
test accordingly (see below)</li>
<li><code>only-X</code> is like <code>ignore-X</code>, but will <em>only</em> run the test on that
target or stage</li>
<li><code>ignore-pretty</code> will not compile the pretty-printed test (this is
done to test the pretty-printer, but might not always work)</li>
<li><code>ignore-test</code> always ignores the test</li>
<li><code>ignore-lldb</code> and <code>ignore-gdb</code> will skip a debuginfo test on that
debugger.</li>
</ul>
<p>Some examples of <code>X</code> in <code>ignore-X</code>:</p>
<ul>
<li>Architecture: <code>aarch64</code>, <code>arm</code>, <code>asmjs</code>, <code>mips</code>, <code>wasm32</code>, <code>x86_64</code>,
<code>x86</code>, ...</li>
<li>OS: <code>android</code>, <code>emscripten</code>, <code>freebsd</code>, <code>ios</code>, <code>linux</code>, <code>macos</code>,
<code>windows</code>, ...</li>
<li>Environment (fourth word of the target triple): <code>gnu</code>, <code>msvc</code>,
<code>musl</code>.</li>
<li>Pointer width: <code>32bit</code>, <code>64bit</code>.</li>
<li>Stage: <code>stage0</code>, <code>stage1</code>, <code>stage2</code>.</li>
</ul>
<a class="header" href="print.html#other-header-commands" id="other-header-commands"><h3>Other Header Commands</h3></a>
<p>Here is a list of other header commands. This list is not
exhaustive. Header commands can generally be found by browsing the
<code>TestProps</code> structure found in <a href="https://github.com/rust-lang/rust/tree/master/src/tools/compiletest/src/header.rs"><code>header.rs</code></a> from the compiletest
source.</p>
<ul>
<li><code>run-rustfix</code> for UI tests, indicates that the test produces
structured suggestions, which are then applied and the final
source is stored in a <code>.fixed</code> file and compiled again. The final
compilation is required to succeed.</li>
<li><code>min-{gdb,lldb}-version</code></li>
<li><code>min-llvm-version</code></li>
<li><code>compile-pass</code> for UI tests, indicates that the test is
supposed to compile, as opposed to the default where the test is
supposed to error out.</li>
<li><code>compile-flags</code> passes extra command-line args to the compiler,
e.g. <code>compile-flags -g</code> which forces debuginfo to be enabled.</li>
<li><code>should-fail</code> indicates that the test should fail; used for &quot;meta
testing&quot;, where we test the compiletest program itself to check that
it will generate errors in appropriate scenarios. This header is
ignored for pretty-printer tests.</li>
<li><code>gate-test-X</code> where <code>X</code> is a feature marks the test as &quot;gate test&quot;
for feature X.  Such tests are supposed to ensure that the compiler
errors when usage of a gated feature is attempted without the proper
<code>#![feature(X)]</code> tag.  Each unstable lang feature is required to
have a gate test.</li>
</ul>
<p><a name="error_annotations"></a></p>
<a class="header" href="print.html#error-annotations" id="error-annotations"><h2>Error annotations</h2></a>
<p>Error annotations specify the errors that the compiler is expected to
emit. They are &quot;attached&quot; to the line in source where the error is
located.</p>
<ul>
<li><code>~</code>: Associates the following error level and message with the
current line</li>
<li><code>~|</code>: Associates the following error level and message with the same
line as the previous comment</li>
<li><code>~^</code>: Associates the following error level and message with the
previous line. Each caret (<code>^</code>) that you add adds a line to this, so
<code>~^^^^^^^</code> is seven lines up.</li>
</ul>
<p>The error levels that you can have are:</p>
<ol>
<li><code>ERROR</code></li>
<li><code>WARNING</code></li>
<li><code>NOTE</code></li>
<li><code>HELP</code> and <code>SUGGESTION</code>*</li>
</ol>
<p>* <strong>Note</strong>: <code>SUGGESTION</code> must follow immediately after <code>HELP</code>.</p>
<a class="header" href="print.html#revisions" id="revisions"><h2>Revisions</h2></a>
<p>Certain classes of tests support &quot;revisions&quot; (as of the time of this
writing, this includes run-pass, compile-fail, run-fail, and
incremental, though incremental tests are somewhat
different). Revisions allow a single test file to be used for multiple
tests. This is done by adding a special header at the top of the file:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// revisions: foo bar baz
#}</code></pre></pre>
<p>This will result in the test being compiled (and tested) three times,
once with <code>--cfg foo</code>, once with <code>--cfg bar</code>, and once with <code>--cfg baz</code>. You can therefore use <code>#[cfg(foo)]</code> etc within the test to tweak
each of these results.</p>
<p>You can also customize headers and expected error messages to a particular
revision. To do this, add <code>[foo]</code> (or <code>bar</code>, <code>baz</code>, etc) after the <code>//</code>
comment, like so:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// A flag to pass in only for cfg `foo`:
//[foo]compile-flags: -Z verbose

#[cfg(foo)]
fn test_foo() {
    let x: usize = 32_u32; //[foo]~ ERROR mismatched types
}
#}</code></pre></pre>
<p>Note that not all headers have meaning when customized to a revision.
For example, the <code>ignore-test</code> header (and all &quot;ignore&quot; headers)
currently only apply to the test as a whole, not to particular
revisions. The only headers that are intended to really work when
customized to a revision are error patterns and compiler flags.</p>
<p><a name="ui"></a></p>
<a class="header" href="print.html#guide-to-the-ui-tests" id="guide-to-the-ui-tests"><h2>Guide to the UI tests</h2></a>
<p>The UI tests are intended to capture the compiler's complete output,
so that we can test all aspects of the presentation. They work by
compiling a file (e.g., <a href="https://github.com/rust-lang/rust/blob/master/src/test/ui/hello_world/main.rs"><code>ui/hello_world/main.rs</code></a>),
capturing the output, and then applying some normalization (see
below). This normalized result is then compared against reference
files named <code>ui/hello_world/main.stderr</code> and
<code>ui/hello_world/main.stdout</code>. If either of those files doesn't exist,
the output must be empty (that is actually the case for
<a href="https://github.com/rust-lang/rust/blob/master/src/test/ui/hello_world/">this particular test</a>). If the test run fails, we will print out
the current output, but it is also saved in
<code>build/&lt;target-triple&gt;/test/ui/hello_world/main.stdout</code> (this path is
printed as part of the test failure message), so you can run <code>diff</code>
and so forth.</p>
<a class="header" href="print.html#tests-that-do-not-result-in-compile-errors" id="tests-that-do-not-result-in-compile-errors"><h3>Tests that do not result in compile errors</h3></a>
<p>By default, a UI test is expected <strong>not to compile</strong> (in which case,
it should contain at least one <code>//~ ERROR</code> annotation). However, you
can also make UI tests where compilation is expected to succeed, and
you can even run the resulting program. Just add one of the following
<a href="print.html#header_commands">header commands</a>:</p>
<ul>
<li><code>// compile-pass</code> -- compilation should succeed but do
not run the resulting binary</li>
<li><code>// run-pass</code> -- compilation should succeed and we should run the
resulting binary</li>
</ul>
<a class="header" href="print.html#editing-and-updating-the-reference-files" id="editing-and-updating-the-reference-files"><h3>Editing and updating the reference files</h3></a>
<p>If you have changed the compiler's output intentionally, or you are
making a new test, you can pass <code>--bless</code> to the test subcommand. E.g.
if some tests in <code>src/test/ui</code> are failing, you can run</p>
<pre><code class="language-text">./x.py test --stage 1 src/test/ui --bless
</code></pre>
<p>to automatically adjust the <code>.stderr</code>, <code>.stdout</code> or <code>.fixed</code> files of
all tests. Of course you can also target just specific tests with the
<code>--test-args your_test_name</code> flag, just like when running the tests.</p>
<a class="header" href="print.html#normalization" id="normalization"><h3>Normalization</h3></a>
<p>The normalization applied is aimed at eliminating output difference
between platforms, mainly about filenames:</p>
<ul>
<li>the test directory is replaced with <code>$DIR</code></li>
<li>all backslashes (<code>\</code>) are converted to forward slashes (<code>/</code>) (for Windows)</li>
<li>all CR LF newlines are converted to LF</li>
</ul>
<p>Sometimes these built-in normalizations are not enough. In such cases, you
may provide custom normalization rules using the header commands, e.g.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// normalize-stdout-test: &quot;foo&quot; -&gt; &quot;bar&quot;
// normalize-stderr-32bit: &quot;fn\(\) \(32 bits\)&quot; -&gt; &quot;fn\(\) \($$PTR bits\)&quot;
// normalize-stderr-64bit: &quot;fn\(\) \(64 bits\)&quot; -&gt; &quot;fn\(\) \($$PTR bits\)&quot;
#}</code></pre></pre>
<p>This tells the test, on 32-bit platforms, whenever the compiler writes
<code>fn() (32 bits)</code> to stderr, it should be normalized to read <code>fn() ($PTR bits)</code>
instead. Similar for 64-bit. The replacement is performed by regexes using
default regex flavor provided by <code>regex</code> crate.</p>
<p>The corresponding reference file will use the normalized output to test both
32-bit and 64-bit platforms:</p>
<pre><code class="language-text">...
   |
   = note: source type: fn() ($PTR bits)
   = note: target type: u16 (16 bits)
...
</code></pre>
<p>Please see <a href="https://github.com/rust-lang/rust/blob/master/src/test/ui/transmute/main.rs"><code>ui/transmute/main.rs</code></a> and <a href="https://github.com/rust-lang/rust/blob/master/src/test/ui/transmute/main.stderr"><code>main.stderr</code></a> for a
concrete usage example.</p>
<p>Besides <code>normalize-stderr-32bit</code> and <code>-64bit</code>, one may use any target
information or stage supported by <code>ignore-X</code> here as well (e.g.
<code>normalize-stderr-windows</code> or simply <code>normalize-stderr-test</code> for unconditional
replacement).</p>
<a class="header" href="print.html#compiletest" id="compiletest"><h1><code>compiletest</code></h1></a>
<a class="header" href="print.html#introduction" id="introduction"><h2>Introduction</h2></a>
<p><code>compiletest</code> is the main test harness of the Rust test suite.  It allows
test authors to organize large numbers of tests (the Rust compiler has many
thousands), efficient test execution (parallel execution is supported), and
allows the test author to configure behavior and expected results of both
individual and groups of tests.</p>
<p><code>compiletest</code> tests may check test code for success, for failure or in some
cases, even failure to compile.  Tests are typically organized as a Rust source
file with annotations in comments before and/or within the test code, which
serve to direct <code>compiletest</code> on if or how to run the test, what behavior to
expect, and more.  If you are unfamiliar with the compiler testing framework,
see <a href="./tests/intro.html">this chapter</a> for additional background.</p>
<p>The tests themselves are typically (but not always) organized into
&quot;suites&quot;--for example, <code>run-pass</code>, a folder representing tests that should
succeed, <code>run-fail</code>, a folder holding tests that should compile successfully,
but return a failure (non-zero status), <code>compile-fail</code>, a folder holding tests
that should fail to compile, and many more.  The various suites are defined in
<a href="https://github.com/rust-lang/rust/tree/master/src/tools/compiletest/src/common.rs">src/tools/compiletest/src/common.rs</a> in the <code>pub struct Config</code>
declaration.  And a very good introduction to the different suites of compiler
tests along with details about them can be found in <a href="./tests/adding.html">Adding new
tests</a>.</p>
<a class="header" href="print.html#adding-a-new-test-file" id="adding-a-new-test-file"><h2>Adding a new test file</h2></a>
<p>Briefly, simply create your new test in the appropriate location under
<a href="https://github.com/rust-lang/rust/tree/master/src/test">src/test</a>. No registration of test files is necessary as <code>compiletest</code>
will scan the <a href="https://github.com/rust-lang/rust/tree/master/src/test">src/test</a> subfolder recursively, and will execute any Rust
source files it finds as tests.  See <a href="./tests/adding.html"><code>Adding new tests</code></a>
for a complete guide on how to adding new tests.</p>
<a class="header" href="print.html#header-commands" id="header-commands"><h2>Header Commands</h2></a>
<p>Source file annotations which appear in comments near the top of the source
file <em>before</em> any test code are known as header commands.  These commands can
instruct <code>compiletest</code> to ignore this test, set expectations on whether it is
expected to succeed at compiling, or what the test's return code is expected to
be.  Header commands (and their inline counterparts, Error Info commands) are
described more fully
<a href="./tests/adding.html#header-commands-configuring-rustc">here</a>.</p>
<a class="header" href="print.html#adding-a-new-header-command" id="adding-a-new-header-command"><h3>Adding a new header command</h3></a>
<p>Header commands are defined in the <code>TestProps</code> struct in
<a href="https://github.com/rust-lang/rust/tree/master/src/tools/compiletest/src/header.rs">src/tools/compiletest/src/header.rs</a>.  At a high level, there are
dozens of test properties defined here, all set to default values in the
<code>TestProp</code> struct's <code>impl</code> block. Any test can override this default value by
specifying the property in question as header command as a comment (<code>//</code>) in
the test source file, before any source code.</p>
<a class="header" href="print.html#using-a-header-command" id="using-a-header-command"><h4>Using a header command</h4></a>
<p>Here is an example, specifying the <code>must-compile-successfully</code> header command,
which takes no arguments, followed by the <code>failure-status</code> header command,
which takes a single argument (which, in this case is a value of 1).
<code>failure-status</code> is instructing <code>compiletest</code> to expect a failure status of 1
(rather than the current Rust default of 101 at the time of this writing).  The
header command and the argument list (if present) are typically separated by a
colon:</p>
<pre><code class="language-rust ignore">// Copyright 2018 The Rust Project Developers. See the COPYRIGHT
// file at the top-level directory of this distribution and at
// http://rust-lang.org/COPYRIGHT.
//
// Licensed under the Apache License, Version 2.0 &lt;LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0&gt; or the MIT license
// &lt;LICENSE-MIT or http://opensource.org/licenses/MIT&gt;, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

// must-compile-successfully
// failure-status: 1

#![feature(termination_trait)]

use std::io::{Error, ErrorKind};

fn main() -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    Err(Box::new(Error::new(ErrorKind::Other, &quot;returned Box&lt;Error&gt; from main()&quot;)))
}
</code></pre>
<a class="header" href="print.html#adding-a-new-header-command-property" id="adding-a-new-header-command-property"><h4>Adding a new header command property</h4></a>
<p>One would add a new header command if there is a need to define some test
property or behavior on an individual, test-by-test basis.  A header command
property serves as the header command's backing store (holds the command's
current value) at runtime.</p>
<p>To add a new header command property:
1. Look for the <code>pub struct TestProps</code> declaration in
<a href="https://github.com/rust-lang/rust/tree/master/src/tools/compiletest/src/header.rs">src/tools/compiletest/src/header.rs</a> and add the new public
property to the end of the declaration.
2. Look for the <code>impl TestProps</code> implementation block immediately following
the struct declaration and initialize the new property to its default
value.</p>
<a class="header" href="print.html#adding-a-new-header-command-parser" id="adding-a-new-header-command-parser"><h4>Adding a new header command parser</h4></a>
<p>When <code>compiletest</code> encounters a test file, it parses the file a line at a time
by calling every parser defined in the <code>Config</code> struct's implementation block,
also in <a href="https://github.com/rust-lang/rust/tree/master/src/tools/compiletest/src/header.rs">src/tools/compiletest/src/header.rs</a> (note the <code>Config</code>
struct's declaration block is found in
<a href="https://github.com/rust-lang/rust/tree/master/src/tools/compiletest/src/common.rs">src/tools/compiletest/src/common.rs</a>.  <code>TestProps</code>'s <code>load_from()</code>
method will try passing the current line of text to each parser, which, in turn
typically checks to see if the line begins with a particular commented (<code>//</code>)
header command such as <code>// must-compile-successfully</code> or <code>// failure-status</code>.
Whitespace after the comment marker is optional.</p>
<p>Parsers will override a given header command property's default value merely by
being specified in the test file as a header command or by having a parameter
value specified in the test file, depending on the header command.</p>
<p>Parsers defined in <code>impl Config</code> are typically named <code>parse_&lt;header_command&gt;</code>
(note kebab-case <code>&lt;header-command&gt;</code> transformed to snake-case
<code>&lt;header_command&gt;</code>).  <code>impl Config</code> also defines several 'low-level' parsers
which make it simple to parse common patterns like simple presence or not
(<code>parse_name_directive()</code>), header-command:parameter(s)
(<code>parse_name_value_directive()</code>), optional parsing only if a particular <code>cfg</code>
attribute is defined (<code>has_cfg_prefix()</code>) and many more.  The low-level parsers
are found near the end of the <code>impl Config</code> block; be sure to look through them
and their associated parsers immediately above to see how they are used to
avoid writing additional parsing code unneccessarily.</p>
<p>As a concrete example, here is the implementation for the
<code>parse_failure_status()</code> parser, in
<a href="https://github.com/rust-lang/rust/tree/master/src/tools/compiletest/src/header.rs">src/tools/compiletest/src/header.rs</a>:</p>
<pre><code class="language-diff">@@ -232,6 +232,7 @@ pub struct TestProps {
     // customized normalization rules
     pub normalize_stdout: Vec&lt;(String, String)&gt;,
     pub normalize_stderr: Vec&lt;(String, String)&gt;,
+    pub failure_status: i32,
 }

 impl TestProps {
@@ -260,6 +261,7 @@ impl TestProps {
             run_pass: false,
             normalize_stdout: vec![],
             normalize_stderr: vec![],
+            failure_status: 101,
         }
     }

@@ -383,6 +385,10 @@ impl TestProps {
             if let Some(rule) = config.parse_custom_normalization(ln, &quot;normalize-stderr&quot;) {
                 self.normalize_stderr.push(rule);
             }
+
+            if let Some(code) = config.parse_failure_status(ln) {
+                self.failure_status = code;
+            }
         });

         for key in &amp;[&quot;RUST_TEST_NOCAPTURE&quot;, &quot;RUST_TEST_THREADS&quot;] {
@@ -488,6 +494,13 @@ impl Config {
         self.parse_name_directive(line, &quot;pretty-compare-only&quot;)
     }

+    fn parse_failure_status(&amp;self, line: &amp;str) -&gt; Option&lt;i32&gt; {
+        match self.parse_name_value_directive(line, &quot;failure-status&quot;) {
+            Some(code) =&gt; code.trim().parse::&lt;i32&gt;().ok(),
+            _ =&gt; None,
+        }
+    }
</code></pre>
<a class="header" href="print.html#implementing-the-behavior-change" id="implementing-the-behavior-change"><h2>Implementing the behavior change</h2></a>
<p>When a test invokes a particular header command, it is expected that some
behavior will change as a result.  What behavior, obviously, will depend on the
purpose of the header command.  In the case of <code>failure-status</code>, the behavior
that changes is that <code>compiletest</code> expects the failure code defined by the
header command invoked in the test, rather than the default value.</p>
<p>Although specific to <code>failure-status</code> (as every header command will have a
different implementation in order to invoke behavior change) perhaps it is
helpful to see the behavior change implementation of one case, simply as an
example.  To implement <code>failure-status</code>, the <code>check_correct_failure_status()</code>
function found in the <code>TestCx</code> implementation block, located in
<a href="https://github.com/rust-lang/rust/tree/master/src/tools/compiletest/src/runtest.rs">src/tools/compiletest/src/runtest.rs</a>,
was modified as per below:</p>
<pre><code class="language-diff">@@ -295,11 +295,14 @@ impl&lt;'test&gt; TestCx&lt;'test&gt; {
     }

     fn check_correct_failure_status(&amp;self, proc_res: &amp;ProcRes) {
-        // The value the rust runtime returns on failure
-        const RUST_ERR: i32 = 101;
-        if proc_res.status.code() != Some(RUST_ERR) {
+        let expected_status = Some(self.props.failure_status);
+        let received_status = proc_res.status.code();
+
+        if expected_status != received_status {
             self.fatal_proc_rec(
-                &amp;format!(&quot;failure produced the wrong error: {}&quot;, proc_res.status),
+                &amp;format!(&quot;Error: expected failure status ({:?}) but received status {:?}.&quot;,
+                         expected_status,
+                         received_status),
                 proc_res,
             );
         }
@@ -320,7 +323,6 @@ impl&lt;'test&gt; TestCx&lt;'test&gt; {
         );

         let proc_res = self.exec_compiled_test();
-
         if !proc_res.status.success() {
             self.fatal_proc_rec(&quot;test run failed!&quot;, &amp;proc_res);
         }
@@ -499,7 +501,6 @@ impl&lt;'test&gt; TestCx&lt;'test&gt; {
                 expected,
                 actual
             );
-            panic!();
         }
     }
</code></pre>
<p>Note the use of <code>self.props.failure_status</code> to access the header command
property.  In tests which do not specify the failure status header command,
<code>self.props.failure_status</code> will evaluate to the default value of 101 at the
time of this writing.  But for a test which specifies a header command of, for
example, <code>// failure-status: 1</code>, <code>self.props.failure_status</code> will evaluate to
1, as <code>parse_failure_status()</code> will have overridden the <code>TestProps</code> default
value, for that test specifically.</p>
<hr />
<p>layout: default
title: Debugging the Compiler</p>
<hr />
<p><strong>Note: This is copied from the
<a href="https://github.com/rust-lang-nursery/rust-forge">rust-forge</a>. If anything needs
updating, please open an issue or make a PR on the github repo.</strong></p>
<a class="header" href="print.html#debugging-the-compiler" id="debugging-the-compiler"><h1>Debugging the compiler</h1></a>
<p>Here are a few tips to debug the compiler:</p>
<a class="header" href="print.html#getting-a-backtrace" id="getting-a-backtrace"><h2>Getting a backtrace</h2></a>
<p>When you have an ICE (panic in the compiler), you can set
<code>RUST_BACKTRACE=1</code> to get the stack trace of the <code>panic!</code> like in
normal Rust programs.  IIRC backtraces <strong>don't work</strong> on Mac and on MinGW,
sorry. If you have trouble or the backtraces are full of <code>unknown</code>,
you might want to find some way to use Linux or MSVC on Windows.</p>
<p>In the default configuration, you don't have line numbers enabled, so the
backtrace looks like this:</p>
<pre><code class="language-text">stack backtrace:
   0: std::sys::imp::backtrace::tracing::imp::unwind_backtrace
   1: std::sys_common::backtrace::_print
   2: std::panicking::default_hook::{{closure}}
   3: std::panicking::default_hook
   4: std::panicking::rust_panic_with_hook
   5: std::panicking::begin_panic
   (~~~~ LINES REMOVED BY ME FOR BREVITY ~~~~)
  32: rustc_typeck::check_crate
  33: &lt;std::thread::local::LocalKey&lt;T&gt;&gt;::with
  34: &lt;std::thread::local::LocalKey&lt;T&gt;&gt;::with
  35: rustc::ty::context::TyCtxt::create_and_enter
  36: rustc_driver::driver::compile_input
  37: rustc_driver::run_compiler
</code></pre>
<p>If you want line numbers for the stack trace, you can enable
<code>debuginfo-lines=true</code> or <code>debuginfo=true</code> in your config.toml and rebuild the
compiler. Then the backtrace will look like this:</p>
<pre><code class="language-text">stack backtrace:
   (~~~~ LINES REMOVED BY ME FOR BREVITY ~~~~)
             at /home/user/rust/src/librustc_typeck/check/cast.rs:110
   7: rustc_typeck::check::cast::CastCheck::check
             at /home/user/rust/src/librustc_typeck/check/cast.rs:572
             at /home/user/rust/src/librustc_typeck/check/cast.rs:460
             at /home/user/rust/src/librustc_typeck/check/cast.rs:370
   (~~~~ LINES REMOVED BY ME FOR BREVITY ~~~~)
  33: rustc_driver::driver::compile_input
             at /home/user/rust/src/librustc_driver/driver.rs:1010
             at /home/user/rust/src/librustc_driver/driver.rs:212
  34: rustc_driver::run_compiler
             at /home/user/rust/src/librustc_driver/lib.rs:253
</code></pre>
<a class="header" href="print.html#getting-a-backtrace-for-errors" id="getting-a-backtrace-for-errors"><h2>Getting a backtrace for errors</h2></a>
<p>If you want to get a backtrace to the point where the compiler emits
an error message, you can pass the <code>-Z treat-err-as-bug</code>, which
will make the compiler panic on the first error it sees.</p>
<p>This can also help when debugging <code>delay_span_bug</code> calls - it will make
the first <code>delay_span_bug</code> call panic, which will give you a useful backtrace.</p>
<p>For example:</p>
<pre><code class="language-bash">$ cat error.rs
fn main() {
    1 + ();
}
</code></pre>
<pre><code class="language-bash">$ ./build/x86_64-unknown-linux-gnu/stage1/bin/rustc error.rs
error[E0277]: the trait bound `{integer}: std::ops::Add&lt;()&gt;` is not satisfied
 --&gt; error.rs:2:7
  |
2 |     1 + ();
  |       ^ no implementation for `{integer} + ()`
  |
  = help: the trait `std::ops::Add&lt;()&gt;` is not implemented for `{integer}`

error: aborting due to previous error

$ # Now, where does the error above come from?
$ RUST_BACKTRACE=1 \
    ./build/x86_64-unknown-linux-gnu/stage1/bin/rustc \
    error.rs \
    -Z treat-err-as-bug
error[E0277]: the trait bound `{integer}: std::ops::Add&lt;()&gt;` is not satisfied
 --&gt; error.rs:2:7
  |
2 |     1 + ();
  |       ^ no implementation for `{integer} + ()`
  |
  = help: the trait `std::ops::Add&lt;()&gt;` is not implemented for `{integer}`

error: internal compiler error: unexpected panic

note: the compiler unexpectedly panicked. this is a bug.

note: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports

note: rustc 1.24.0-dev running on x86_64-unknown-linux-gnu

note: run with `RUST_BACKTRACE=1` for a backtrace

thread 'rustc' panicked at 'encountered error with `-Z treat_err_as_bug', 
/home/user/rust/src/librustc_errors/lib.rs:411:12
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose 
backtrace.
stack backtrace:
  (~~~ IRRELEVANT PART OF BACKTRACE REMOVED BY ME ~~~)
   7: rustc::traits::error_reporting::&lt;impl rustc::infer::InferCtxt&lt;'a, 'gcx, 
             'tcx&gt;&gt;::report_selection_error
             at /home/user/rust/src/librustc/traits/error_reporting.rs:823
   8: rustc::traits::error_reporting::&lt;impl rustc::infer::InferCtxt&lt;'a, 'gcx, 
             'tcx&gt;&gt;::report_fulfillment_errors
             at /home/user/rust/src/librustc/traits/error_reporting.rs:160
             at /home/user/rust/src/librustc/traits/error_reporting.rs:112
   9: rustc_typeck::check::FnCtxt::select_obligations_where_possible
             at /home/user/rust/src/librustc_typeck/check/mod.rs:2192
  (~~~ IRRELEVANT PART OF BACKTRACE REMOVED BY ME ~~~)
  36: rustc_driver::run_compiler
             at /home/user/rust/src/librustc_driver/lib.rs:253
$ # Cool, now I have a backtrace for the error
</code></pre>
<a class="header" href="print.html#getting-logging-output" id="getting-logging-output"><h2>Getting logging output</h2></a>
<p>The compiler has a lot of <code>debug!</code> calls, which print out logging information
at many points. These are very useful to at least narrow down the location of
a bug if not to find it entirely, or just to orient yourself as to why the
compiler is doing a particular thing.</p>
<p>To see the logs, you need to set the <code>RUST_LOG</code> environment variable to
your log filter, e.g. to get the logs for a specific module, you can run the
compiler as <code>RUST_LOG=module::path rustc my-file.rs</code>. The Rust logs are
powered by <a href="https://docs.rs/env_logger/0.4.3/env_logger/">env-logger</a>, and you can look at the docs linked there to see
the full <code>RUST_LOG</code> syntax. All <code>debug!</code> output will then appear in
standard error.</p>
<p>Note that unless you use a very strict filter, the logger will emit a <em>lot</em>
of output - so it's typically a good idea to pipe standard error to a file
and look at the log output with a text editor.</p>
<p>So to put it together.</p>
<pre><code class="language-bash"># This puts the output of all debug calls in `librustc/traits` into
# standard error, which might fill your console backscroll.
$ RUST_LOG=rustc::traits rustc +local my-file.rs

# This puts the output of all debug calls in `librustc/traits` in
# `traits-log`, so you can then see it with a text editor.
$ RUST_LOG=rustc::traits rustc +local my-file.rs 2&gt;traits-log

# Not recommended. This will show the output of all `debug!` calls
# in the Rust compiler, and there are a *lot* of them, so it will be
# hard to find anything.
$ RUST_LOG=debug rustc +local my-file.rs 2&gt;all-log

# This will show the output of all `info!` calls in `rustc_trans`.
#
# There's an `info!` statement in `trans_instance` that outputs
# every function that is translated. This is useful to find out
# which function triggers an LLVM assertion, and this is an `info!`
# log rather than a `debug!` log so it will work on the official
# compilers.
$ RUST_LOG=rustc_trans=info rustc +local my-file.rs
</code></pre>
<p>While calls to <code>info!</code> are included in every build of the compiler,
calls to <code>debug!</code> are only included in the program if the
<code>debug-assertions=yes</code> is turned on in config.toml (it is
turned off by default), so if you don't see <code>DEBUG</code> logs, especially
if you run the compiler with <code>RUST_LOG=rustc rustc some.rs</code> and only see
<code>INFO</code> logs, make sure that <code>debug-assertions=yes</code> is turned on in your
config.toml.</p>
<p>I also think that in some cases just setting it will not trigger a rebuild,
so if you changed it and you already have a compiler built, you might
want to call <code>x.py clean</code> to force one.</p>
<a class="header" href="print.html#logging-etiquette" id="logging-etiquette"><h3>Logging etiquette</h3></a>
<p>Because calls to <code>debug!</code> are removed by default, in most cases, don't worry
about adding &quot;unnecessary&quot; calls to <code>debug!</code> and leaving them in code you
commit - they won't slow down the performance of what we ship, and if they
helped you pinning down a bug, they will probably help someone else with a
different one.</p>
<p>However, there are still a few concerns that you might care about:</p>
<a class="header" href="print.html#expensive-operations-in-logs" id="expensive-operations-in-logs"><h3>Expensive operations in logs</h3></a>
<p>A note of caution: the expressions <em>within</em> the <code>debug!</code> call are run
whenever RUST_LOG is set, even if the filter would exclude the log. This means
that if in the module <code>rustc::foo</code> you have a statement</p>
<pre><code class="language-Rust">debug!(&quot;{:?}&quot;, random_operation(tcx));
</code></pre>
<p>Then if someone runs a debug <code>rustc</code> with <code>RUST_LOG=rustc::bar</code>, then
<code>random_operation()</code> will still run - even while it's output will never be
needed!</p>
<p>This means that you should not put anything too expensive or likely
to crash there - that would annoy anyone who wants to use logging for their own
module. Note that if <code>RUST_LOG</code> is unset (the default), then the code will not
run - this means that if your logging code panics, then no-one will know it
until someone tries to use logging to find <em>another</em> bug.</p>
<p>If you <em>need</em> to do an expensive operation in a log, be aware that while log
expressions are <em>evaluated</em> even if logging is not enabled in your module,
they are not <em>formatted</em> unless it <em>is</em>. This means you can put your
expensive/crashy operations inside an <code>fmt::Debug</code> impl, and they will not be
run unless your log is enabled:</p>
<pre><code class="language-Rust">use std::fmt;

struct ExpensiveOperationContainer&lt;'a, 'gcx, 'tcx&gt;
    where 'tcx: 'gcx, 'a: 'tcx
{
    tcx: TyCtxt&lt;'a, 'gcx, 'tcx&gt;
}

impl&lt;'a, 'gcx, 'tcx&gt; fmt::Debug for ExpensiveOperationContainer&lt;'a, 'gcx, 'tcx&gt; {
    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        let value = random_operation(tcx);
        fmt::Debug::fmt(&amp;value, fmt)
    }
}

debug!(&quot;{:?}&quot;, ExpensiveOperationContainer { tcx });
</code></pre>
<a class="header" href="print.html#formatting-graphviz-output-dot-files" id="formatting-graphviz-output-dot-files"><h2>Formatting Graphviz output (.dot files)</h2></a>
<p>Some compiler options for debugging specific features yield graphviz graphs -
e.g. the <code>#[rustc_mir(borrowck_graphviz_postflow=&quot;suffix.dot&quot;)]</code> attribute
dumps various borrow-checker dataflow graphs.</p>
<p>These all produce <code>.dot</code> files. To view these files, install graphviz (e.g.
<code>apt-get install graphviz</code>) and then run the following commands:</p>
<pre><code class="language-bash">$ dot -T pdf maybe_init_suffix.dot &gt; maybe_init_suffix.pdf
$ firefox maybe_init_suffix.pdf # Or your favorite pdf viewer
</code></pre>
<a class="header" href="print.html#debugging-llvm" id="debugging-llvm"><h2>Debugging LLVM</h2></a>
<p>LLVM is a big project on its own that probably needs to have its own debugging
document (not that I could find one). But here are some tips that are important
in a rustc context:</p>
<p>The official compilers (including nightlies) have LLVM assertions disabled,
which means that LLVM assertion failures can show up as compiler crashes (not
ICEs but &quot;real&quot; crashes) and other sorts of weird behavior. If you are
encountering these, it is a good idea to try using a compiler with LLVM
assertions enabled - either an &quot;alt&quot; nightly or a compiler you build yourself
by setting <code>[llvm] assertions=true</code> in your config.toml - and
see whether anything turns up.</p>
<p>The rustc build process builds the LLVM tools into
<code>./build/&lt;host-triple&gt;/llvm/bin</code>. They can be called directly.</p>
<p>The default rustc compilation pipeline has multiple codegen units, which is hard
to replicate manually and means that LLVM is called multiple times in parallel.
If you can get away with it (i.e. if it doesn't make your bug disappear),
passing <code>-C codegen-units=1</code> to rustc will make debugging easier.</p>
<p>If you want to play with the optimization pipeline, you can use the opt tool
from <code>./build/&lt;host-triple&gt;/llvm/bin/</code> with the the LLVM IR emitted by rustc.
Note that rustc emits different IR depending on whether <code>-O</code> is enabled, even
without LLVM's optimizations, so if you want to play with the IR rustc emits,
you should:</p>
<pre><code class="language-bash">$ rustc +local my-file.rs --emit=llvm-ir -O -C no-prepopulate-passes \
    -C codegen-units=1
$ OPT=./build/$TRIPLE/llvm/bin/opt
$ $OPT -S -O2 &lt; my-file.ll &gt; my
</code></pre>
<p>If you just want to get the LLVM IR during the LLVM pipeline, to e.g. see which
IR causes an optimization-time assertion to fail, or to see when
LLVM performs a particular optimization, you can pass the rustc flag
<code>-C llvm-args=-print-after-all</code>, and possibly add
<code>-C llvm-args='-filter-print-funcs=EXACT_FUNCTION_NAME</code> (e.g.
<code>-C llvm-args='-filter-print-funcs=_ZN11collections3str21_$LT$impl$u20$str$GT$\ 7replace17hbe10ea2e7c809b0bE'</code>).</p>
<p>That produces a lot of output into standard error, so you'll want to pipe
that to some file. Also, if you are using neither <code>-filter-print-funcs</code> nor
<code>-C codegen-units=1</code>, then, because the multiple codegen units run in parallel,
the printouts will mix together and you won't be able to read anything.</p>
<p>If you want just the IR for a specific function (say, you want to see
why it causes an assertion or doesn't optimize correctly), you can use
<code>llvm-extract</code>, e.g.</p>
<pre><code class="language-bash">$ ./build/$TRIPLE/llvm/bin/llvm-extract \
    -func='_ZN11collections3str21_$LT$impl$u20$str$GT$7replace17hbe10ea2e7c809b0bE' \
    -S \
    &lt; unextracted.ll \
    &gt; extracted.ll
</code></pre>
<a class="header" href="print.html#walkthrough-a-typical-contribution" id="walkthrough-a-typical-contribution"><h1>Walkthrough: a typical contribution</h1></a>
<a class="header" href="print.html#high-level-overview-of-the-compiler-source" id="high-level-overview-of-the-compiler-source"><h1>High-level overview of the compiler source</h1></a>
<a class="header" href="print.html#crate-structure" id="crate-structure"><h2>Crate structure</h2></a>
<p>The main Rust repository consists of a <code>src</code> directory, under which
there live many crates. These crates contain the sources for the
standard library and the compiler.  This document, of course, focuses
on the latter.</p>
<p>Rustc consists of a number of crates, including <code>syntax</code>,
<code>rustc</code>, <code>rustc_back</code>, <code>rustc_trans</code>, <code>rustc_driver</code>, and
many more. The source for each crate can be found in a directory
like <code>src/libXXX</code>, where <code>XXX</code> is the crate name.</p>
<p>(N.B. The names and divisions of these crates are not set in
stone and may change over time. For the time being, we tend towards a
finer-grained division to help with compilation time, though as incremental
compilation improves, that may change.)</p>
<p>The dependency structure of these crates is roughly a diamond:</p>
<pre><code class="language-text">                  rustc_driver
                /      |       \
              /        |         \
            /          |           \
          /            v             \
rustc_trans    rustc_borrowck   ...  rustc_metadata
          \            |            /
            \          |          /
              \        |        /
                \      v      /
                    rustc
                       |
                       v
                    syntax
                    /    \
                  /       \
           syntax_pos  syntax_ext
</code></pre>
<p>The <code>rustc_driver</code> crate, at the top of this lattice, is effectively
the &quot;main&quot; function for the rust compiler. It doesn't have much &quot;real
code&quot;, but instead ties together all of the code defined in the other
crates and defines the overall flow of execution. (As we transition
more and more to the <a href="query.html">query model</a>, however, the
&quot;flow&quot; of compilation is becoming less centrally defined.)</p>
<p>At the other extreme, the <code>rustc</code> crate defines the common and
pervasive data structures that all the rest of the compiler uses
(e.g. how to represent types, traits, and the program itself). It
also contains some amount of the compiler itself, although that is
relatively limited.</p>
<p>Finally, all the crates in the bulge in the middle define the bulk of
the compiler – they all depend on <code>rustc</code>, so that they can make use
of the various types defined there, and they export public routines
that <code>rustc_driver</code> will invoke as needed (more and more, what these
crates export are &quot;query definitions&quot;, but those are covered later
on).</p>
<p>Below <code>rustc</code> lie various crates that make up the parser and error
reporting mechanism. For historical reasons, these crates do not have
the <code>rustc_</code> prefix, but they are really just as much an internal part
of the compiler and not intended to be stable (though they do wind up
getting used by some crates in the wild; a practice we hope to
gradually phase out).</p>
<p>Each crate has a <code>README.md</code> file that describes, at a high-level,
what it contains, and tries to give some kind of explanation (some
better than others).</p>
<a class="header" href="print.html#the-main-stages-of-compilation" id="the-main-stages-of-compilation"><h2>The main stages of compilation</h2></a>
<p>The Rust compiler is in a bit of transition right now. It used to be a
purely &quot;pass-based&quot; compiler, where we ran a number of passes over the
entire program, and each did a particular check of transformation. We
are gradually replacing this pass-based code with an alternative setup
based on on-demand <strong>queries</strong>. In the query-model, we work backwards,
executing a <em>query</em> that expresses our ultimate goal (e.g. &quot;compile
this crate&quot;). This query in turn may make other queries (e.g. &quot;get me
a list of all modules in the crate&quot;). Those queries make other queries
that ultimately bottom out in the base operations, like parsing the
input, running the type-checker, and so forth. This on-demand model
permits us to do exciting things like only do the minimal amount of
work needed to type-check a single function. It also helps with
incremental compilation. (For details on defining queries, check out
<code>src/librustc/ty/maps/README.md</code>.)</p>
<p>Regardless of the general setup, the basic operations that the
compiler must perform are the same. The only thing that changes is
whether these operations are invoked front-to-back, or on demand.  In
order to compile a Rust crate, these are the general steps that we
take:</p>
<ol>
<li><strong>Parsing input</strong>
<ul>
<li>this processes the <code>.rs</code> files and produces the AST
(&quot;abstract syntax tree&quot;)</li>
<li>the AST is defined in <code>syntax/ast.rs</code>. It is intended to match the lexical
syntax of the Rust language quite closely.</li>
</ul>
</li>
<li><strong>Name resolution, macro expansion, and configuration</strong>
<ul>
<li>once parsing is complete, we process the AST recursively, resolving
paths and expanding macros. This same process also processes <code>#[cfg]</code>
nodes, and hence may strip things out of the AST as well.</li>
</ul>
</li>
<li><strong>Lowering to HIR</strong>
<ul>
<li>Once name resolution completes, we convert the AST into the HIR,
or &quot;<a href="hir.html">high-level intermediate representation</a>&quot;. The HIR is defined in
<code>src/librustc/hir/</code>; that module also includes the lowering code.</li>
<li>The HIR is a lightly desugared variant of the AST. It is more processed
than the AST and more suitable for the analyses that follow.
It is <strong>not</strong> required to match the syntax of the Rust language.</li>
<li>As a simple example, in the <strong>AST</strong>, we preserve the parentheses
that the user wrote, so <code>((1 + 2) + 3)</code> and <code>1 + 2 + 3</code> parse
into distinct trees, even though they are equivalent. In the
HIR, however, parentheses nodes are removed, and those two
expressions are represented in the same way.</li>
</ul>
</li>
<li><strong>Type-checking and subsequent analyses</strong>
<ul>
<li>An important step in processing the HIR is to perform type
checking. This process assigns types to every HIR expression,
for example, and also is responsible for resolving some
&quot;type-dependent&quot; paths, such as field accesses (<code>x.f</code> – we
can't know what field <code>f</code> is being accessed until we know the
type of <code>x</code>) and associated type references (<code>T::Item</code> – we
can't know what type <code>Item</code> is until we know what <code>T</code> is).</li>
<li>Type checking creates &quot;side-tables&quot; (<code>TypeckTables</code>) that include
the types of expressions, the way to resolve methods, and so forth.</li>
<li>After type-checking, we can do other analyses, such as privacy checking.</li>
</ul>
</li>
<li><strong>Lowering to MIR and post-processing</strong>
<ul>
<li>Once type-checking is done, we can lower the HIR into MIR (&quot;middle IR&quot;),
which is a <strong>very</strong> desugared version of Rust, well suited to borrowck
but also to certain high-level optimizations.</li>
</ul>
</li>
<li><strong>Translation to LLVM and LLVM optimizations</strong>
<ul>
<li>From MIR, we can produce LLVM IR.</li>
<li>LLVM then runs its various optimizations, which produces a number of
<code>.o</code> files (one for each &quot;codegen unit&quot;).</li>
</ul>
</li>
<li><strong>Linking</strong>
<ul>
<li>Finally, those <code>.o</code> files are linked together.</li>
</ul>
</li>
</ol>
<a class="header" href="print.html#the-rustc-driver" id="the-rustc-driver"><h1>The Rustc Driver</h1></a>
<p>The <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_driver/"><code>rustc_driver</code></a> is essentially <code>rustc</code>'s <code>main()</code> function. It acts as
the glue for running the various phases of the compiler in the correct order,
managing state such as the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/codemap/struct.CodeMap.html"><code>CodeMap</code></a> (maps AST nodes to source code),
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/session/struct.Session.html"><code>Session</code></a> (general build context and error messaging) and the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/ty/struct.TyCtxt.html"><code>TyCtxt</code></a>
(the &quot;typing context&quot;, allowing you to query the type system and other cool
stuff). The <code>rustc_driver</code> crate also provides external users with a method
for running code at particular times during the compilation process, allowing
third parties to effectively use <code>rustc</code>'s internals as a library for
analysing a crate or emulating the compiler in-process (e.g. the RLS).</p>
<p>For those using <code>rustc</code> as a library, the <code>run_compiler()</code> function is the main
entrypoint to the compiler. Its main parameters are a list of command-line
arguments and a reference to something which implements the <code>CompilerCalls</code>
trait. A <code>CompilerCalls</code> creates the overall <code>CompileController</code>, letting it
govern which compiler passes are run and attach callbacks to be fired at the end
of each phase.</p>
<p>From <code>rustc_driver</code>'s perspective, the main phases of the compiler are:</p>
<ol>
<li><em>Parse Input:</em> Initial crate parsing</li>
<li><em>Configure and Expand:</em> Resolve <code>#[cfg]</code> attributes, name resolution, and
expand macros</li>
<li><em>Run Analysis Passes:</em> Run trait resolution, typechecking, region checking
and other miscellaneous analysis passes on the crate</li>
<li><em>Translate to LLVM:</em> Translate to the in-memory form of LLVM IR and turn it
into an executable/object files</li>
</ol>
<p>The <code>CompileController</code> then gives users the ability to inspect the ongoing
compilation process</p>
<ul>
<li>after parsing</li>
<li>after AST expansion</li>
<li>after HIR lowering</li>
<li>after analysis, and</li>
<li>when compilation is done</li>
</ul>
<p>The <code>CompileState</code>'s various <code>state_after_*()</code> constructors can be inspected to
determine what bits of information are available to which callback.</p>
<p>For a more detailed explanation on using <code>rustc_driver</code>, check out the
<a href="https://github.com/nrc/stupid-stats">stupid-stats</a> guide by <code>@nrc</code> (attached as <a href="appendix/stupid-stats.html">Appendix A</a>).</p>
<blockquote>
<p><strong>Warning:</strong> By its very nature, the internal compiler APIs are always going
to be unstable. That said, we do try not to break things unnecessarily.</p>
</blockquote>
<a class="header" href="print.html#a-note-on-lifetimes" id="a-note-on-lifetimes"><h2>A Note On Lifetimes</h2></a>
<p>The Rust compiler is a fairly large program containing lots of big data
structures (e.g. the AST, HIR, and the type system) and as such, arenas and
references are heavily relied upon to minimize unnecessary memory use. This
manifests itself in the way people can plug into the compiler, preferring a
&quot;push&quot;-style API (callbacks) instead of the more Rust-ic &quot;pull&quot; style (think
the <code>Iterator</code> trait).</p>
<p>For example the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_driver/driver/struct.CompileState.html"><code>CompileState</code></a>, the state passed to callbacks after each
phase, is essentially just a box of optional references to pieces inside the
compiler. The lifetime bound on the <code>CompilerCalls</code> trait then helps to ensure
compiler internals don't &quot;escape&quot; the compiler (e.g. if you tried to keep a
reference to the AST after the compiler is finished), while still letting users
record <em>some</em> state for use after the <code>run_compiler()</code> function finishes.</p>
<p>Thread-local storage and interning are used a lot through the compiler to reduce
duplication while also preventing a lot of the ergonomic issues due to many
pervasive lifetimes. The <code>rustc::ty::tls</code> module is used to access these
thread-locals, although you should rarely need to touch it.</p>
<a class="header" href="print.html#the-walking-tour-of-rustdoc" id="the-walking-tour-of-rustdoc"><h1>The walking tour of rustdoc</h1></a>
<p>Rustdoc actually uses the rustc internals directly. It lives in-tree with the
compiler and standard library. This chapter is about how it works. (A new
implementation is also <a href="https://github.com/steveklabnik/rustdoc">under way</a>, though).</p>
<p>Rustdoc is implemented entirely within the crate <a href="https://github.com/rust-lang/rust/tree/master/src/librustdoc"><code>librustdoc</code></a>. It runs
the compiler up to the point where we have an internal representation of a
crate (HIR) and the ability to run some queries about the types of items. <a href="./hir.html">HIR</a>
and <a href="./query.html">queries</a> are discussed in the linked chapters.</p>
<p><code>librustdoc</code> performs two major steps after that to render a set of
documentation:</p>
<ul>
<li>&quot;Clean&quot; the AST into a form that's more suited to creating documentation (and
slightly more resistant to churn in the compiler).</li>
<li>Use this cleaned AST to render a crate's documentation, one page at a time.</li>
</ul>
<p>Naturally, there's more than just this, and those descriptions simplify out
lots of details, but that's the high-level overview.</p>
<p>(Side note: <code>librustdoc</code> is a library crate! The <code>rustdoc</code> binary is created
using the project in <a href="https://github.com/rust-lang/rust/tree/master/src/tools/rustdoc"><code>src/tools/rustdoc</code></a>. Note that literally all that
does is call the <code>main()</code> that's in this crate's <code>lib.rs</code>, though.)</p>
<a class="header" href="print.html#cheat-sheet" id="cheat-sheet"><h2>Cheat sheet</h2></a>
<ul>
<li>Use <code>x.py build --stage 1 src/libstd src/tools/rustdoc</code> to make a useable
rustdoc you can run on other projects.
<ul>
<li>Add <code>src/libtest</code> to be able to use <code>rustdoc --test</code>.</li>
<li>If you've used <code>rustup toolchain link local /path/to/build/$TARGET/stage1</code>
previously, then after the previous build command, <code>cargo +local doc</code> will
Just Work.</li>
</ul>
</li>
<li>Use <code>x.py doc --stage 1 src/libstd</code> to use this rustdoc to generate the
standard library docs.
<ul>
<li>The completed docs will be available in <code>build/$TARGET/doc/std</code>, though the
bundle is meant to be used as though you would copy out the <code>doc</code> folder to
a web server, since that's where the CSS/JS and landing page are.</li>
</ul>
</li>
<li>Most of the HTML printing code is in <code>html/format.rs</code> and <code>html/render.rs</code>.
It's in a bunch of <code>fmt::Display</code> implementations and supplementary
functions.</li>
<li>The types that got <code>Display</code> impls above are defined in <code>clean/mod.rs</code>, right
next to the custom <code>Clean</code> trait used to process them out of the rustc HIR.</li>
<li>The bits specific to using rustdoc as a test harness are in <code>test.rs</code>.</li>
<li>The Markdown renderer is loaded up in <code>html/markdown.rs</code>, including functions
for extracting doctests from a given block of Markdown.</li>
<li>The tests on rustdoc <em>output</em> are located in <code>src/test/rustdoc</code>, where
they're handled by the test runner of rustbuild and the supplementary script
<code>src/etc/htmldocck.py</code>.</li>
<li>Tests on search index generation are located in <code>src/test/rustdoc-js</code>, as a
series of JavaScript files that encode queries on the standard library search
index and expected results.</li>
</ul>
<a class="header" href="print.html#from-crate-to-clean" id="from-crate-to-clean"><h2>From crate to clean</h2></a>
<p>In <code>core.rs</code> are two central items: the <code>DocContext</code> struct, and the <code>run_core</code>
function. The latter is where rustdoc calls out to rustc to compile a crate to
the point where rustdoc can take over. The former is a state container used
when crawling through a crate to gather its documentation.</p>
<p>The main process of crate crawling is done in <code>clean/mod.rs</code> through several
implementations of the <code>Clean</code> trait defined within. This is a conversion
trait, which defines one method:</p>
<pre><code class="language-rust ignore">pub trait Clean&lt;T&gt; {
    fn clean(&amp;self, cx: &amp;DocContext) -&gt; T;
}
</code></pre>
<p><code>clean/mod.rs</code> also defines the types for the &quot;cleaned&quot; AST used later on to
render documentation pages. Each usually accompanies an implementation of
<code>Clean</code> that takes some AST or HIR type from rustc and converts it into the
appropriate &quot;cleaned&quot; type. &quot;Big&quot; items like modules or associated items may
have some extra processing in its <code>Clean</code> implementation, but for the most part
these impls are straightforward conversions. The &quot;entry point&quot; to this module
is the <code>impl Clean&lt;Crate&gt; for visit_ast::RustdocVisitor</code>, which is called by
<code>run_core</code> above.</p>
<p>You see, I actually lied a little earlier: There's another AST transformation
that happens before the events in <code>clean/mod.rs</code>.  In <code>visit_ast.rs</code> is the
type <code>RustdocVisitor</code>, which <em>actually</em> crawls a <code>hir::Crate</code> to get the first
intermediate representation, defined in <code>doctree.rs</code>. This pass is mainly to
get a few intermediate wrappers around the HIR types and to process visibility
and inlining. This is where <code>#[doc(inline)]</code>, <code>#[doc(no_inline)]</code>, and
<code>#[doc(hidden)]</code> are processed, as well as the logic for whether a <code>pub use</code>
should get the full page or a &quot;Reexport&quot; line in the module page.</p>
<p>The other major thing that happens in <code>clean/mod.rs</code> is the collection of doc
comments and <code>#[doc=&quot;&quot;]</code> attributes into a separate field of the Attributes
struct, present on anything that gets hand-written documentation. This makes it
easier to collect this documentation later in the process.</p>
<p>The primary output of this process is a <code>clean::Crate</code> with a tree of Items
which describe the publicly-documentable items in the target crate.</p>
<a class="header" href="print.html#hot-potato" id="hot-potato"><h3>Hot potato</h3></a>
<p>Before moving on to the next major step, a few important &quot;passes&quot; occur over
the documentation.  These do things like combine the separate &quot;attributes&quot; into
a single string and strip leading whitespace to make the document easier on the
markdown parser, or drop items that are not public or deliberately hidden with
<code>#[doc(hidden)]</code>. These are all implemented in the <code>passes/</code> directory, one
file per pass. By default, all of these passes are run on a crate, but the ones
regarding dropping private/hidden items can be bypassed by passing
<code>--document-private-items</code> to rustdoc. Note that unlike the previous set of AST
transformations, the passes happen on the <em>cleaned</em> crate.</p>
<p>(Strictly speaking, you can fine-tune the passes run and even add your own, but
<a href="https://github.com/rust-lang/rust/issues/44136">we're trying to deprecate that</a>. If you need finer-grain control over
these passes, please let us know!)</p>
<p>Here is current (as of this writing) list of passes:</p>
<ul>
<li><code>propagate-doc-cfg</code> - propagates <code>#[doc(cfg(...))]</code> to child items.</li>
<li><code>collapse-docs</code> concatenates all document attributes into one document
attribute. This is necessary because each line of a doc comment is given as a
separate doc attribute, and this will combine them into a single string with
line breaks between each attribute.</li>
<li><code>unindent-comments</code> removes excess indentation on comments in order for
markdown to like it. This is necessary because the convention for writing
documentation is to provide a space between the <code>///</code> or <code>//!</code> marker and the
text, and stripping that leading space will make the text easier to parse by
the Markdown parser. (In the past, the markdown parser used was not
Commonmark- compliant, which caused annoyances with extra whitespace but this
seems to be less of an issue today.)</li>
<li><code>strip-priv-imports</code> strips all private import statements (<code>use</code>, <code>extern crate</code>) from a crate. This is necessary because rustdoc will handle <em>public</em>
imports by either inlining the item's documentation to the module or creating
a &quot;Reexports&quot; section with the import in it. The pass ensures that all of
these imports are actually relevant to documentation.</li>
<li><code>strip-hidden</code> and <code>strip-private</code> strip all <code>doc(hidden)</code> and private items
from the output. <code>strip-private</code> implies <code>strip-priv-imports</code>. Basically, the
goal is to remove items that are not relevant for public documentation.</li>
</ul>
<a class="header" href="print.html#from-clean-to-crate" id="from-clean-to-crate"><h2>From clean to crate</h2></a>
<p>This is where the &quot;second phase&quot; in rustdoc begins. This phase primarily lives
in the <code>html/</code> folder, and it all starts with <code>run()</code> in <code>html/render.rs</code>. This
code is responsible for setting up the <code>Context</code>, <code>SharedContext</code>, and <code>Cache</code>
which are used during rendering, copying out the static files which live in
every rendered set of documentation (things like the fonts, CSS, and JavaScript
that live in <code>html/static/</code>), creating the search index, and printing out the
source code rendering, before beginning the process of rendering all the
documentation for the crate.</p>
<p>Several functions implemented directly on <code>Context</code> take the <code>clean::Crate</code> and
set up some state between rendering items or recursing on a module's child
items. From here the &quot;page rendering&quot; begins, via an enormous <code>write!()</code> call
in <code>html/layout.rs</code>. The parts that actually generate HTML from the items and
documentation occurs within a series of <code>std::fmt::Display</code> implementations and
functions that pass around a <code>&amp;mut std::fmt::Formatter</code>. The top-level
implementation that writes out the page body is the <code>impl&lt;'a&gt; fmt::Display for Item&lt;'a&gt;</code> in <code>html/render.rs</code>, which switches out to one of several <code>item_*</code>
functions based on the kind of <code>Item</code> being rendered.</p>
<p>Depending on what kind of rendering code you're looking for, you'll probably
find it either in <code>html/render.rs</code> for major items like &quot;what sections should I
print for a struct page&quot; or <code>html/format.rs</code> for smaller component pieces like
&quot;how should I print a where clause as part of some other item&quot;.</p>
<p>Whenever rustdoc comes across an item that should print hand-written
documentation alongside, it calls out to <code>html/markdown.rs</code> which interfaces
with the Markdown parser. This is exposed as a series of types that wrap a
string of Markdown, and implement <code>fmt::Display</code> to emit HTML text. It takes
special care to enable certain features like footnotes and tables and add
syntax highlighting to Rust code blocks (via <code>html/highlight.rs</code>) before
running the Markdown parser. There's also a function in here
(<code>find_testable_code</code>) that specifically scans for Rust code blocks so the
test-runner code can find all the doctests in the crate.</p>
<a class="header" href="print.html#from-soup-to-nuts" id="from-soup-to-nuts"><h3>From soup to nuts</h3></a>
<p>(alternate title: <a href="https://www.youtube.com/watch?v=hOLAGYmUQV0">&quot;An unbroken thread that stretches from those first <code>Cell</code>s
to us&quot;</a>)</p>
<p>It's important to note that the AST cleaning can ask the compiler for
information (crucially, <code>DocContext</code> contains a <code>TyCtxt</code>), but page rendering
cannot. The <code>clean::Crate</code> created within <code>run_core</code> is passed outside the
compiler context before being handed to <code>html::render::run</code>. This means that a
lot of the &quot;supplementary data&quot; that isn't immediately available inside an
item's definition, like which trait is the <code>Deref</code> trait used by the language,
needs to be collected during cleaning, stored in the <code>DocContext</code>, and passed
along to the <code>SharedContext</code> during HTML rendering.  This manifests as a bunch
of shared state, context variables, and <code>RefCell</code>s.</p>
<p>Also of note is that some items that come from &quot;asking the compiler&quot; don't go
directly into the <code>DocContext</code> - for example, when loading items from a foreign
crate, rustdoc will ask about trait implementations and generate new <code>Item</code>s
for the impls based on that information. This goes directly into the returned
<code>Crate</code> rather than roundabout through the <code>DocContext</code>. This way, these
implementations can be collected alongside the others, right before rendering
the HTML.</p>
<a class="header" href="print.html#other-tricks-up-its-sleeve" id="other-tricks-up-its-sleeve"><h2>Other tricks up its sleeve</h2></a>
<p>All this describes the process for generating HTML documentation from a Rust
crate, but there are couple other major modes that rustdoc runs in. It can also
be run on a standalone Markdown file, or it can run doctests on Rust code or
standalone Markdown files. For the former, it shortcuts straight to
<code>html/markdown.rs</code>, optionally including a mode which inserts a Table of
Contents to the output HTML.</p>
<p>For the latter, rustdoc runs a similar partial-compilation to get relevant
documentation in <code>test.rs</code>, but instead of going through the full clean and
render process, it runs a much simpler crate walk to grab <em>just</em> the
hand-written documentation. Combined with the aforementioned
&quot;<code>find_testable_code</code>&quot; in <code>html/markdown.rs</code>, it builds up a collection of
tests to run before handing them off to the libtest test runner. One notable
location in <code>test.rs</code> is the function <code>make_test</code>, which is where hand-written
doctests get transformed into something that can be executed.</p>
<p>Some extra reading about <code>make_test</code> can be found
<a href="https://quietmisdreavus.net/code/2018/02/23/how-the-doctests-get-made/">here</a>.</p>
<a class="header" href="print.html#dotting-is-and-crossing-ts" id="dotting-is-and-crossing-ts"><h2>Dotting i's and crossing t's</h2></a>
<p>So that's rustdoc's code in a nutshell, but there's more things in the repo
that deal with it. Since we have the full <code>compiletest</code> suite at hand, there's
a set of tests in <code>src/test/rustdoc</code> that make sure the final HTML is what we
expect in various situations. These tests also use a supplementary script,
<code>src/etc/htmldocck.py</code>, that allows it to look through the final HTML using
XPath notation to get a precise look at the output. The full description of all
the commands available to rustdoc tests is in <code>htmldocck.py</code>.</p>
<p>In addition, there are separate tests for the search index and rustdoc's
ability to query it. The files in <code>src/test/rustdoc-js</code> each contain a
different search query and the expected results, broken out by search tab.
These files are processed by a script in <code>src/tools/rustdoc-js</code> and the Node.js
runtime. These tests don't have as thorough of a writeup, but a broad example
that features results in all tabs can be found in <code>basic.js</code>. The basic idea is
that you match a given <code>QUERY</code> with a set of <code>EXPECTED</code> results, complete with
the full item path of each item.</p>
<a class="header" href="print.html#queries-demand-driven-compilation" id="queries-demand-driven-compilation"><h1>Queries: demand-driven compilation</h1></a>
<p>As described in <a href="high-level-overview.html">the high-level overview of the compiler</a>, the
Rust compiler is current transitioning from a traditional &quot;pass-based&quot;
setup to a &quot;demand-driven&quot; system. <strong>The Compiler Query System is the
key to our new demand-driven organization.</strong> The idea is pretty
simple. You have various queries that compute things about the input
-- for example, there is a query called <code>type_of(def_id)</code> that, given
the def-id of some item, will compute the type of that item and return
it to you.</p>
<p>Query execution is <strong>memoized</strong> – so the first time you invoke a
query, it will go do the computation, but the next time, the result is
returned from a hashtable. Moreover, query execution fits nicely into
<strong>incremental computation</strong>; the idea is roughly that, when you do a
query, the result <strong>may</strong> be returned to you by loading stored data
from disk (but that's a separate topic we won't discuss further here).</p>
<p>The overall vision is that, eventually, the entire compiler
control-flow will be query driven. There will effectively be one
top-level query (&quot;compile&quot;) that will run compilation on a crate; this
will in turn demand information about that crate, starting from the
<em>end</em>.  For example:</p>
<ul>
<li>This &quot;compile&quot; query might demand to get a list of codegen-units
(i.e. modules that need to be compiled by LLVM).</li>
<li>But computing the list of codegen-units would invoke some subquery
that returns the list of all modules defined in the Rust source.</li>
<li>That query in turn would invoke something asking for the HIR.</li>
<li>This keeps going further and further back until we wind up doing the
actual parsing.</li>
</ul>
<p>However, that vision is not fully realized. Still, big chunks of the
compiler (for example, generating MIR) work exactly like this.</p>
<a class="header" href="print.html#invoking-queries" id="invoking-queries"><h3>Invoking queries</h3></a>
<p>To invoke a query is simple. The tcx (&quot;type context&quot;) offers a method
for each defined query. So, for example, to invoke the <code>type_of</code>
query, you would just do this:</p>
<pre><code class="language-rust ignore">let ty = tcx.type_of(some_def_id);
</code></pre>
<a class="header" href="print.html#cycles-between-queries" id="cycles-between-queries"><h3>Cycles between queries</h3></a>
<p>A cycle is when a query becomes stuck in a loop e.g. query A generates query B
which generates query A again.</p>
<p>Currently, cycles during query execution should always result in a
compilation error. Typically, they arise because of illegal programs
that contain cyclic references they shouldn't (though sometimes they
arise because of compiler bugs, in which case we need to factor our
queries in a more fine-grained fashion to avoid them).</p>
<p>However, it is nonetheless often useful to <em>recover</em> from a cycle
(after reporting an error, say) and try to soldier on, so as to give a
better user experience. In order to recover from a cycle, you don't
get to use the nice method-call-style syntax. Instead, you invoke
using the <code>try_get</code> method, which looks roughly like this:</p>
<pre><code class="language-rust ignore">use ty::maps::queries;
...
match queries::type_of::try_get(tcx, DUMMY_SP, self.did) {
  Ok(result) =&gt; {
    // no cycle occurred! You can use `result`
  }
  Err(err) =&gt; {
    // A cycle occurred! The error value `err` is a `DiagnosticBuilder`,
    // meaning essentially an &quot;in-progress&quot;, not-yet-reported error message.
    // See below for more details on what to do here.
  }
}
</code></pre>
<p>So, if you get back an <code>Err</code> from <code>try_get</code>, then a cycle <em>did</em> occur. This
means that you must ensure that a compiler error message is reported. You can
do that in two ways:</p>
<p>The simplest is to invoke <code>err.emit()</code>. This will emit the cycle error to the
user.</p>
<p>However, often cycles happen because of an illegal program, and you
know at that point that an error either already has been reported or
will be reported due to this cycle by some other bit of code. In that
case, you can invoke <code>err.cancel()</code> to not emit any error. It is
traditional to then invoke:</p>
<pre><code class="language-rust ignore">tcx.sess.delay_span_bug(some_span, &quot;some message&quot;)
</code></pre>
<p><code>delay_span_bug()</code> is a helper that says: we expect a compilation
error to have happened or to happen in the future; so, if compilation
ultimately succeeds, make an ICE with the message <code>&quot;some message&quot;</code>. This is basically just a precaution in case you are wrong.</p>
<a class="header" href="print.html#how-the-compiler-executes-a-query" id="how-the-compiler-executes-a-query"><h3>How the compiler executes a query</h3></a>
<p>So you may be wondering what happens when you invoke a query
method. The answer is that, for each query, the compiler maintains a
cache – if your query has already been executed, then, the answer is
simple: we clone the return value out of the cache and return it
(therefore, you should try to ensure that the return types of queries
are cheaply cloneable; insert a <code>Rc</code> if necessary).</p>
<a class="header" href="print.html#providers" id="providers"><h4>Providers</h4></a>
<p>If, however, the query is <em>not</em> in the cache, then the compiler will
try to find a suitable <strong>provider</strong>. A provider is a function that has
been defined and linked into the compiler somewhere that contains the
code to compute the result of the query.</p>
<p><strong>Providers are defined per-crate.</strong> The compiler maintains,
internally, a table of providers for every crate, at least
conceptually. Right now, there are really two sets: the providers for
queries about the <strong>local crate</strong> (that is, the one being compiled)
and providers for queries about <strong>external crates</strong> (that is,
dependencies of the local crate). Note that what determines the crate
that a query is targeting is not the <em>kind</em> of query, but the <em>key</em>.
For example, when you invoke <code>tcx.type_of(def_id)</code>, that could be a
local query or an external query, depending on what crate the <code>def_id</code>
is referring to (see the <code>self::keys::Key</code> trait for more information
on how that works).</p>
<p>Providers always have the same signature:</p>
<pre><code class="language-rust ignore">fn provider&lt;'cx, 'tcx&gt;(tcx: TyCtxt&lt;'cx, 'tcx, 'tcx&gt;,
                       key: QUERY_KEY)
                       -&gt; QUERY_RESULT
{
    ...
}
</code></pre>
<p>Providers take two arguments: the <code>tcx</code> and the query key. Note also
that they take the <em>global</em> tcx (i.e. they use the <code>'tcx</code> lifetime
twice), rather than taking a tcx with some active inference context.
They return the result of the query.</p>
<a class="header" href="print.html#how-providers-are-setup" id="how-providers-are-setup"><h4>How providers are setup</h4></a>
<p>When the tcx is created, it is given the providers by its creator using
the <code>Providers</code> struct. This struct is generated by the macros here, but it
is basically a big list of function pointers:</p>
<pre><code class="language-rust ignore">struct Providers {
    type_of: for&lt;'cx, 'tcx&gt; fn(TyCtxt&lt;'cx, 'tcx, 'tcx&gt;, DefId) -&gt; Ty&lt;'tcx&gt;,
    ...
}
</code></pre>
<p>At present, we have one copy of the struct for local crates, and one
for external crates, though the plan is that we may eventually have
one per crate.</p>
<p>These <code>Provider</code> structs are ultimately created and populated by
<code>librustc_driver</code>, but it does this by distributing the work
throughout the other <code>rustc_*</code> crates. This is done by invoking
various <code>provide</code> functions. These functions tend to look something
like this:</p>
<pre><code class="language-rust ignore">pub fn provide(providers: &amp;mut Providers) {
    *providers = Providers {
        type_of,
        ..*providers
    };
}
</code></pre>
<p>That is, they take an <code>&amp;mut Providers</code> and mutate it in place. Usually
we use the formulation above just because it looks nice, but you could
as well do <code>providers.type_of = type_of</code>, which would be equivalent.
(Here, <code>type_of</code> would be a top-level function, defined as we saw
before.) So, if we want to add a provider for some other query,
let's call it <code>fubar</code>, into the crate above, we might modify the <code>provide()</code>
function like so:</p>
<pre><code class="language-rust ignore">pub fn provide(providers: &amp;mut Providers) {
    *providers = Providers {
        type_of,
        fubar,
        ..*providers
    };
}

fn fubar&lt;'cx, 'tcx&gt;(tcx: TyCtxt&lt;'cx, 'tcx&gt;, key: DefId) -&gt; Fubar&lt;'tcx&gt; { ... }
</code></pre>
<p>N.B. Most of the <code>rustc_*</code> crates only provide <strong>local
providers</strong>. Almost all <strong>extern providers</strong> wind up going through the
<a href="https://github.com/rust-lang/rust/tree/master/src/librustc_metadata"><code>rustc_metadata</code> crate</a>, which loads the information from the
crate metadata. But in some cases there are crates that provide queries for
<em>both</em> local and external crates, in which case they define both a
<code>provide</code> and a <code>provide_extern</code> function that <code>rustc_driver</code> can
invoke.</p>
<a class="header" href="print.html#adding-a-new-kind-of-query" id="adding-a-new-kind-of-query"><h3>Adding a new kind of query</h3></a>
<p>So suppose you want to add a new kind of query, how do you do so?
Well, defining a query takes place in two steps:</p>
<ol>
<li>first, you have to specify the query name and arguments; and then,</li>
<li>you have to supply query providers where needed.</li>
</ol>
<p>To specify the query name and arguments, you simply add an entry to
the big macro invocation in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/ty/maps/index.html"><code>src/librustc/ty/maps/mod.rs</code></a>. This will probably have
changed by the time you read this README, but at present it looks
something like:</p>
<pre><code class="language-rust ignore">define_maps! { &lt;'tcx&gt;
    /// Records the type of every item.
    [] fn type_of: TypeOfItem(DefId) -&gt; Ty&lt;'tcx&gt;,

    ...
}
</code></pre>
<p>Each line of the macro defines one query. The name is broken up like this:</p>
<pre><code class="language-rust ignore">[] fn type_of: TypeOfItem(DefId) -&gt; Ty&lt;'tcx&gt;,
^^    ^^^^^^^  ^^^^^^^^^^ ^^^^^     ^^^^^^^^
|     |        |          |         |
|     |        |          |         result type of query
|     |        |          query key type
|     |        dep-node constructor
|     name of query
query flags
</code></pre>
<p>Let's go over them one by one:</p>
<ul>
<li><strong>Query flags:</strong> these are largely unused right now, but the intention
is that we'll be able to customize various aspects of how the query is
processed.</li>
<li><strong>Name of query:</strong> the name of the query method
(<code>tcx.type_of(..)</code>). Also used as the name of a struct
(<code>ty::maps::queries::type_of</code>) that will be generated to represent
this query.</li>
<li><strong>Dep-node constructor:</strong> indicates the constructor function that
connects this query to incremental compilation. Typically, this is a
<code>DepNode</code> variant, which can be added by modifying the
<code>define_dep_nodes!</code> macro invocation in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/dep_graph/struct.DepNode.html"><code>librustc/dep_graph/dep_node.rs</code></a>.
<ul>
<li>However, sometimes we use a custom function, in which case the
name will be in snake case and the function will be defined at the
bottom of the file. This is typically used when the query key is
not a def-id, or just not the type that the dep-node expects.</li>
</ul>
</li>
<li><strong>Query key type:</strong> the type of the argument to this query.
This type must implement the <code>ty::maps::keys::Key</code> trait, which
defines (for example) how to map it to a crate, and so forth.</li>
<li><strong>Result type of query:</strong> the type produced by this query. This type
should (a) not use <code>RefCell</code> or other interior mutability and (b) be
cheaply cloneable. Interning or using <code>Rc</code> or <code>Arc</code> is recommended for
non-trivial data types.
<ul>
<li>The one exception to those rules is the <code>ty::steal::Steal</code> type,
which is used to cheaply modify MIR in place. See the definition
of <code>Steal</code> for more details. New uses of <code>Steal</code> should <strong>not</strong> be
added without alerting <code>@rust-lang/compiler</code>.</li>
</ul>
</li>
</ul>
<p>So, to add a query:</p>
<ul>
<li>Add an entry to <code>define_maps!</code> using the format above.</li>
<li>Possibly add a corresponding entry to the dep-node macro.</li>
<li>Link the provider by modifying the appropriate <code>provide</code> method;
or add a new one if needed and ensure that <code>rustc_driver</code> is invoking it.</li>
</ul>
<a class="header" href="print.html#query-structs-and-descriptions" id="query-structs-and-descriptions"><h4>Query structs and descriptions</h4></a>
<p>For each kind, the <code>define_maps</code> macro will generate a &quot;query struct&quot;
named after the query. This struct is a kind of a place-holder
describing the query. Each such struct implements the
<code>self::config::QueryConfig</code> trait, which has associated types for the
key/value of that particular query. Basically the code generated looks something
like this:</p>
<pre><code class="language-rust ignore">// Dummy struct representing a particular kind of query:
pub struct type_of&lt;'tcx&gt; { phantom: PhantomData&lt;&amp;'tcx ()&gt; }

impl&lt;'tcx&gt; QueryConfig for type_of&lt;'tcx&gt; {
  type Key = DefId;
  type Value = Ty&lt;'tcx&gt;;
}
</code></pre>
<p>There is an additional trait that you may wish to implement called
<code>self::config::QueryDescription</code>. This trait is used during cycle
errors to give a &quot;human readable&quot; name for the query, so that we can
summarize what was happening when the cycle occurred. Implementing
this trait is optional if the query key is <code>DefId</code>, but if you <em>don't</em>
implement it, you get a pretty generic error (&quot;processing <code>foo</code>...&quot;).
You can put new impls into the <code>config</code> module. They look something like this:</p>
<pre><code class="language-rust ignore">impl&lt;'tcx&gt; QueryDescription for queries::type_of&lt;'tcx&gt; {
    fn describe(tcx: TyCtxt, key: DefId) -&gt; String {
        format!(&quot;computing the type of `{}`&quot;, tcx.item_path_str(key))
    }
}
</code></pre>
<a class="header" href="print.html#incremental-compilation" id="incremental-compilation"><h1>Incremental compilation</h1></a>
<p>The incremental compilation scheme is, in essence, a surprisingly
simple extension to the overall query system. We'll start by describing
a slightly simplified variant of the real thing – the &quot;basic algorithm&quot; –
and then describe some possible improvements.</p>
<a class="header" href="print.html#the-basic-algorithm" id="the-basic-algorithm"><h2>The basic algorithm</h2></a>
<p>The basic algorithm is
called the <strong>red-green</strong> algorithm<sup class="footnote-reference"><a href="print.html#salsa">1</a></sup>. The high-level idea is
that, after each run of the compiler, we will save the results of all
the queries that we do, as well as the <strong>query DAG</strong>. The
<strong>query DAG</strong> is a <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">DAG</a> that indexes which queries executed which
other queries. So, for example, there would be an edge from a query Q1
to another query Q2 if computing Q1 required computing Q2 (note that
because queries cannot depend on themselves, this results in a DAG and
not a general graph).</p>
<p>On the next run of the compiler, then, we can sometimes reuse these
query results to avoid re-executing a query. We do this by assigning
every query a <strong>color</strong>:</p>
<ul>
<li>If a query is colored <strong>red</strong>, that means that its result during
this compilation has <strong>changed</strong> from the previous compilation.</li>
<li>If a query is colored <strong>green</strong>, that means that its result is
the <strong>same</strong> as the previous compilation.</li>
</ul>
<p>There are two key insights here:</p>
<ul>
<li>First, if all the inputs to query Q are colored green, then the
query Q <strong>must</strong> result in the same value as last time and hence
need not be re-executed (or else the compiler is not deterministic).</li>
<li>Second, even if some inputs to a query changes, it may be that it
<strong>still</strong> produces the same result as the previous compilation. In
particular, the query may only use part of its input.
<ul>
<li>Therefore, after executing a query, we always check whether it
produced the same result as the previous time. <strong>If it did,</strong> we
can still mark the query as green, and hence avoid re-executing
dependent queries.</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#the-try-mark-green-algorithm" id="the-try-mark-green-algorithm"><h3>The try-mark-green algorithm</h3></a>
<p>At the core of incremental compilation is an algorithm called
&quot;try-mark-green&quot;. It has the job of determining the color of a given
query Q (which must not have yet been executed). In cases where Q has
red inputs, determining Q's color may involve re-executing Q so that
we can compare its output, but if all of Q's inputs are green, then we
can conclude that Q must be green without re-executing it or inspecting
its value at all. In the compiler, this allows us to avoid
deserializing the result from disk when we don't need it, and in fact
enables us to sometimes skip <em>serializing</em> the result as well
(see the refinements section below).</p>
<p>Try-mark-green works as follows:</p>
<ul>
<li>First check if the query Q was executed during the previous compilation.
<ul>
<li>If not, we can just re-execute the query as normal, and assign it the
color of red.</li>
</ul>
</li>
<li>If yes, then load the 'dependent queries' of Q.</li>
<li>If there is a saved result, then we load the <code>reads(Q)</code> vector from the
query DAG. The &quot;reads&quot; is the set of queries that Q executed during
its execution.
<ul>
<li>For each query R in <code>reads(Q)</code>, we recursively demand the color
of R using try-mark-green.
<ul>
<li>Note: it is important that we visit each node in <code>reads(Q)</code> in same order
as they occurred in the original compilation. See <a href="print.html#dag">the section on the
query DAG below</a>.</li>
<li>If <strong>any</strong> of the nodes in <code>reads(Q)</code> wind up colored <strong>red</strong>, then Q is
dirty.
<ul>
<li>We re-execute Q and compare the hash of its result to the hash of the
result from the previous compilation.</li>
<li>If the hash has not changed, we can mark Q as <strong>green</strong> and return.</li>
</ul>
</li>
<li>Otherwise, <strong>all</strong> of the nodes in <code>reads(Q)</code> must be <strong>green</strong>. In that
case, we can color Q as <strong>green</strong> and return.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a name="dag"></a></p>
<a class="header" href="print.html#the-query-dag" id="the-query-dag"><h3>The query DAG</h3></a>
<p>The query DAG code is stored in
<a href="https://github.com/rust-lang/rust/tree/master/src/librustc/dep_graph"><code>src/librustc/dep_graph</code></a>. Construction of the DAG is done
by instrumenting the query execution.</p>
<p>One key point is that the query DAG also tracks ordering; that is, for
each query Q, we not only track the queries that Q reads, we track the
<strong>order</strong> in which they were read.  This allows try-mark-green to walk
those queries back in the same order. This is important because once a
subquery comes back as red, we can no longer be sure that Q will continue
along the same path as before. That is, imagine a query like this:</p>
<pre><code class="language-rust ignore">fn main_query(tcx) {
    if tcx.subquery1() {
        tcx.subquery2()
    } else {
        tcx.subquery3()
    }
}
</code></pre>
<p>Now imagine that in the first compilation, <code>main_query</code> starts by
executing <code>subquery1</code>, and this returns true. In that case, the next
query <code>main_query</code> executes will be <code>subquery2</code>, and <code>subquery3</code> will
not be executed at all.</p>
<p>But now imagine that in the <strong>next</strong> compilation, the input has
changed such that <code>subquery1</code> returns <strong>false</strong>. In this case, <code>subquery2</code>
would never execute. If try-mark-green were to visit <code>reads(main_query)</code> out
of order, however, it might visit <code>subquery2</code> before <code>subquery1</code>, and hence
execute it.
This can lead to ICEs and other problems in the compiler.</p>
<a class="header" href="print.html#improvements-to-the-basic-algorithm" id="improvements-to-the-basic-algorithm"><h2>Improvements to the basic algorithm</h2></a>
<p>In the description of the basic algorithm, we said that at the end of
compilation we would save the results of all the queries that were
performed.  In practice, this can be quite wasteful – many of those
results are very cheap to recompute, and serializing and deserializing
them is not a particular win. In practice, what we would do is to save
<strong>the hashes</strong> of all the subqueries that we performed. Then, in select cases,
we <strong>also</strong> save the results.</p>
<p>This is why the incremental algorithm separates computing the
<strong>color</strong> of a node, which often does not require its value, from
computing the <strong>result</strong> of a node. Computing the result is done via a simple
algorithm like so:</p>
<ul>
<li>Check if a saved result for Q is available. If so, compute the color of Q.
If Q is green, deserialize and return the saved result.</li>
<li>Otherwise, execute Q.
<ul>
<li>We can then compare the hash of the result and color Q as green if
it did not change.</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#footnotes" id="footnotes"><h1>Footnotes</h1></a>
<div class="footnote-definition" id="salsa"><sup class="footnote-definition-label">1</sup>
<p>I have long wanted to rename it to the Salsa algorithm, but it never caught on. -@nikomatsakis</p>
</div>
<a class="header" href="print.html#debugging-and-testing-dependencies" id="debugging-and-testing-dependencies"><h1>Debugging and Testing Dependencies</h1></a>
<a class="header" href="print.html#testing-the-dependency-graph" id="testing-the-dependency-graph"><h2>Testing the dependency graph</h2></a>
<p>There are various ways to write tests against the dependency graph.
The simplest mechanisms are the <code>#[rustc_if_this_changed]</code> and
<code>#[rustc_then_this_would_need]</code> annotations. These are used in compile-fail
tests to test whether the expected set of paths exist in the dependency graph.
As an example, see <code>src/test/compile-fail/dep-graph-caller-callee.rs</code>.</p>
<p>The idea is that you can annotate a test like:</p>
<pre><code class="language-rust ignore">#[rustc_if_this_changed]
fn foo() { }

#[rustc_then_this_would_need(TypeckTables)] //~ ERROR OK
fn bar() { foo(); }

#[rustc_then_this_would_need(TypeckTables)] //~ ERROR no path
fn baz() { }
</code></pre>
<p>This will check whether there is a path in the dependency graph from <code>Hir(foo)</code>
to <code>TypeckTables(bar)</code>. An error is reported for each
<code>#[rustc_then_this_would_need]</code> annotation that indicates whether a path
exists. <code>//~ ERROR</code> annotations can then be used to test if a path is found (as
demonstrated above).</p>
<a class="header" href="print.html#debugging-the-dependency-graph" id="debugging-the-dependency-graph"><h2>Debugging the dependency graph</h2></a>
<a class="header" href="print.html#dumping-the-graph" id="dumping-the-graph"><h3>Dumping the graph</h3></a>
<p>The compiler is also capable of dumping the dependency graph for your
debugging pleasure. To do so, pass the <code>-Z dump-dep-graph</code> flag. The
graph will be dumped to <code>dep_graph.{txt,dot}</code> in the current
directory.  You can override the filename with the <code>RUST_DEP_GRAPH</code>
environment variable.</p>
<p>Frequently, though, the full dep graph is quite overwhelming and not
particularly helpful. Therefore, the compiler also allows you to filter
the graph. You can filter in three ways:</p>
<ol>
<li>All edges originating in a particular set of nodes (usually a single node).</li>
<li>All edges reaching a particular set of nodes.</li>
<li>All edges that lie between given start and end nodes.</li>
</ol>
<p>To filter, use the <code>RUST_DEP_GRAPH_FILTER</code> environment variable, which should
look like one of the following:</p>
<pre><code class="language-text">source_filter     // nodes originating from source_filter
-&gt; target_filter  // nodes that can reach target_filter
source_filter -&gt; target_filter // nodes in between source_filter and target_filter
</code></pre>
<p><code>source_filter</code> and <code>target_filter</code> are a <code>&amp;</code>-separated list of strings.
A node is considered to match a filter if all of those strings appear in its
label. So, for example:</p>
<pre><code class="language-text">RUST_DEP_GRAPH_FILTER='-&gt; TypeckTables'
</code></pre>
<p>would select the predecessors of all <code>TypeckTables</code> nodes. Usually though you
want the <code>TypeckTables</code> node for some particular fn, so you might write:</p>
<pre><code class="language-text">RUST_DEP_GRAPH_FILTER='-&gt; TypeckTables &amp; bar'
</code></pre>
<p>This will select only the predecessors of <code>TypeckTables</code> nodes for functions
with <code>bar</code> in their name.</p>
<p>Perhaps you are finding that when you change <code>foo</code> you need to re-type-check
<code>bar</code>, but you don't think you should have to. In that case, you might do:</p>
<pre><code class="language-text">RUST_DEP_GRAPH_FILTER='Hir &amp; foo -&gt; TypeckTables &amp; bar'
</code></pre>
<p>This will dump out all the nodes that lead from <code>Hir(foo)</code> to
<code>TypeckTables(bar)</code>, from which you can (hopefully) see the source
of the erroneous edge.</p>
<a class="header" href="print.html#tracking-down-incorrect-edges" id="tracking-down-incorrect-edges"><h3>Tracking down incorrect edges</h3></a>
<p>Sometimes, after you dump the dependency graph, you will find some
path that should not exist, but you will not be quite sure how it came
to be. <strong>When the compiler is built with debug assertions,</strong> it can
help you track that down. Simply set the <code>RUST_FORBID_DEP_GRAPH_EDGE</code>
environment variable to a filter. Every edge created in the dep-graph
will be tested against that filter -- if it matches, a <code>bug!</code> is
reported, so you can easily see the backtrace (<code>RUST_BACKTRACE=1</code>).</p>
<p>The syntax for these filters is the same as described in the previous
section. However, note that this filter is applied to every <strong>edge</strong>
and doesn't handle longer paths in the graph, unlike the previous
section.</p>
<p>Example:</p>
<p>You find that there is a path from the <code>Hir</code> of <code>foo</code> to the type
check of <code>bar</code> and you don't think there should be. You dump the
dep-graph as described in the previous section and open <code>dep-graph.txt</code>
to see something like:</p>
<pre><code class="language-text">Hir(foo) -&gt; Collect(bar)
Collect(bar) -&gt; TypeckTables(bar)
</code></pre>
<p>That first edge looks suspicious to you. So you set
<code>RUST_FORBID_DEP_GRAPH_EDGE</code> to <code>Hir&amp;foo -&gt; Collect&amp;bar</code>, re-run, and
then observe the backtrace. Voila, bug fixed!</p>
<a class="header" href="print.html#the-parser" id="the-parser"><h1>The Parser</h1></a>
<p>The parser is responsible for converting raw Rust source code into a structured
form which is easier for the compiler to work with, usually called an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree"><em>Abstract
Syntax Tree</em></a>. An AST mirrors the structure of a Rust program in memory,
using a <code>Span</code> to link a particular AST node back to its source text.</p>
<p>The bulk of the parser lives in the <a href="https://github.com/rust-lang/rust/tree/master/src/libsyntax">libsyntax</a> crate.</p>
<p>Like most parsers, the parsing process is composed of two main steps,</p>
<ul>
<li>lexical analysis – turn a stream of characters into a stream of token trees</li>
<li>parsing – turn the token trees into an AST</li>
</ul>
<p>The <code>syntax</code> crate contains several main players,</p>
<ul>
<li>a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/codemap/struct.CodeMap.html"><code>CodeMap</code></a> for mapping AST nodes to their source code</li>
<li>the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ast/index.html">ast module</a> contains types corresponding to each AST node</li>
<li>a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/parse/lexer/struct.StringReader.html"><code>StringReader</code></a> for lexing source code into tokens</li>
<li>the <a href="https://github.com/rust-lang/rust/tree/master/src/libsyntax/parse">parser module</a> and <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/parse/parser/struct.Parser.html"><code>Parser</code></a> struct are in charge of actually parsing
tokens into AST nodes,</li>
<li>and a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/visit/index.html">visit module</a> for walking the AST and inspecting or mutating the AST
nodes.</li>
</ul>
<p>The main entrypoint to the parser is via the various <code>parse_*</code> functions
in the <a href="https://github.com/rust-lang/rust/tree/master/src/libsyntax/parse">parser module</a>. They let you do things like turn a filemap into a
token stream, create a parser from the token stream, and then execute the
parser to get a <code>Crate</code> (the root AST node).</p>
<p>To minimise the amount of copying that is done, both the <code>StringReader</code> and
<code>Parser</code> have lifetimes which bind them to the parent <code>ParseSess</code>. This contains
all the information needed while parsing, as well as the <code>CodeMap</code> itself.</p>
<a class="header" href="print.html#macro-expansion" id="macro-expansion"><h1>Macro expansion</h1></a>
<p>Macro expansion happens during parsing. <code>rustc</code> has two parsers, in fact: the
normal Rust parser, and the macro parser. During the parsing phase, the normal
Rust parser will set aside the contents of macros and their invocations. Later,
before name resolution, macros are expanded using these portions of the code.
The macro parser, in turn, may call the normal Rust parser when it needs to
bind a metavariable (e.g.  <code>$my_expr</code>) while parsing the contents of a macro
invocation. The code for macro expansion is in
<a href="https://github.com/rust-lang/rust/tree/master/src/libsyntax/ext/tt"><code>src/libsyntax/ext/tt/</code></a>. This chapter aims to explain how macro
expansion works.</p>
<a class="header" href="print.html#example" id="example"><h3>Example</h3></a>
<p>It's helpful to have an example to refer to. For the remainder of this chapter,
whenever we refer to the &quot;example <em>definition</em>&quot;, we mean the following:</p>
<pre><code class="language-rust ignore">macro_rules! printer {
    (print $mvar:ident) =&gt; {
        println!(&quot;{}&quot;, $mvar);
    }
    (print twice $mvar:ident) =&gt; {
        println!(&quot;{}&quot;, $mvar);
        println!(&quot;{}&quot;, $mvar);
    }
}
</code></pre>
<p><code>$mvar</code> is called a <em>metavariable</em>. Unlike normal variables, rather than
binding to a value in a computation, a metavariable binds <em>at compile time</em> to
a tree of <em>tokens</em>.  A <em>token</em> is a single &quot;unit&quot; of the grammar, such as an
identifier (e.g. <code>foo</code>) or punctuation (e.g. <code>=&gt;</code>). There are also other
special tokens, such as <code>EOF</code>, which indicates that there are no more tokens.
Token trees resulting from paired parentheses-like characters (<code>(</code>...<code>)</code>,
<code>[</code>...<code>]</code>, and <code>{</code>...<code>}</code>) – they include the open and close and all the tokens
in between (we do require that parentheses-like characters be balanced). Having
macro expansion operate on token streams rather than the raw bytes of a source
file abstracts away a lot of complexity. The macro expander (and much of the
rest of the compiler) doesn't really care that much about the exact line and
column of some syntactic construct in the code; it cares about what constructs
are used in the code. Using tokens allows us to care about <em>what</em> without
worrying about <em>where</em>. For more information about tokens, see the
<a href="./the-parser.html">Parsing</a> chapter of this book.</p>
<p>Whenever we refer to the &quot;example <em>invocation</em>&quot;, we mean the following snippet:</p>
<pre><code class="language-rust ignore">printer!(print foo); // Assume `foo` is a variable defined somewhere else...
</code></pre>
<p>The process of expanding the macro invocation into the syntax tree
<code>println!(&quot;{}&quot;, foo)</code> and then expanding that into a call to <code>Display::fmt</code> is
called <em>macro expansion</em>, and it is the topic of this chapter.</p>
<a class="header" href="print.html#the-macro-parser" id="the-macro-parser"><h3>The macro parser</h3></a>
<p>There are two parts to macro expansion: parsing the definition and parsing the
invocations. Interestingly, both are done by the macro parser.</p>
<p>Basically, the macro parser is like an NFA-based regex parser. It uses an
algorithm similar in spirit to the <a href="https://en.wikipedia.org/wiki/Earley_parser">Earley parsing
algorithm</a>. The macro parser is
defined in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ext/tt/macro_parser/"><code>src/libsyntax/ext/tt/macro_parser.rs</code></a>.</p>
<p>The interface of the macro parser is as follows (this is slightly simplified):</p>
<pre><code class="language-rust ignore">fn parse(
    sess: ParserSession,
    tts: TokenStream,
    ms: &amp;[TokenTree]
) -&gt; NamedParseResult
</code></pre>
<p>In this interface:</p>
<ul>
<li><code>sess</code> is a &quot;parsing session&quot;, which keeps track of some metadata. Most
notably, this is used to keep track of errors that are generated so they can
be reported to the user.</li>
<li><code>tts</code> is a stream of tokens. The macro parser's job is to consume the raw
stream of tokens and output a binding of metavariables to corresponding token
trees.</li>
<li><code>ms</code> a <em>matcher</em>. This is a sequence of token trees that we want to match
<code>tts</code> against.</li>
</ul>
<p>In the analogy of a regex parser, <code>tts</code> is the input and we are matching it
against the pattern <code>ms</code>. Using our examples, <code>tts</code> could be the stream of
tokens containing the inside of the example invocation <code>print foo</code>, while <code>ms</code>
might be the sequence of token (trees) <code>print $mvar:ident</code>.</p>
<p>The output of the parser is a <code>NamedParseResult</code>, which indicates which of
three cases has occured:</p>
<ul>
<li>Success: <code>tts</code> matches the given matcher <code>ms</code>, and we have produced a binding
from metavariables to the corresponding token trees.</li>
<li>Failure: <code>tts</code> does not match <code>ms</code>. This results in an error message such as
&quot;No rule expected token <em>blah</em>&quot;.</li>
<li>Error: some fatal error has occured <em>in the parser</em>. For example, this happens
if there are more than one pattern match, since that indicates the macro is
ambiguous.</li>
</ul>
<p>The full interface is defined <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ext/tt/macro_parser/fn.parse.html">here</a>.</p>
<p>The macro parser does pretty much exactly the same as a normal regex parser with
one exception: in order to parse different types of metavariables, such as
<code>ident</code>, <code>block</code>, <code>expr</code>, etc., the macro parser must sometimes call back to the
normal Rust parser.</p>
<p>As mentioned above, both definitions and invocations of macros are parsed using
the macro parser. This is extremely non-intuitive and self-referential. The code
to parse macro <em>definitions</em> is in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ext/tt/macro_rules/"><code>src/libsyntax/ext/tt/macro_rules.rs</code></a>. It defines the pattern for
matching for a macro definition as <code>$( $lhs:tt =&gt; $rhs:tt );+</code>. In other words,
a <code>macro_rules</code> defintion should have in its body at least one occurence of a
token tree followed by <code>=&gt;</code> followed by another token tree. When the compiler
comes to a <code>macro_rules</code> definition, it uses this pattern to match the two token
trees per rule in the definition of the macro <em>using the macro parser itself</em>.
In our example definition, the metavariable <code>$lhs</code> would match the patterns of
both arms: <code>(print $mvar:ident)</code> and <code>(print twice $mvar:ident)</code>.  And <code>$rhs</code>
would match the bodies of both arms: <code>{ println!(&quot;{}&quot;, $mvar); }</code> and <code>{ println!(&quot;{}&quot;, $mvar); println!(&quot;{}&quot;, $mvar); }</code>. The parser would keep this
knowledge around for when it needs to expand a macro invocation.</p>
<p>When the compiler comes to a macro invocation, it parses that invocation using
the same NFA-based macro parser that is described above. However, the matcher
used is the first token tree (<code>$lhs</code>) extracted from the arms of the macro
<em>definition</em>. Using our example, we would try to match the token stream <code>print foo</code> from the invocation against the matchers <code>print $mvar:ident</code> and <code>print twice $mvar:ident</code> that we previously extracted from the definition.  The
algorithm is exactly the same, but when the macro parser comes to a place in the
current matcher where it needs to match a <em>non-terminal</em> (e.g. <code>$mvar:ident</code>),
it calls back to the normal Rust parser to get the contents of that
non-terminal. In this case, the Rust parser would look for an <code>ident</code> token,
which it finds (<code>foo</code>) and returns to the macro parser. Then, the macro parser
proceeds in parsing as normal. Also, note that exactly one of the matchers from
the various arms should match the invocation; if there is more than one match,
the parse is ambiguous, while if there are no matches at all, there is a syntax
error.</p>
<p>For more information about the macro parser's implementation, see the comments
in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ext/tt/macro_parser/"><code>src/libsyntax/ext/tt/macro_parser.rs</code></a>.</p>
<a class="header" href="print.html#hygiene" id="hygiene"><h3>Hygiene</h3></a>
<p>TODO</p>
<a class="header" href="print.html#procedural-macros" id="procedural-macros"><h3>Procedural Macros</h3></a>
<p>TODO</p>
<a class="header" href="print.html#custom-derive" id="custom-derive"><h3>Custom Derive</h3></a>
<p>TODO</p>
<a class="header" href="print.html#name-resolution" id="name-resolution"><h1>Name resolution</h1></a>
<p>The name resolution is a separate pass in the compiler. Its input is the syntax
tree, produced by parsing input files. It produces links from all the names in
the source to relevant places where the name was introduced. It also generates
helpful error messages, like typo suggestions, traits to import or lints about
unused items.</p>
<p>A successful run of the name resolution (<code>Resolver::resolve_crate</code>) creates kind
of an index the rest of the compilation may use to ask about the present names
(through the <code>hir::lowering::Resolver</code> interface).</p>
<p>The name resolution lives in the <code>librustc_resolve</code> crate, with the meat in
<code>lib.rs</code> and some helpers or symbol-type specific logic in the other modules.</p>
<a class="header" href="print.html#namespaces" id="namespaces"><h2>Namespaces</h2></a>
<p>Different kind of symbols live in different namespaces ‒ eg. types don't
clash with variables. This usually doesn't happen, because variables start with
lower-case letter while types with upper case one, but this is only a
convention. This is legal Rust code that'll compile (with warnings):</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type x = u32;
let x: x = 1;
let y: x = 2; // See? x is still a type here.
#}</code></pre></pre>
<p>To cope with this, and with slightly different scoping rules for these
namespaces, the resolver keeps them separated and builds separate structures for
them.</p>
<p>In other words, when the code talks about namespaces, it doesn't mean the module
hierarchy, it's types vs. values vs. macros.</p>
<a class="header" href="print.html#scopes-and-ribs" id="scopes-and-ribs"><h2>Scopes and ribs</h2></a>
<p>A name is visible only in certain area in the source code. This forms a
hierarchical structure, but not necessarily a simple one ‒ if one scope is part
of another, it doesn't mean the name visible in the outer one is also visible in
the inner one, or that it refers to the same thing.</p>
<p>To cope with that, the compiler introduces the concept of Ribs. This is
abstraction of a scope. Every time the set of visible names potentially changes,
a new rib is pushed onto a stack. The places where this can happen includes for
example:</p>
<ul>
<li>The obvious places ‒ curly braces enclosing a block, function boundaries,
modules.</li>
<li>Introducing a let binding ‒ this can shadow another binding with the same
name.</li>
<li>Macro expansion border ‒ to cope with macro hygiene.</li>
</ul>
<p>When searching for a name, the stack of ribs is traversed from the innermost
outwards. This helps to find the closest meaning of the name (the one not
shadowed by anything else). The transition to outer rib may also change the
rules what names are usable ‒ if there are nested functions (not closures), the
inner one can't access parameters and local bindings of the outer one, even
though they should be visible by ordinary scoping rules. An example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn do_something&lt;T: Default&gt;(val: T) { // &lt;- New rib in both types and values (1)
    // `val` is accessible, as is the helper function
    // `T` is accessible
    let helper = || { // New rib on `helper` (2) and another on the block (3)
        // `val` is accessible here
    }; // End of (3)
    // `val` is accessible, `helper` variable shadows `helper` function
    fn helper() { // &lt;- New rib in both types and values (4)
        // `val` is not accessible here, (4) is not transparent for locals)
        // `T` is not accessible here
    } // End of (4)
    let val = T::default(); // New rib (5)
    // `val` is the variable, not the parameter here
} // End of (5), (2) and (1)
#}</code></pre></pre>
<p>Because the rules for different namespaces are a bit different, each namespace
has its own independent rib stack that is constructed in parallel to the others.
In addition, there's also a rib stack for local labels (eg. names of loops or
blocks), which isn't a full namespace in its own right.</p>
<a class="header" href="print.html#overall-strategy" id="overall-strategy"><h2>Overall strategy</h2></a>
<p>To perform the name resolution of the whole crate, the syntax tree is traversed
top-down and every encountered name is resolved. This works for most kinds of
names, because at the point of use of a name it is already introduced in the Rib
hierarchy.</p>
<p>There are some exceptions to this. Items are bit tricky, because they can be
used even before encountered ‒ therefore every block needs to be first scanned
for items to fill in its Rib.</p>
<p>Other, even more problematic ones, are imports which need recursive fixed-point
resolution and macros, that need to be resolved and expanded before the rest of
the code can be processed.</p>
<p>Therefore, the resolution is performed in multiple stages.</p>
<a class="header" href="print.html#todo" id="todo"><h2>TODO:</h2></a>
<p>This is a result of the first pass of learning the code. It is definitely
incomplete and not detailed enough. It also might be inaccurate in places.
Still, it probably provides useful first guidepost to what happens in there.</p>
<ul>
<li>What exactly does it link to and how is that published and consumed by
following stages of compilation?</li>
<li>Who calls it and how it is actually used.</li>
<li>Is it a pass and then the result is only used, or can it be computed
incrementally (eg. for RLS)?</li>
<li>The overall strategy description is a bit vague.</li>
<li>Where does the name <code>Rib</code> come from?</li>
<li>Does this thing have its own tests, or is it tested only as part of some e2e
testing?</li>
</ul>
<a class="header" href="print.html#the-hir" id="the-hir"><h1>The HIR</h1></a>
<p>The HIR – &quot;High-Level Intermediate Representation&quot; – is the primary IR used in
most of rustc. It is a compiler-friendly representation of the abstract syntax
tree (AST) that is generated after parsing, macro expansion, and name
resolution. Many parts of HIR resemble Rust surface syntax quite closely, with
the exception that some of Rust's expression forms have been desugared away. For
example, <code>for</code> loops are converted into a <code>loop</code> and do not appear in the HIR.
This makes HIR more amenable to analysis than a normal AST.</p>
<p>This chapter covers the main concepts of the HIR.</p>
<p>You can view the HIR representation of your code by passing the
<code>-Zunpretty=hir-tree</code> flag to rustc:</p>
<pre><code class="language-bash">&gt; cargo rustc -- -Zunpretty=hir-tree
</code></pre>
<a class="header" href="print.html#out-of-band-storage-and-the-crate-type" id="out-of-band-storage-and-the-crate-type"><h3>Out-of-band storage and the <code>Crate</code> type</h3></a>
<p>The top-level data-structure in the HIR is the <code>Crate</code>, which stores
the contents of the crate currently being compiled (we only ever
construct HIR for the current crate). Whereas in the AST the crate
data structure basically just contains the root module, the HIR
<code>Crate</code> structure contains a number of maps and other things that
serve to organize the content of the crate for easier access.</p>
<p>For example, the contents of individual items (e.g. modules,
functions, traits, impls, etc) in the HIR are not immediately
accessible in the parents. So, for example, if there is a module item
<code>foo</code> containing a function <code>bar()</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod foo {
    fn bar() { }
}
#}</code></pre></pre>
<p>then in the HIR the representation of module <code>foo</code> (the <code>Mod</code>
stuct) would only have the <strong><code>ItemId</code></strong> <code>I</code> of <code>bar()</code>. To get the
details of the function <code>bar()</code>, we would lookup <code>I</code> in the
<code>items</code> map.</p>
<p>One nice result from this representation is that one can iterate
over all items in the crate by iterating over the key-value pairs
in these maps (without the need to trawl through the whole HIR).
There are similar maps for things like trait items and impl items,
as well as &quot;bodies&quot; (explained below).</p>
<p>The other reason to set up the representation this way is for better
integration with incremental compilation. This way, if you gain access
to an <code>&amp;hir::Item</code> (e.g. for the mod <code>foo</code>), you do not immediately
gain access to the contents of the function <code>bar()</code>. Instead, you only
gain access to the <strong>id</strong> for <code>bar()</code>, and you must invoke some
function to lookup the contents of <code>bar()</code> given its id; this gives the
compiler a chance to observe that you accessed the data for <code>bar()</code>,
and then record the dependency.</p>
<a class="header" href="print.html#identifiers-in-the-hir" id="identifiers-in-the-hir"><h3>Identifiers in the HIR</h3></a>
<p>Most of the code that has to deal with things in HIR tends not to
carry around references into the HIR, but rather to carry around
<em>identifier numbers</em> (or just &quot;ids&quot;). Right now, you will find four
sorts of identifiers in active use:</p>
<ul>
<li><code>DefId</code>, which primarily names &quot;definitions&quot; or top-level items.
<ul>
<li>You can think of a <code>DefId</code> as being shorthand for a very explicit
and complete path, like <code>std::collections::HashMap</code>. However,
these paths are able to name things that are not nameable in
normal Rust (e.g. impls), and they also include extra information
about the crate (such as its version number, as two versions of
the same crate can co-exist).</li>
<li>A <code>DefId</code> really consists of two parts, a <code>CrateNum</code> (which
identifies the crate) and a <code>DefIndex</code> (which indixes into a list
of items that is maintained per crate).</li>
</ul>
</li>
<li><code>HirId</code>, which combines the index of a particular item with an
offset within that item.
<ul>
<li>the key point of a <code>HirId</code> is that it is <em>relative</em> to some item
(which is named via a <code>DefId</code>).</li>
</ul>
</li>
<li><code>BodyId</code>, this is an absolute identifier that refers to a specific
body (definition of a function or constant) in the crate. It is currently
effectively a &quot;newtype'd&quot; <code>NodeId</code>.</li>
<li><code>NodeId</code>, which is an absolute id that identifies a single node in the HIR
tree.
<ul>
<li>While these are still in common use, <strong>they are being slowly phased out</strong>.</li>
<li>Since they are absolute within the crate, adding a new node anywhere in the
tree causes the <code>NodeId</code>s of all subsequent code in the crate to change.
This is terrible for incremental compilation, as you can perhaps imagine.</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#the-hir-map" id="the-hir-map"><h3>The HIR Map</h3></a>
<p>Most of the time when you are working with the HIR, you will do so via
the <strong>HIR Map</strong>, accessible in the tcx via <code>tcx.hir</code> (and defined in
the <code>hir::map</code> module). The HIR map contains a number of methods to
convert between IDs of various kinds and to lookup data associated
with an HIR node.</p>
<p>For example, if you have a <code>DefId</code>, and you would like to convert it
to a <code>NodeId</code>, you can use <code>tcx.hir.as_local_node_id(def_id)</code>. This
returns an <code>Option&lt;NodeId&gt;</code> – this will be <code>None</code> if the def-id
refers to something outside of the current crate (since then it has no
HIR node), but otherwise returns <code>Some(n)</code> where <code>n</code> is the node-id of
the definition.</p>
<p>Similarly, you can use <code>tcx.hir.find(n)</code> to lookup the node for a
<code>NodeId</code>. This returns a <code>Option&lt;Node&lt;'tcx&gt;&gt;</code>, where <code>Node</code> is an enum
defined in the map; by matching on this you can find out what sort of
node the node-id referred to and also get a pointer to the data
itself. Often, you know what sort of node <code>n</code> is – e.g. if you know
that <code>n</code> must be some HIR expression, you can do
<code>tcx.hir.expect_expr(n)</code>, which will extract and return the
<code>&amp;hir::Expr</code>, panicking if <code>n</code> is not in fact an expression.</p>
<p>Finally, you can use the HIR map to find the parents of nodes, via
calls like <code>tcx.hir.get_parent_node(n)</code>.</p>
<a class="header" href="print.html#hir-bodies" id="hir-bodies"><h3>HIR Bodies</h3></a>
<p>A <strong>body</strong> represents some kind of executable code, such as the body
of a function/closure or the definition of a constant. Bodies are
associated with an <strong>owner</strong>, which is typically some kind of item
(e.g. an <code>fn()</code> or <code>const</code>), but could also be a closure expression
(e.g. <code>|x, y| x + y</code>). You can use the HIR map to find the body
associated with a given def-id (<code>maybe_body_owned_by()</code>) or to find
the owner of a body (<code>body_owner_def_id()</code>).</p>
<a class="header" href="print.html#the-ty-module-representing-types" id="the-ty-module-representing-types"><h1>The <code>ty</code> module: representing types</h1></a>
<p>The <code>ty</code> module defines how the Rust compiler represents types
internally. It also defines the <em>typing context</em> (<code>tcx</code> or <code>TyCtxt</code>),
which is the central data structure in the compiler.</p>
<a class="header" href="print.html#the-tcx-and-how-it-uses-lifetimes" id="the-tcx-and-how-it-uses-lifetimes"><h2>The tcx and how it uses lifetimes</h2></a>
<p>The <code>tcx</code> (&quot;typing context&quot;) is the central data structure in the
compiler. It is the context that you use to perform all manner of
queries. The struct <code>TyCtxt</code> defines a reference to this shared context:</p>
<pre><code class="language-rust ignore">tcx: TyCtxt&lt;'a, 'gcx, 'tcx&gt;
//          --  ----  ----
//          |   |     |
//          |   |     innermost arena lifetime (if any)
//          |   &quot;global arena&quot; lifetime
//          lifetime of this reference
</code></pre>
<p>As you can see, the <code>TyCtxt</code> type takes three lifetime parameters.
These lifetimes are perhaps the most complex thing to understand about
the tcx. During Rust compilation, we allocate most of our memory in
<strong>arenas</strong>, which are basically pools of memory that get freed all at
once. When you see a reference with a lifetime like <code>'tcx</code> or <code>'gcx</code>,
you know that it refers to arena-allocated data (or data that lives as
long as the arenas, anyhow).</p>
<p>We use two distinct levels of arenas. The outer level is the &quot;global
arena&quot;. This arena lasts for the entire compilation: so anything you
allocate in there is only freed once compilation is basically over
(actually, when we shift to executing LLVM).</p>
<p>To reduce peak memory usage, when we do type inference, we also use an
inner level of arena. These arenas get thrown away once type inference
is over. This is done because type inference generates a lot of
&quot;throw-away&quot; types that are not particularly interesting after type
inference completes, so keeping around those allocations would be
wasteful.</p>
<p>Often, we wish to write code that explicitly asserts that it is not
taking place during inference. In that case, there is no &quot;local&quot;
arena, and all the types that you can access are allocated in the
global arena.  To express this, the idea is to use the same lifetime
for the <code>'gcx</code> and <code>'tcx</code> parameters of <code>TyCtxt</code>. Just to be a touch
confusing, we tend to use the name <code>'tcx</code> in such contexts. Here is an
example:</p>
<pre><code class="language-rust ignore">fn not_in_inference&lt;'a, 'tcx&gt;(tcx: TyCtxt&lt;'a, 'tcx, 'tcx&gt;, def_id: DefId) {
    //                                        ----  ----
    //                                        Using the same lifetime here asserts
    //                                        that the innermost arena accessible through
    //                                        this reference *is* the global arena.
}
</code></pre>
<p>In contrast, if we want to code that can be usable during type inference, then
you need to declare a distinct <code>'gcx</code> and <code>'tcx</code> lifetime parameter:</p>
<pre><code class="language-rust ignore">fn maybe_in_inference&lt;'a, 'gcx, 'tcx&gt;(tcx: TyCtxt&lt;'a, 'gcx, 'tcx&gt;, def_id: DefId) {
    //                                                ----  ----
    //                                        Using different lifetimes here means that
    //                                        the innermost arena *may* be distinct
    //                                        from the global arena (but doesn't have to be).
}
</code></pre>
<a class="header" href="print.html#allocating-and-working-with-types" id="allocating-and-working-with-types"><h3>Allocating and working with types</h3></a>
<p>Rust types are represented using the <code>Ty&lt;'tcx&gt;</code> defined in the <code>ty</code>
module (not to be confused with the <code>Ty</code> struct from <a href="./hir.html">the HIR</a>). This
is in fact a simple type alias for a reference with <code>'tcx</code> lifetime:</p>
<pre><code class="language-rust ignore">pub type Ty&lt;'tcx&gt; = &amp;'tcx TyS&lt;'tcx&gt;;
</code></pre>
<p>You can basically ignore the <code>TyS</code> struct – you will basically never
access it explicitly. We always pass it by reference using the
<code>Ty&lt;'tcx&gt;</code> alias – the only exception I think is to define inherent
methods on types. Instances of <code>TyS</code> are only ever allocated in one of
the rustc arenas (never e.g. on the stack).</p>
<p>One common operation on types is to <strong>match</strong> and see what kinds of
types they are. This is done by doing <code>match ty.sty</code>, sort of like this:</p>
<pre><code class="language-rust ignore">fn test_type&lt;'tcx&gt;(ty: Ty&lt;'tcx&gt;) {
    match ty.sty {
        ty::TyArray(elem_ty, len) =&gt; { ... }
        ...
    }
}
</code></pre>
<p>The <code>sty</code> field (the origin of this name is unclear to me; perhaps
structural type?) is of type <code>TypeVariants&lt;'tcx&gt;</code>, which is an enum
defining all of the different kinds of types in the compiler.</p>
<blockquote>
<p>N.B. inspecting the <code>sty</code> field on types during type inference can be
risky, as there may be inference variables and other things to
consider, or sometimes types are not yet known that will become
known later.).</p>
</blockquote>
<p>To allocate a new type, you can use the various <code>mk_</code> methods defined
on the <code>tcx</code>. These have names that correpond mostly to the various kinds
of type variants. For example:</p>
<pre><code class="language-rust ignore">let array_ty = tcx.mk_array(elem_ty, len * 2);
</code></pre>
<p>These methods all return a <code>Ty&lt;'tcx&gt;</code> – note that the lifetime you
get back is the lifetime of the innermost arena that this <code>tcx</code> has
access to. In fact, types are always canonicalized and interned (so we
never allocate exactly the same type twice) and are always allocated
in the outermost arena where they can be (so, if they do not contain
any inference variables or other &quot;temporary&quot; types, they will be
allocated in the global arena). However, the lifetime <code>'tcx</code> is always
a safe approximation, so that is what you get back.</p>
<blockquote>
<p>NB. Because types are interned, it is possible to compare them for
equality efficiently using <code>==</code> – however, this is almost never what
you want to do unless you happen to be hashing and looking for
duplicates. This is because often in Rust there are multiple ways to
represent the same type, particularly once inference is involved. If
you are going to be testing for type equality, you probably need to
start looking into the inference code to do it right.</p>
</blockquote>
<p>You can also find various common types in the <code>tcx</code> itself by accessing
<code>tcx.types.bool</code>, <code>tcx.types.char</code>, etc (see <code>CommonTypes</code> for more).</p>
<a class="header" href="print.html#beyond-types-other-kinds-of-arena-allocated-data-structures" id="beyond-types-other-kinds-of-arena-allocated-data-structures"><h3>Beyond types: other kinds of arena-allocated data structures</h3></a>
<p>In addition to types, there are a number of other arena-allocated data
structures that you can allocate, and which are found in this
module. Here are a few examples:</p>
<ul>
<li><code>Substs</code>, allocated with <code>mk_substs</code> – this will intern a slice of types,
often used to specify the values to be substituted for generics
(e.g. <code>HashMap&lt;i32, u32&gt;</code> would be represented as a slice
<code>&amp;'tcx [tcx.types.i32, tcx.types.u32]</code>).</li>
<li><code>TraitRef</code>, typically passed by value – a <strong>trait reference</strong>
consists of a reference to a trait along with its various type
parameters (including <code>Self</code>), like <code>i32: Display</code> (here, the def-id
would reference the <code>Display</code> trait, and the substs would contain
<code>i32</code>).</li>
<li><code>Predicate</code> defines something the trait system has to prove (see <code>traits</code>
module).</li>
</ul>
<a class="header" href="print.html#import-conventions" id="import-conventions"><h3>Import conventions</h3></a>
<p>Although there is no hard and fast rule, the <code>ty</code> module tends to be used like
so:</p>
<pre><code class="language-rust ignore">use ty::{self, Ty, TyCtxt};
</code></pre>
<p>In particular, since they are so common, the <code>Ty</code> and <code>TyCtxt</code> types
are imported directly. Other types are often referenced with an
explicit <code>ty::</code> prefix (e.g. <code>ty::TraitRef&lt;'tcx&gt;</code>). But some modules
choose to import a larger or smaller set of names explicitly.</p>
<a class="header" href="print.html#type-inference" id="type-inference"><h1>Type inference</h1></a>
<p>Type inference is the process of automatic detection of the type of an
expression.</p>
<p>It is what allows Rust to work with fewer or no type annotations,
making things easier for users:</p>
<pre><code class="language-rust ignore">fn main() {
    let mut things = vec![];
    things.push(&quot;thing&quot;)
}
</code></pre>
<p>Here, the type of <code>things</code> is <em>inferenced</em> to be <code>&amp;str</code> because that's the value
we push into <code>things</code>.</p>
<p>The type inference is based on the standard Hindley-Milner (HM) type inference
algorithm, but extended in various way to accommodate subtyping, region
inference, and higher-ranked types.</p>
<a class="header" href="print.html#a-note-on-terminology" id="a-note-on-terminology"><h2>A note on terminology</h2></a>
<p>We use the notation <code>?T</code> to refer to inference variables, also called
existential variables.</p>
<p>We use the terms &quot;region&quot; and &quot;lifetime&quot; interchangeably. Both refer to
the <code>'a</code> in <code>&amp;'a T</code>.</p>
<p>The term &quot;bound region&quot; refers to a region that is bound in a function
signature, such as the <code>'a</code> in <code>for&lt;'a&gt; fn(&amp;'a u32)</code>. A region is
&quot;free&quot; if it is not bound.</p>
<a class="header" href="print.html#creating-an-inference-context" id="creating-an-inference-context"><h2>Creating an inference context</h2></a>
<p>You create and &quot;enter&quot; an inference context by doing something like
the following:</p>
<pre><code class="language-rust ignore">tcx.infer_ctxt().enter(|infcx| {
    // Use the inference context `infcx` here.
})
</code></pre>
<p>Each inference context creates a short-lived type arena to store the
fresh types and things that it will create, as described in the
<a href="ty.html">chapter on the <code>ty</code> module</a>. This arena is created by the <code>enter</code>
function and disposed of after it returns.</p>
<p>Within the closure, <code>infcx</code> has the type <code>InferCtxt&lt;'cx, 'gcx, 'tcx&gt;</code>
for some fresh <code>'cx</code> and <code>'tcx</code> – the latter corresponds to the lifetime of
this temporary arena, and the <code>'cx</code> is the lifetime of the <code>InferCtxt</code> itself.
(Again, see the <a href="ty.html"><code>ty</code> chapter</a> for more details on this setup.)</p>
<p>The <code>tcx.infer_ctxt</code> method actually returns a builder, which means
there are some kinds of configuration you can do before the <code>infcx</code> is
created. See <code>InferCtxtBuilder</code> for more information.</p>
<p><a name="vars"></a></p>
<a class="header" href="print.html#inference-variables" id="inference-variables"><h2>Inference variables</h2></a>
<p>The main purpose of the inference context is to house a bunch of
<strong>inference variables</strong> – these represent types or regions whose precise
value is not yet known, but will be uncovered as we perform type-checking.</p>
<p>If you're familiar with the basic ideas of unification from H-M type
systems, or logic languages like Prolog, this is the same concept. If
you're not, you might want to read a tutorial on how H-M type
inference works, or perhaps this blog post on
<a href="http://smallcultfollowing.com/babysteps/blog/2017/03/25/unification-in-chalk-part-1/">unification in the Chalk project</a>.</p>
<p>All told, the inference context stores four kinds of inference variables as of
this writing:</p>
<ul>
<li>Type variables, which come in three varieties:
<ul>
<li>General type variables (the most common). These can be unified with any
type.</li>
<li>Integral type variables, which can only be unified with an integral type,
and arise from an integer literal expression like <code>22</code>.</li>
<li>Float type variables, which can only be unified with a float type, and
arise from a float literal expression like <code>22.0</code>.</li>
</ul>
</li>
<li>Region variables, which represent lifetimes, and arise all over the place.</li>
</ul>
<p>All the type variables work in much the same way: you can create a new
type variable, and what you get is <code>Ty&lt;'tcx&gt;</code> representing an
unresolved type <code>?T</code>. Then later you can apply the various operations
that the inferencer supports, such as equality or subtyping, and it
will possibly <strong>instantiate</strong> (or <strong>bind</strong>) that <code>?T</code> to a specific
value as a result.</p>
<p>The region variables work somewhat differently, and are described
below in a separate section.</p>
<a class="header" href="print.html#enforcing-equality--subtyping" id="enforcing-equality--subtyping"><h2>Enforcing equality / subtyping</h2></a>
<p>The most basic operations you can perform in the type inferencer is
<strong>equality</strong>, which forces two types <code>T</code> and <code>U</code> to be the same. The
recommended way to add an equality constraint is to use the <code>at</code>
method, roughly like so:</p>
<pre><code class="language-rust ignore">infcx.at(...).eq(t, u);
</code></pre>
<p>The first <code>at()</code> call provides a bit of context, i.e. why you are
doing this unification, and in what environment, and the <code>eq</code> method
performs the actual equality constraint.</p>
<p>When you equate things, you force them to be precisely equal. Equating
returns an <code>InferResult</code> – if it returns <code>Err(err)</code>, then equating
failed, and the enclosing <code>TypeError</code> will tell you what went wrong.</p>
<p>The success case is perhaps more interesting. The &quot;primary&quot; return
type of <code>eq</code> is <code>()</code> – that is, when it succeeds, it doesn't return a
value of any particular interest. Rather, it is executed for its
side-effects of constraining type variables and so forth. However, the
actual return type is not <code>()</code>, but rather <code>InferOk&lt;()&gt;</code>. The
<code>InferOk</code> type is used to carry extra trait obligations – your job is
to ensure that these are fulfilled (typically by enrolling them in a
fulfillment context). See the <a href="traits/resolution.html">trait chapter</a> for more background on that.</p>
<p>You can similarly enforce subtyping through <code>infcx.at(..).sub(..)</code>. The same
basic concepts as above apply.</p>
<a class="header" href="print.html#trying-equality" id="trying-equality"><h2>&quot;Trying&quot; equality</h2></a>
<p>Sometimes you would like to know if it is <em>possible</em> to equate two
types without error.  You can test that with <code>infcx.can_eq</code> (or
<code>infcx.can_sub</code> for subtyping). If this returns <code>Ok</code>, then equality
is possible – but in all cases, any side-effects are reversed.</p>
<p>Be aware, though, that the success or failure of these methods is always
<strong>modulo regions</strong>. That is, two types <code>&amp;'a u32</code> and <code>&amp;'b u32</code> will
return <code>Ok</code> for <code>can_eq</code>, even if <code>'a != 'b</code>.  This falls out from the
&quot;two-phase&quot; nature of how we solve region constraints.</p>
<a class="header" href="print.html#snapshots" id="snapshots"><h2>Snapshots</h2></a>
<p>As described in the previous section on <code>can_eq</code>, often it is useful
to be able to do a series of operations and then roll back their
side-effects. This is done for various reasons: one of them is to be
able to backtrack, trying out multiple possibilities before settling
on which path to take. Another is in order to ensure that a series of
smaller changes take place atomically or not at all.</p>
<p>To allow for this, the inference context supports a <code>snapshot</code> method.
When you call it, it will start recording changes that occur from the
operations you perform. When you are done, you can either invoke
<code>rollback_to</code>, which will undo those changes, or else <code>confirm</code>, which
will make the permanent. Snapshots can be nested as long as you follow
a stack-like discipline.</p>
<p>Rather than use snapshots directly, it is often helpful to use the
methods like <code>commit_if_ok</code> or <code>probe</code> that encapsulate higher-level
patterns.</p>
<a class="header" href="print.html#subtyping-obligations" id="subtyping-obligations"><h2>Subtyping obligations</h2></a>
<p>One thing worth discussing is subtyping obligations. When you force
two types to be a subtype, like <code>?T &lt;: i32</code>, we can often convert those
into equality constraints. This follows from Rust's rather limited notion
of subtyping: so, in the above case, <code>?T &lt;: i32</code> is equivalent to <code>?T = i32</code>.</p>
<p>However, in some cases we have to be more careful. For example, when
regions are involved. So if you have <code>?T &lt;: &amp;'a i32</code>, what we would do
is to first &quot;generalize&quot; <code>&amp;'a i32</code> into a type with a region variable:
<code>&amp;'?b i32</code>, and then unify <code>?T</code> with that (<code>?T = &amp;'?b i32</code>). We then
relate this new variable with the original bound:</p>
<pre><code class="language-text">&amp;'?b i32 &lt;: &amp;'a i32
</code></pre>
<p>This will result in a region constraint (see below) of <code>'?b: 'a</code>.</p>
<p>One final interesting case is relating two unbound type variables,
like <code>?T &lt;: ?U</code>.  In that case, we can't make progress, so we enqueue
an obligation <code>Subtype(?T, ?U)</code> and return it via the <code>InferOk</code>
mechanism. You'll have to try again when more details about <code>?T</code> or
<code>?U</code> are known.</p>
<a class="header" href="print.html#region-constraints" id="region-constraints"><h2>Region constraints</h2></a>
<p>Regions are inferenced somewhat differently from types. Rather than
eagerly unifying things, we simply collect constraints as we go, but
make (almost) no attempt to solve regions. These constraints have the
form of an &quot;outlives&quot; constraint:</p>
<pre><code class="language-text">'a: 'b
</code></pre>
<p>Actually the code tends to view them as a subregion relation, but it's the same
idea:</p>
<pre><code class="language-text">'b &lt;= 'a
</code></pre>
<p>(There are various other kinds of constraints, such as &quot;verifys&quot;; see
the <code>region_constraints</code> module for details.)</p>
<p>There is one case where we do some amount of eager unification. If you have an
equality constraint between two regions</p>
<pre><code class="language-text">'a = 'b
</code></pre>
<p>we will record that fact in a unification table. You can then use
<code>opportunistic_resolve_var</code> to convert <code>'b</code> to <code>'a</code> (or vice
versa). This is sometimes needed to ensure termination of fixed-point
algorithms.</p>
<a class="header" href="print.html#extracting-region-constraints" id="extracting-region-constraints"><h2>Extracting region constraints</h2></a>
<p>Ultimately, region constraints are only solved at the very end of
type-checking, once all other constraints are known. There are two
ways to solve region constraints right now: lexical and
non-lexical. Eventually there will only be one.</p>
<p>To solve <strong>lexical</strong> region constraints, you invoke
<code>resolve_regions_and_report_errors</code>.  This &quot;closes&quot; the region
constraint process and invoke the <code>lexical_region_resolve</code> code. Once
this is done, any further attempt to equate or create a subtyping
relationship will yield an ICE.</p>
<p>Non-lexical region constraints are not handled within the inference
context. Instead, the NLL solver (actually, the MIR type-checker)
invokes <code>take_and_reset_region_constraints</code> periodically. This
extracts all of the outlives constraints from the region solver, but
leaves the set of variables intact. This is used to get <em>just</em> the
region constraints that resulted from some particular point in the
program, since the NLL solver needs to know not just <em>what</em> regions
were subregions but <em>where</em>. Finally, the NLL solver invokes
<code>take_region_var_origins</code>, which &quot;closes&quot; the region constraint
process in the same way as normal solving.</p>
<a class="header" href="print.html#lexical-region-resolution" id="lexical-region-resolution"><h2>Lexical region resolution</h2></a>
<p>Lexical region resolution is done by initially assigning each region
variable to an empty value. We then process each outlives constraint
repeatedly, growing region variables until a fixed-point is reached.
Region variables can be grown using a least-upper-bound relation on
the region lattice in a fairly straightforward fashion.</p>
<a class="header" href="print.html#trait-resolution-old-style" id="trait-resolution-old-style"><h1>Trait resolution (old-style)</h1></a>
<p>This chapter describes the general process of <em>trait resolution</em> and points out
some non-obvious things.</p>
<p><strong>Note:</strong> This chapter (and its subchapters) describe how the trait
solver <strong>currently</strong> works. However, we are in the process of
designing a new trait solver. If you'd prefer to read about <em>that</em>,
see <a href="./traits/index.html"><em>this</em> traits chapter</a>.</p>
<a class="header" href="print.html#major-concepts" id="major-concepts"><h2>Major concepts</h2></a>
<p>Trait resolution is the process of pairing up an impl with each
reference to a trait. So, for example, if there is a generic function like:</p>
<pre><code class="language-rust ignore">fn clone_slice&lt;T:Clone&gt;(x: &amp;[T]) -&gt; Vec&lt;T&gt; { ... }
</code></pre>
<p>and then a call to that function:</p>
<pre><code class="language-rust ignore">let v: Vec&lt;isize&gt; = clone_slice(&amp;[1, 2, 3])
</code></pre>
<p>it is the job of trait resolution to figure out whether there exists an impl of
(in this case) <code>isize : Clone</code>.</p>
<p>Note that in some cases, like generic functions, we may not be able to
find a specific impl, but we can figure out that the caller must
provide an impl. For example, consider the body of <code>clone_slice</code>:</p>
<pre><code class="language-rust ignore">fn clone_slice&lt;T:Clone&gt;(x: &amp;[T]) -&gt; Vec&lt;T&gt; {
    let mut v = Vec::new();
    for e in &amp;x {
        v.push((*e).clone()); // (*)
    }
}
</code></pre>
<p>The line marked <code>(*)</code> is only legal if <code>T</code> (the type of <code>*e</code>)
implements the <code>Clone</code> trait. Naturally, since we don't know what <code>T</code>
is, we can't find the specific impl; but based on the bound <code>T:Clone</code>,
we can say that there exists an impl which the caller must provide.</p>
<p>We use the term <em>obligation</em> to refer to a trait reference in need of
an impl. Basically, the trait resolution system resolves an obligation
by proving that an appropriate impl does exist.</p>
<p>During type checking, we do not store the results of trait selection.
We simply wish to verify that trait selection will succeed. Then
later, at trans time, when we have all concrete types available, we
can repeat the trait selection to choose an actual implementation, which
will then be generated in the output binary.</p>
<a class="header" href="print.html#overview" id="overview"><h2>Overview</h2></a>
<p>Trait resolution consists of three major parts:</p>
<ul>
<li>
<p><strong>Selection</strong>: Deciding how to resolve a specific obligation. For
example, selection might decide that a specific obligation can be
resolved by employing an impl which matches the <code>Self</code> type, or by using a
parameter bound (e.g. <code>T: Trait</code>). In the case of an impl, selecting one
obligation can create <em>nested obligations</em> because of where clauses
on the impl itself. It may also require evaluating those nested
obligations to resolve ambiguities.</p>
</li>
<li>
<p><strong>Fulfillment</strong>: The fulfillment code is what tracks that obligations
are completely fulfilled. Basically it is a worklist of obligations
to be selected: once selection is successful, the obligation is
removed from the worklist and any nested obligations are enqueued.</p>
</li>
<li>
<p><strong>Coherence</strong>: The coherence checks are intended to ensure that there
are never overlapping impls, where two impls could be used with
equal precedence.</p>
</li>
</ul>
<a class="header" href="print.html#selection" id="selection"><h2>Selection</h2></a>
<p>Selection is the process of deciding whether an obligation can be
resolved and, if so, how it is to be resolved (via impl, where clause, etc).
The main interface is the <code>select()</code> function, which takes an obligation
and returns a <code>SelectionResult</code>. There are three possible outcomes:</p>
<ul>
<li>
<p><code>Ok(Some(selection))</code> – yes, the obligation can be resolved, and
<code>selection</code> indicates how. If the impl was resolved via an impl,
then <code>selection</code> may also indicate nested obligations that are required
by the impl.</p>
</li>
<li>
<p><code>Ok(None)</code> – we are not yet sure whether the obligation can be
resolved or not. This happens most commonly when the obligation
contains unbound type variables.</p>
</li>
<li>
<p><code>Err(err)</code> – the obligation definitely cannot be resolved due to a
type error or because there are no impls that could possibly apply.</p>
</li>
</ul>
<p>The basic algorithm for selection is broken into two big phases:
candidate assembly and confirmation.</p>
<p>Note that because of how lifetime inference works, it is not possible to
give back immediate feedback as to whether a unification or subtype
relationship between lifetimes holds or not. Therefore, lifetime
matching is <em>not</em> considered during selection. This is reflected in
the fact that subregion assignment is infallible. This may yield
lifetime constraints that will later be found to be in error (in
contrast, the non-lifetime-constraints have already been checked
during selection and can never cause an error, though naturally they
may lead to other errors downstream).</p>
<a class="header" href="print.html#candidate-assembly" id="candidate-assembly"><h3>Candidate assembly</h3></a>
<p>Searches for impls/where-clauses/etc that might
possibly be used to satisfy the obligation. Each of those is called
a candidate. To avoid ambiguity, we want to find exactly one
candidate that is definitively applicable. In some cases, we may not
know whether an impl/where-clause applies or not – this occurs when
the obligation contains unbound inference variables.</p>
<p>The subroutines that decide whether a particular impl/where-clause/etc
applies to a particular obligation are collectively refered to as the
process of <em>matching</em>. At the moment, this amounts to
unifying the <code>Self</code> types, but in the future we may also recursively
consider some of the nested obligations, in the case of an impl.</p>
<p><strong>TODO</strong>: what does &quot;unifying the <code>Self</code> types&quot; mean? The <code>Self</code> of the
obligation with that of an impl?</p>
<p>The basic idea for candidate assembly is to do a first pass in which
we identify all possible candidates. During this pass, all that we do
is try and unify the type parameters. (In particular, we ignore any
nested where clauses.) Presuming that this unification succeeds, the
impl is added as a candidate.</p>
<p>Once this first pass is done, we can examine the set of candidates. If
it is a singleton set, then we are done: this is the only impl in
scope that could possibly apply. Otherwise, we can winnow down the set
of candidates by using where clauses and other conditions. If this
reduced set yields a single, unambiguous entry, we're good to go,
otherwise the result is considered ambiguous.</p>
<a class="header" href="print.html#the-basic-process-inferring-based-on-the-impls-we-see" id="the-basic-process-inferring-based-on-the-impls-we-see"><h4>The basic process: Inferring based on the impls we see</h4></a>
<p>This process is easier if we work through some examples. Consider
the following trait:</p>
<pre><code class="language-rust ignore">trait Convert&lt;Target&gt; {
    fn convert(&amp;self) -&gt; Target;
}
</code></pre>
<p>This trait just has one method. It's about as simple as it gets. It
converts from the (implicit) <code>Self</code> type to the <code>Target</code> type. If we
wanted to permit conversion between <code>isize</code> and <code>usize</code>, we might
implement <code>Convert</code> like so:</p>
<pre><code class="language-rust ignore">impl Convert&lt;usize&gt; for isize { ... } // isize -&gt; usize
impl Convert&lt;isize&gt; for usize { ... } // usize -&gt; isize
</code></pre>
<p>Now imagine there is some code like the following:</p>
<pre><code class="language-rust ignore">let x: isize = ...;
let y = x.convert();
</code></pre>
<p>The call to convert will generate a trait reference <code>Convert&lt;$Y&gt; for isize</code>, where <code>$Y</code> is the type variable representing the type of
<code>y</code>. Of the two impls we can see, the only one that matches is
<code>Convert&lt;usize&gt; for isize</code>. Therefore, we can
select this impl, which will cause the type of <code>$Y</code> to be unified to
<code>usize</code>. (Note that while assembling candidates, we do the initial
unifications in a transaction, so that they don't affect one another.)</p>
<p><strong>TODO</strong>: The example says we can &quot;select&quot; the impl, but this section is
talking specifically about candidate assembly. Does this mean we can sometimes
skip confirmation? Or is this poor wording?
<strong>TODO</strong>: Is the unification of <code>$Y</code> part of trait resolution or type
inference? Or is this not the same type of &quot;inference variable&quot; as in type
inference?</p>
<a class="header" href="print.html#winnowing-resolving-ambiguities" id="winnowing-resolving-ambiguities"><h4>Winnowing: Resolving ambiguities</h4></a>
<p>But what happens if there are multiple impls where all the types
unify? Consider this example:</p>
<pre><code class="language-rust ignore">trait Get {
    fn get(&amp;self) -&gt; Self;
}

impl&lt;T:Copy&gt; Get for T {
    fn get(&amp;self) -&gt; T { *self }
}

impl&lt;T:Get&gt; Get for Box&lt;T&gt; {
    fn get(&amp;self) -&gt; Box&lt;T&gt; { Box::new(get_it(&amp;**self)) }
}
</code></pre>
<p>What happens when we invoke <code>get_it(&amp;Box::new(1_u16))</code>, for example? In this
case, the <code>Self</code> type is <code>Box&lt;u16&gt;</code> – that unifies with both impls,
because the first applies to all types <code>T</code>, and the second to all
<code>Box&lt;T&gt;</code>. In order for this to be unambiguous, the compiler does a <em>winnowing</em>
pass that considers <code>where</code> clauses
and attempts to remove candidates. In this case, the first impl only
applies if <code>Box&lt;u16&gt; : Copy</code>, which doesn't hold. After winnowing,
then, we are left with just one candidate, so we can proceed.</p>
<a class="header" href="print.html#where-clauses" id="where-clauses"><h4><code>where</code> clauses</h4></a>
<p>Besides an impl, the other major way to resolve an obligation is via a
where clause. The selection process is always given a <a href="./param_env.html">parameter
environment</a> which contains a list of where clauses, which are
basically obligations that we can assume are satisfiable. We will iterate
over that list and check whether our current obligation can be found
in that list. If so, it is considered satisfied. More precisely, we
want to check whether there is a where-clause obligation that is for
the same trait (or some subtrait) and which can match against the obligation.</p>
<p>Consider this simple example:</p>
<pre><code class="language-rust ignore">trait A1 {
    fn do_a1(&amp;self);
}
trait A2 : A1 { ... }

trait B {
    fn do_b(&amp;self);
}

fn foo&lt;X:A2+B&gt;(x: X) {
    x.do_a1(); // (*)
    x.do_b();  // (#)
}
</code></pre>
<p>In the body of <code>foo</code>, clearly we can use methods of <code>A1</code>, <code>A2</code>, or <code>B</code>
on variable <code>x</code>. The line marked <code>(*)</code> will incur an obligation <code>X: A1</code>,
while the line marked <code>(#)</code> will incur an obligation <code>X: B</code>. Meanwhile,
the parameter environment will contain two where-clauses: <code>X : A2</code> and <code>X : B</code>.
For each obligation, then, we search this list of where-clauses. The
obligation <code>X: B</code> trivially matches against the where-clause <code>X: B</code>.
To resolve an obligation <code>X:A1</code>, we would note that <code>X:A2</code> implies that <code>X:A1</code>.</p>
<a class="header" href="print.html#confirmation" id="confirmation"><h3>Confirmation</h3></a>
<p><em>Confirmation</em> unifies the output type parameters of the trait with the
values found in the obligation, possibly yielding a type error.</p>
<p>Suppose we have the following variation of the <code>Convert</code> example in the
previous section:</p>
<pre><code class="language-rust ignore">trait Convert&lt;Target&gt; {
    fn convert(&amp;self) -&gt; Target;
}

impl Convert&lt;usize&gt; for isize { ... } // isize -&gt; usize
impl Convert&lt;isize&gt; for usize { ... } // usize -&gt; isize

let x: isize = ...;
let y: char = x.convert(); // NOTE: `y: char` now!
</code></pre>
<p>Confirmation is where an error would be reported because the impl specified
that <code>Target</code> would be <code>usize</code>, but the obligation reported <code>char</code>. Hence the
result of selection would be an error.</p>
<p>Note that the candidate impl is chosen based on the <code>Self</code> type, but
confirmation is done based on (in this case) the <code>Target</code> type parameter.</p>
<a class="header" href="print.html#selection-during-translation" id="selection-during-translation"><h3>Selection during translation</h3></a>
<p>As mentioned above, during type checking, we do not store the results of trait
selection. At trans time, we repeat the trait selection to choose a particular
impl for each method call. In this second selection, we do not consider any
where-clauses to be in scope because we know that each resolution will resolve
to a particular impl.</p>
<p>One interesting twist has to do with nested obligations. In general, in trans,
we only need to do a &quot;shallow&quot; selection for an obligation. That is, we wish to
identify which impl applies, but we do not (yet) need to decide how to select
any nested obligations. Nonetheless, we <em>do</em> currently do a complete resolution,
and that is because it can sometimes inform the results of type inference.
That is, we do not have the full substitutions in terms of the type variables
of the impl available to us, so we must run trait selection to figure
everything out.</p>
<p><strong>TODO</strong>: is this still talking about trans?</p>
<p>Here is an example:</p>
<pre><code class="language-rust ignore">trait Foo { ... }
impl&lt;U, T:Bar&lt;U&gt;&gt; Foo for Vec&lt;T&gt; { ... }

impl Bar&lt;usize&gt; for isize { ... }
</code></pre>
<p>After one shallow round of selection for an obligation like <code>Vec&lt;isize&gt; : Foo</code>, we would know which impl we want, and we would know that
<code>T=isize</code>, but we do not know the type of <code>U</code>.  We must select the
nested obligation <code>isize : Bar&lt;U&gt;</code> to find out that <code>U=usize</code>.</p>
<p>It would be good to only do <em>just as much</em> nested resolution as
necessary. Currently, though, we just do a full resolution.</p>
<a class="header" href="print.html#higher-ranked-trait-bounds" id="higher-ranked-trait-bounds"><h1>Higher-ranked trait bounds</h1></a>
<p>One of the more subtle concepts in trait resolution is <em>higher-ranked trait
bounds</em>. An example of such a bound is <code>for&lt;'a&gt; MyTrait&lt;&amp;'a isize&gt;</code>.
Let's walk through how selection on higher-ranked trait references
works.</p>
<a class="header" href="print.html#basic-matching-and-skolemization-leaks" id="basic-matching-and-skolemization-leaks"><h2>Basic matching and skolemization leaks</h2></a>
<p>Suppose we have a trait <code>Foo</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Foo&lt;X&gt; {
    fn foo(&amp;self, x: X) { }
}
#}</code></pre></pre>
<p>Let's say we have a function <code>want_hrtb</code> that wants a type which
implements <code>Foo&lt;&amp;'a isize&gt;</code> for any <code>'a</code>:</p>
<pre><code class="language-rust ignore">fn want_hrtb&lt;T&gt;() where T : for&lt;'a&gt; Foo&lt;&amp;'a isize&gt; { ... }
</code></pre>
<p>Now we have a struct <code>AnyInt</code> that implements <code>Foo&lt;&amp;'a isize&gt;</code> for any
<code>'a</code>:</p>
<pre><code class="language-rust ignore">struct AnyInt;
impl&lt;'a&gt; Foo&lt;&amp;'a isize&gt; for AnyInt { }
</code></pre>
<p>And the question is, does <code>AnyInt : for&lt;'a&gt; Foo&lt;&amp;'a isize&gt;</code>? We want the
answer to be yes. The algorithm for figuring it out is closely related
to the subtyping for higher-ranked types (which is described <a href="https://github.com/rust-lang/rust/tree/master/src/librustc/infer/higher_ranked/README.md">here</a>
and also in a <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/">paper by SPJ</a>. If you wish to understand higher-ranked
subtyping, we recommend you read the paper). There are a few parts:</p>
<p><strong>TODO</strong>: We should define <em>skolemize</em>.</p>
<ol>
<li><em>Skolemize</em> the obligation.</li>
<li>Match the impl against the skolemized obligation.</li>
<li>Check for <em>skolemization leaks</em>.</li>
</ol>
<p>So let's work through our example.</p>
<ol>
<li>
<p>The first thing we would do is to
skolemize the obligation, yielding <code>AnyInt : Foo&lt;&amp;'0 isize&gt;</code> (here <code>'0</code>
represents skolemized region #0). Note that we now have no quantifiers;
in terms of the compiler type, this changes from a <code>ty::PolyTraitRef</code>
to a <code>TraitRef</code>. We would then create the <code>TraitRef</code> from the impl,
using fresh variables for it's bound regions (and thus getting
<code>Foo&lt;&amp;'$a isize&gt;</code>, where <code>'$a</code> is the inference variable for <code>'a</code>).</p>
</li>
<li>
<p>Next
we relate the two trait refs, yielding a graph with the constraint
that <code>'0 == '$a</code>.</p>
</li>
<li>
<p>Finally, we check for skolemization &quot;leaks&quot; – a
leak is basically any attempt to relate a skolemized region to another
skolemized region, or to any region that pre-existed the impl match.
The leak check is done by searching from the skolemized region to find
the set of regions that it is related to in any way. This is called
the &quot;taint&quot; set. To pass the check, that set must consist <em>solely</em> of
itself and region variables from the impl. If the taint set includes
any other region, then the match is a failure. In this case, the taint
set for <code>'0</code> is <code>{'0, '$a}</code>, and hence the check will succeed.</p>
</li>
</ol>
<p>Let's consider a failure case. Imagine we also have a struct</p>
<pre><code class="language-rust ignore">struct StaticInt;
impl Foo&lt;&amp;'static isize&gt; for StaticInt;
</code></pre>
<p>We want the obligation <code>StaticInt : for&lt;'a&gt; Foo&lt;&amp;'a isize&gt;</code> to be
considered unsatisfied. The check begins just as before. <code>'a</code> is
skolemized to <code>'0</code> and the impl trait reference is instantiated to
<code>Foo&lt;&amp;'static isize&gt;</code>. When we relate those two, we get a constraint
like <code>'static == '0</code>. This means that the taint set for <code>'0</code> is <code>{'0, 'static}</code>, which fails the leak check.</p>
<p><strong>TODO</strong>: This is because <code>'static</code> is not a region variable but is in the
taint set, right?</p>
<a class="header" href="print.html#higher-ranked-trait-obligations" id="higher-ranked-trait-obligations"><h2>Higher-ranked trait obligations</h2></a>
<p>Once the basic matching is done, we get to another interesting topic:
how to deal with impl obligations. I'll work through a simple example
here. Imagine we have the traits <code>Foo</code> and <code>Bar</code> and an associated impl:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Foo&lt;X&gt; {
    fn foo(&amp;self, x: X) { }
}

trait Bar&lt;X&gt; {
    fn bar(&amp;self, x: X) { }
}

impl&lt;X,F&gt; Foo&lt;X&gt; for F
    where F : Bar&lt;X&gt;
{
}
#}</code></pre></pre>
<p>Now let's say we have a obligation <code>Baz: for&lt;'a&gt; Foo&lt;&amp;'a isize&gt;</code> and we match
this impl. What obligation is generated as a result? We want to get
<code>Baz: for&lt;'a&gt; Bar&lt;&amp;'a isize&gt;</code>, but how does that happen?</p>
<p>After the matching, we are in a position where we have a skolemized
substitution like <code>X =&gt; &amp;'0 isize</code>. If we apply this substitution to the
impl obligations, we get <code>F : Bar&lt;&amp;'0 isize&gt;</code>. Obviously this is not
directly usable because the skolemized region <code>'0</code> cannot leak out of
our computation.</p>
<p>What we do is to create an inverse mapping from the taint set of <code>'0</code>
back to the original bound region (<code>'a</code>, here) that <code>'0</code> resulted
from. (This is done in <code>higher_ranked::plug_leaks</code>). We know that the
leak check passed, so this taint set consists solely of the skolemized
region itself plus various intermediate region variables. We then walk
the trait-reference and convert every region in that taint set back to
a late-bound region, so in this case we'd wind up with
<code>Baz: for&lt;'a&gt; Bar&lt;&amp;'a isize&gt;</code>.</p>
<a class="header" href="print.html#caching-and-subtle-considerations-therewith" id="caching-and-subtle-considerations-therewith"><h1>Caching and subtle considerations therewith</h1></a>
<p>In general, we attempt to cache the results of trait selection.  This
is a somewhat complex process. Part of the reason for this is that we
want to be able to cache results even when all the types in the trait
reference are not fully known. In that case, it may happen that the
trait selection process is also influencing type variables, so we have
to be able to not only cache the <em>result</em> of the selection process,
but <em>replay</em> its effects on the type variables.</p>
<a class="header" href="print.html#an-example" id="an-example"><h2>An example</h2></a>
<p>The high-level idea of how the cache works is that we first replace
all unbound inference variables with skolemized versions. Therefore,
if we had a trait reference <code>usize : Foo&lt;$t&gt;</code>, where <code>$t</code> is an unbound
inference variable, we might replace it with <code>usize : Foo&lt;$0&gt;</code>, where
<code>$0</code> is a skolemized type. We would then look this up in the cache.</p>
<p>If we found a hit, the hit would tell us the immediate next step to
take in the selection process (e.g. apply impl #22, or apply where
clause <code>X : Foo&lt;Y&gt;</code>).</p>
<p>On the other hand, if there is no hit, we need to go through the <a href="./traits/resolution.html#selection">selection
process</a> from scratch. Suppose, we come to the conclusion that the only
possible impl is this one, with def-id 22:</p>
<pre><code class="language-rust ignore">impl Foo&lt;isize&gt; for usize { ... } // Impl #22
</code></pre>
<p>We would then record in the cache <code>usize : Foo&lt;$0&gt; =&gt; ImplCandidate(22)</code>. Next
we would <a href="./traits/resolution.html#confirmation">confirm</a> <code>ImplCandidate(22)</code>, which would (as a side-effect) unify
<code>$t</code> with <code>isize</code>.</p>
<p>Now, at some later time, we might come along and see a <code>usize : Foo&lt;$u&gt;</code>. When skolemized, this would yield <code>usize : Foo&lt;$0&gt;</code>, just as
before, and hence the cache lookup would succeed, yielding
<code>ImplCandidate(22)</code>. We would confirm <code>ImplCandidate(22)</code> which would
(as a side-effect) unify <code>$u</code> with <code>isize</code>.</p>
<a class="header" href="print.html#where-clauses-and-the-local-vs-global-cache" id="where-clauses-and-the-local-vs-global-cache"><h2>Where clauses and the local vs global cache</h2></a>
<p>One subtle interaction is that the results of trait lookup will vary
depending on what where clauses are in scope. Therefore, we actually
have <em>two</em> caches, a local and a global cache. The local cache is
attached to the <a href="./param_env.html"><code>ParamEnv</code></a>, and the global cache attached to the
<a href="./ty.html"><code>tcx</code></a>. We use the local cache whenever the result might depend on the
where clauses that are in scope. The determination of which cache to
use is done by the method <code>pick_candidate_cache</code> in <code>select.rs</code>. At
the moment, we use a very simple, conservative rule: if there are any
where-clauses in scope, then we use the local cache.  We used to try
and draw finer-grained distinctions, but that led to a serious of
annoying and weird bugs like <a href="https://github.com/rust-lang/rust/issues/22019">#22019</a> and <a href="https://github.com/rust-lang/rust/issues/18290">#18290</a>. This simple rule seems
to be pretty clearly safe and also still retains a very high hit rate
(~95% when compiling rustc).</p>
<p><strong>TODO</strong>: it looks like <code>pick_candidate_cache</code> no longer exists. In
general, is this section still accurate at all?</p>
<a class="header" href="print.html#specialization" id="specialization"><h1>Specialization</h1></a>
<p><strong>TODO</strong>: where does Chalk fit in? Should we mention/discuss it here?</p>
<p>Defined in the <code>specialize</code> module.</p>
<p>The basic strategy is to build up a <em>specialization graph</em> during
coherence checking (recall that coherence checking looks for overlapping
impls). Insertion into the graph locates the right place
to put an impl in the specialization hierarchy; if there is no right
place (due to partial overlap but no containment), you get an overlap
error. Specialization is consulted when selecting an impl (of course),
and the graph is consulted when propagating defaults down the
specialization hierarchy.</p>
<p>You might expect that the specialization graph would be used during
selection – i.e. when actually performing specialization. This is
not done for two reasons:</p>
<ul>
<li>
<p>It's merely an optimization: given a set of candidates that apply,
we can determine the most specialized one by comparing them directly
for specialization, rather than consulting the graph. Given that we
also cache the results of selection, the benefit of this
optimization is questionable.</p>
</li>
<li>
<p>To build the specialization graph in the first place, we need to use
selection (because we need to determine whether one impl specializes
another). Dealing with this reentrancy would require some additional
mode switch for selection. Given that there seems to be no strong
reason to use the graph anyway, we stick with a simpler approach in
selection, and use the graph only for propagating default
implementations.</p>
</li>
</ul>
<p>Trait impl selection can succeed even when multiple impls can apply,
as long as they are part of the same specialization family. In that
case, it returns a <em>single</em> impl on success – this is the most
specialized impl <em>known</em> to apply. However, if there are any inference
variables in play, the returned impl may not be the actual impl we
will use at trans time. Thus, we take special care to avoid projecting
associated types unless either (1) the associated type does not use
<code>default</code> and thus cannot be overridden or (2) all input types are
known concretely.</p>
<a class="header" href="print.html#trait-solving-new-style" id="trait-solving-new-style"><h1>Trait solving (new-style)</h1></a>
<p>🚧 This chapter describes &quot;new-style&quot; trait solving. This is still in the
<a href="https://github.com/rust-lang/rust/issues/48416">process of being implemented</a>; this chapter serves as a kind of
in-progress design document. If you would prefer to read about how the
current trait solver works, check out
<a href="./traits/resolution.html">this other chapter</a>. (By the way, if you
would like to help in hacking on the new solver, you will find
instructions for getting involved in the
<a href="https://github.com/rust-lang/rust/issues/48416">Traits Working Group tracking issue</a>.) 🚧</p>
<p>Trait solving is based around a few key ideas:</p>
<ul>
<li><a href="./traits/lowering-to-logic.html">Lowering to logic</a>, which expresses
Rust traits in terms of standard logical terms.
<ul>
<li>The <a href="./traits/goals-and-clauses.html">goals and clauses</a> chapter
describes the precise form of rules we use, and
<a href="./traits/lowering-rules.html">lowering rules</a> gives the complete set of
lowering rules in a more reference-like form.</li>
</ul>
</li>
<li><a href="./traits/canonical-queries.html">Canonical queries</a>, which allow us
to solve trait problems (like &quot;is <code>Foo</code> implemented for the type
<code>Bar</code>?&quot;) once, and then apply that same result independently in many
different inference contexts.</li>
<li><a href="./traits/associated-types.html">Lazy normalization</a>, which is the
technique we use to accommodate associated types when figuring out
whether types are equal.</li>
<li><a href="./traits/regions.html">Region constraints</a>, which are accumulated
during trait solving but mostly ignored. This means that trait
solving effectively ignores the precise regions involved, always --
but we still remember the constraints on them so that those
constraints can be checked by thet type checker.</li>
</ul>
<p>Note: this is not a complete list of topics. See the sidebar for more.</p>
<a class="header" href="print.html#lowering-to-logic" id="lowering-to-logic"><h1>Lowering to logic</h1></a>
<p>The key observation here is that the Rust trait system is basically a
kind of logic, and it can be mapped onto standard logical inference
rules. We can then look for solutions to those inference rules in a
very similar fashion to how e.g. a <a href="https://en.wikipedia.org/wiki/Prolog">Prolog</a> solver works. It turns out
that we can't <em>quite</em> use Prolog rules (also called Horn clauses) but
rather need a somewhat more expressive variant.</p>
<a class="header" href="print.html#rust-traits-and-logic" id="rust-traits-and-logic"><h2>Rust traits and logic</h2></a>
<p>One of the first observations is that the Rust trait system is
basically a kind of logic. As such, we can map our struct, trait, and
impl declarations into logical inference rules. For the most part,
these are basically Horn clauses, though we'll see that to capture the
full richness of Rust -- and in particular to support generic
programming -- we have to go a bit further than standard Horn clauses.</p>
<p>To see how this mapping works, let's start with an example. Imagine
we declare a trait and a few impls, like so:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Clone { }
impl Clone for usize { }
impl&lt;T&gt; Clone for Vec&lt;T&gt; where T: Clone { }
#}</code></pre></pre>
<p>We could map these declarations to some Horn clauses, written in a
Prolog-like notation, as follows:</p>
<pre><code class="language-text">Clone(usize).
Clone(Vec&lt;?T&gt;) :- Clone(?T).

// The notation `A :- B` means &quot;A is true if B is true&quot;.
// Or, put another way, B implies A.
</code></pre>
<p>In Prolog terms, we might say that <code>Clone(Foo)</code> -- where <code>Foo</code> is some
Rust type -- is a <em>predicate</em> that represents the idea that the type
<code>Foo</code> implements <code>Clone</code>. These rules are <strong>program clauses</strong>; they
state the conditions under which that predicate can be proven (i.e.,
considered true). So the first rule just says &quot;Clone is implemented
for <code>usize</code>&quot;. The next rule says &quot;for any type <code>?T</code>, Clone is
implemented for <code>Vec&lt;?T&gt;</code> if clone is implemented for <code>?T</code>&quot;. So
e.g. if we wanted to prove that <code>Clone(Vec&lt;Vec&lt;usize&gt;&gt;)</code>, we would do
so by applying the rules recursively:</p>
<ul>
<li><code>Clone(Vec&lt;Vec&lt;usize&gt;&gt;)</code> is provable if:
<ul>
<li><code>Clone(Vec&lt;usize&gt;)</code> is provable if:
<ul>
<li><code>Clone(usize)</code> is provable. (Which is is, so we're all good.)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>But now suppose we tried to prove that <code>Clone(Vec&lt;Bar&gt;)</code>. This would
fail (after all, I didn't give an impl of <code>Clone</code> for <code>Bar</code>):</p>
<ul>
<li><code>Clone(Vec&lt;Bar&gt;)</code> is provable if:
<ul>
<li><code>Clone(Bar)</code> is provable. (But it is not, as there are no applicable rules.)</li>
</ul>
</li>
</ul>
<p>We can easily extend the example above to cover generic traits with
more than one input type. So imagine the <code>Eq&lt;T&gt;</code> trait, which declares
that <code>Self</code> is equatable with a value of type <code>T</code>:</p>
<pre><code class="language-rust ignore">trait Eq&lt;T&gt; { ... }
impl Eq&lt;usize&gt; for usize { }
impl&lt;T: Eq&lt;U&gt;&gt; Eq&lt;Vec&lt;U&gt;&gt; for Vec&lt;T&gt; { }
</code></pre>
<p>That could be mapped as follows:</p>
<pre><code class="language-text">Eq(usize, usize).
Eq(Vec&lt;?T&gt;, Vec&lt;?U&gt;) :- Eq(?T, ?U).
</code></pre>
<p>So far so good.</p>
<a class="header" href="print.html#type-checking-normal-functions" id="type-checking-normal-functions"><h2>Type-checking normal functions</h2></a>
<p>OK, now that we have defined some logical rules that are able to
express when traits are implemented and to handle associated types,
let's turn our focus a bit towards <strong>type-checking</strong>. Type-checking is
interesting because it is what gives us the goals that we need to
prove. That is, everything we've seen so far has been about how we
derive the rules by which we can prove goals from the traits and impls
in the program; but we are also interested in how to derive the goals
that we need to prove, and those come from type-checking.</p>
<p>Consider type-checking the function <code>foo()</code> here:</p>
<pre><code class="language-rust ignore">fn foo() { bar::&lt;usize&gt;() }
fn bar&lt;U: Eq&lt;U&gt;&gt;() { }
</code></pre>
<p>This function is very simple, of course: all it does is to call
<code>bar::&lt;usize&gt;()</code>. Now, looking at the definition of <code>bar()</code>, we can see
that it has one where-clause <code>U: Eq&lt;U&gt;</code>. So, that means that <code>foo()</code> will
have to prove that <code>usize: Eq&lt;usize&gt;</code> in order to show that it can call <code>bar()</code>
with <code>usize</code> as the type argument.</p>
<p>If we wanted, we could write a Prolog predicate that defines the
conditions under which <code>bar()</code> can be called. We'll say that those
conditions are called being &quot;well-formed&quot;:</p>
<pre><code class="language-text">barWellFormed(?U) :- Eq(?U, ?U).
</code></pre>
<p>Then we can say that <code>foo()</code> type-checks if the reference to
<code>bar::&lt;usize&gt;</code> (that is, <code>bar()</code> applied to the type <code>usize</code>) is
well-formed:</p>
<pre><code class="language-text">fooTypeChecks :- barWellFormed(usize).
</code></pre>
<p>If we try to prove the goal <code>fooTypeChecks</code>, it will succeed:</p>
<ul>
<li><code>fooTypeChecks</code> is provable if:
<ul>
<li><code>barWellFormed(usize)</code>, which is provable if:
<ul>
<li><code>Eq(usize, usize)</code>, which is provable because of an impl.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Ok, so far so good. Let's move on to type-checking a more complex function.</p>
<a class="header" href="print.html#type-checking-generic-functions-beyond-horn-clauses" id="type-checking-generic-functions-beyond-horn-clauses"><h2>Type-checking generic functions: beyond Horn clauses</h2></a>
<p>In the last section, we used standard Prolog horn-clauses (augmented with Rust's
notion of type equality) to type-check some simple Rust functions. But that only
works when we are type-checking non-generic functions. If we want to type-check
a generic function, it turns out we need a stronger notion of goal than Prolog
can be provide. To see what I'm talking about, let's revamp our previous
example to make <code>foo</code> generic:</p>
<pre><code class="language-rust ignore">fn foo&lt;T: Eq&lt;T&gt;&gt;() { bar::&lt;T&gt;() }
fn bar&lt;U: Eq&lt;U&gt;&gt;() { }
</code></pre>
<p>To type-check the body of <code>foo</code>, we need to be able to hold the type
<code>T</code> &quot;abstract&quot;.  That is, we need to check that the body of <code>foo</code> is
type-safe <em>for all types <code>T</code></em>, not just for some specific type. We might express
this like so:</p>
<pre><code class="language-text">fooTypeChecks :-
  // for all types T...
  forall&lt;T&gt; {
    // ...if we assume that Eq(T, T) is provable...
    if (Eq(T, T)) {
      // ...then we can prove that `barWellFormed(T)` holds.
      barWellFormed(T)
    }
  }.
</code></pre>
<p>This notation I'm using here is the notation I've been using in my
prototype implementation; it's similar to standard mathematical
notation but a bit Rustified. Anyway, the problem is that standard
Horn clauses don't allow universal quantification (<code>forall</code>) or
implication (<code>if</code>) in goals (though many Prolog engines do support
them, as an extension). For this reason, we need to accept something
called &quot;first-order hereditary harrop&quot; (FOHH) clauses -- this long
name basically means &quot;standard Horn clauses with <code>forall</code> and <code>if</code> in
the body&quot;. But it's nice to know the proper name, because there is a
lot of work describing how to efficiently handle FOHH clauses; see for
example Gopalan Nadathur's excellent
<a href="./traits/bibliography.html#pphhf">&quot;A Proof Procedure for the Logic of Hereditary Harrop Formulas&quot;</a>
in <a href="./traits/bibliography.html">the bibliography</a>.</p>
<p>It turns out that supporting FOHH is not really all that hard. And
once we are able to do that, we can easily describe the type-checking
rule for generic functions like <code>foo</code> in our logic.</p>
<a class="header" href="print.html#source" id="source"><h2>Source</h2></a>
<p>This page is a lightly adapted version of a
<a href="http://smallcultfollowing.com/babysteps/blog/2017/01/26/lowering-rust-traits-to-logic/">blog post by Nicholas Matsakis</a>.</p>
<a class="header" href="print.html#goals-and-clauses" id="goals-and-clauses"><h1>Goals and clauses</h1></a>
<p>In logic programming terms, a <strong>goal</strong> is something that you must
prove and a <strong>clause</strong> is something that you know is true. As
described in the <a href="./traits/lowering-to-logic.html">lowering to logic</a>
chapter, Rust's trait solver is based on an extension of hereditary
harrop (HH) clauses, which extend traditional Prolog Horn clauses with
a few new superpowers.</p>
<a class="header" href="print.html#goals-and-clauses-meta-structure" id="goals-and-clauses-meta-structure"><h2>Goals and clauses meta structure</h2></a>
<p>In Rust's solver, <strong>goals</strong> and <strong>clauses</strong> have the following forms
(note that the two definitions reference one another):</p>
<pre><code class="language-text">Goal = DomainGoal           // defined in the section below
        | Goal &amp;&amp; Goal
        | Goal || Goal
        | exists&lt;K&gt; { Goal }   // existential quantification
        | forall&lt;K&gt; { Goal }   // universal quantification
        | if (Clause) { Goal } // implication
        | true                 // something that's trivially true
        | ambiguous            // something that's never provable

Clause = DomainGoal
        | Clause :- Goal     // if can prove Goal, then Clause is true
        | Clause &amp;&amp; Clause
        | forall&lt;K&gt; { Clause }

K = &lt;type&gt;     // a &quot;kind&quot;
    | &lt;lifetime&gt;
</code></pre>
<p>The proof procedure for these sorts of goals is actually quite
straightforward.  Essentially, it's a form of depth-first search. The
paper
<a href="./traits/bibliography.html#pphhf">&quot;A Proof Procedure for the Logic of Hereditary Harrop Formulas&quot;</a>
gives the details.</p>
<p><a name="domain-goals"></a></p>
<a class="header" href="print.html#domain-goals" id="domain-goals"><h2>Domain goals</h2></a>
<p><a name="trait-ref"></a></p>
<p>To define the set of <em>domain goals</em> in our system, we need to first
introduce a few simple formulations. A <strong>trait reference</strong> consists of
the name of a trait along with a suitable set of inputs P0..Pn:</p>
<pre><code class="language-text">TraitRef = P0: TraitName&lt;P1..Pn&gt;
</code></pre>
<p>So, for example, <code>u32: Display</code> is a trait reference, as is <code>Vec&lt;T&gt;: IntoIterator</code>. Note that Rust surface syntax also permits some extra
things, like associated type bindings (<code>Vec&lt;T&gt;: IntoIterator&lt;Item = T&gt;</code>), that are not part of a trait reference.</p>
<p><a name="projection"></a></p>
<p>A <strong>projection</strong> consists of an associated item reference along with
its inputs P0..Pm:</p>
<pre><code class="language-text">Projection = &lt;P0 as TraitName&lt;P1..Pn&gt;&gt;::AssocItem&lt;Pn+1..Pm&gt;
</code></pre>
<p>Given these, we can define a <code>DomainGoal</code> as follows:</p>
<pre><code class="language-text">DomainGoal = Implemented(TraitRef)
            | ProjectionEq(Projection = Type)
            | Normalize(Projection -&gt; Type)
            | FromEnv(TraitRef)
            | FromEnv(Projection = Type)
            | WellFormed(Type)
            | WellFormed(TraitRef)
            | WellFormed(Projection = Type)
            | Outlives(Type: Region)
            | Outlives(Region: Region)
</code></pre>
<p>Let's break down each one of these, one-by-one.</p>
<a class="header" href="print.html#implementedtraitref" id="implementedtraitref"><h4>Implemented(TraitRef)</h4></a>
<p>e.g. <code>Implemented(i32: Copy)</code></p>
<p>True if the given trait is implemented for the given input types and lifetimes.</p>
<a class="header" href="print.html#projectioneqprojection--type" id="projectioneqprojection--type"><h4>ProjectionEq(Projection = Type)</h4></a>
<p>e.g. <code>ProjectionEq&lt;T as Iterator&gt;::Item = u8</code></p>
<p>The given associated type <code>Projection</code> is equal to <code>Type</code>; this can be proved
with either normalization or using skolemized types. See <a href="./traits/associated-types.html">the section
on associated types</a>.</p>
<a class="header" href="print.html#normalizeprojection---type" id="normalizeprojection---type"><h4>Normalize(Projection -&gt; Type)</h4></a>
<p>e.g. <code>ProjectionEq&lt;T as Iterator&gt;::Item -&gt; u8</code></p>
<p>The given associated type <code>Projection</code> can be <a href="./traits/associated-types.html#normalize">normalized</a> to <code>Type</code>.</p>
<p>As discussed in <a href="./traits/associated-types.html">the section on associated
types</a>, <code>Normalize</code> implies <code>ProjectionEq</code>,
but not vice versa. In general, proving <code>Normalize(&lt;T as Trait&gt;::Item -&gt; U)</code>
also requires proving <code>Implemented(T: Trait)</code>.</p>
<a class="header" href="print.html#fromenvtraitref-fromenvprojection--type" id="fromenvtraitref-fromenvprojection--type"><h4>FromEnv(TraitRef), FromEnv(Projection = Type)</h4></a>
<p>e.g. <code>FromEnv(Self: Add&lt;i32&gt;)</code></p>
<p>e.g. <code>FromEnv(&lt;Self as StreamingIterator&gt;::Item&lt;'a&gt; = &amp;'a [u8])</code></p>
<p>True if the inner <code>TraitRef</code> or projection equality is <em>assumed</em> to be true;
that is, if it can be derived from the in-scope where clauses.</p>
<p>For example, given the following function:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn loud_clone&lt;T: Clone&gt;(stuff: &amp;T) -&gt; T {
    println!(&quot;cloning!&quot;);
    stuff.clone()
}
#}</code></pre></pre>
<p>Inside the body of our function, we would have <code>FromEnv(T: Clone)</code>. In-scope
where clauses nest, so a function body inside an impl body inherits the
impl body's where clauses, too.</p>
<p>This and the next rule are used to implement <a href="./traits/lowering-rules.html#implied-bounds">implied bounds</a>. As we'll see
in the section on lowering, <code>FromEnv(X)</code> implies <code>Implemented(X)</code>, but not
vice versa. This distinction is crucial to implied bounds.</p>
<a class="header" href="print.html#wellformeditem" id="wellformeditem"><h4>WellFormed(Item)</h4></a>
<p>These goals imply that the given item is <em>well-formed</em>.</p>
<p>We can talk about different types of items being well-formed:</p>
<p><strong>Types</strong>, like <code>WellFormed(Vec&lt;i32&gt;)</code>, which is true in Rust, or
<code>WellFormed(Vec&lt;str&gt;)</code>, which is not (because <code>str</code> is not <code>Sized</code>.)</p>
<p><strong>TraitRefs</strong>, like <code>WellFormed(Vec&lt;i32&gt;: Clone)</code>.</p>
<p><strong>Projections</strong>, like <code>WellFormed(T: Iterator&lt;Item = u32&gt;)</code>.</p>
<p>Well-formedness is important to <a href="./traits/lowering-rules.html#implied-bounds">implied bounds</a>. In particular, the reason
it is okay to assume <code>FromEnv(T: Clone)</code> in the example above is that we
<em>also</em> verify <code>WellFormed(T: Clone)</code> for each call site of <code>loud_clone</code>.</p>
<a class="header" href="print.html#outlivestype-region-outlivesregion-region" id="outlivestype-region-outlivesregion-region"><h4>Outlives(Type: Region), Outlives(Region: Region)</h4></a>
<p>e.g. <code>Outlives(&amp;'a str: 'b)</code>, <code>Outlives('a: 'static)</code></p>
<p>True if the given type or region on the left outlives the right-hand region.</p>
<p><a name="coinductive"></a></p>
<a class="header" href="print.html#coinductive-goals" id="coinductive-goals"><h2>Coinductive goals</h2></a>
<p>Most goals in our system are &quot;inductive&quot;. In an inductive goal,
circular reasoning is disallowed. Consider this example clause:</p>
<pre><code class="language-text">    Implemented(Foo: Bar) :-
        Implemented(Foo: Bar).
</code></pre>
<p>Considered inductively, this clause is useless: if we are trying to
prove <code>Implemented(Foo: Bar)</code>, we would then recursively have to prove
<code>Implemented(Foo: Bar)</code>, and that cycle would continue ad infinitum
(the trait solver will terminate here, it would just consider that
<code>Implemented(Foo: Bar)</code> is not known to be true).</p>
<p>However, some goals are <em>co-inductive</em>. Simply put, this means that
cycles are OK. So, if <code>Bar</code> were a co-inductive trait, then the rule
above would be perfectly valid, and it would indicate that
<code>Implemented(Foo: Bar)</code> is true.</p>
<p><em>Auto traits</em> are one example in Rust where co-inductive goals are used.
Consider the <code>Send</code> trait, and imagine that we have this struct:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Foo {
    next: Option&lt;Box&lt;Foo&gt;&gt;
}
#}</code></pre></pre>
<p>The default rules for auto traits say that <code>Foo</code> is <code>Send</code> if the
types of its fields are <code>Send</code>. Therefore, we would have a rule like</p>
<pre><code class="language-text">Implemented(Foo: Send) :-
    Implemented(Option&lt;Box&lt;Foo&gt;&gt;: Send).
</code></pre>
<p>As you can probably imagine, proving that <code>Option&lt;Box&lt;Foo&gt;&gt;: Send</code> is
going to wind up circularly requiring us to prove that <code>Foo: Send</code>
again. So this would be an example where we wind up in a cycle -- but
that's ok, we <em>do</em> consider <code>Foo: Send</code> to hold, even though it
references itself.</p>
<p>In general, co-inductive traits are used in Rust trait solving when we
want to enumerate a fixed set of possibilities. In the case of auto
traits, we are enumerating the set of reachable types from a given
starting point (i.e., <code>Foo</code> can reach values of type
<code>Option&lt;Box&lt;Foo&gt;&gt;</code>, which implies it can reach values of type
<code>Box&lt;Foo&gt;</code>, and then of type <code>Foo</code>, and then the cycle is complete).</p>
<p>In addition to auto traits, <code>WellFormed</code> predicates are co-inductive.
These are used to achieve a similar &quot;enumerate all the cases&quot; pattern,
as described in the section on <a href="./traits/lowering-rules.html#implied-bounds">implied bounds</a>.</p>
<a class="header" href="print.html#incomplete-chapter" id="incomplete-chapter"><h2>Incomplete chapter</h2></a>
<p>Some topics yet to be written:</p>
<ul>
<li>Elaborate on the proof procedure</li>
<li>SLG solving -- introduce negative reasoning</li>
</ul>
<a class="header" href="print.html#equality-and-associated-types" id="equality-and-associated-types"><h1>Equality and associated types</h1></a>
<p>This section covers how the trait system handles equality between
associated types. The full system consists of several moving parts,
which we will introduce one by one:</p>
<ul>
<li>Projection and the <code>Normalize</code> predicate</li>
<li>Skolemization</li>
<li>The <code>ProjectionEq</code> predicate</li>
<li>Integration with unification</li>
</ul>
<a class="header" href="print.html#associated-type-projection-and-normalization" id="associated-type-projection-and-normalization"><h2>Associated type projection and normalization</h2></a>
<p>When a trait defines an associated type (e.g.,
<a href="https://doc.rust-lang.org/nightly/core/iter/trait.IntoIterator.html#associatedtype.Item">the <code>Item</code> type in the <code>IntoIterator</code> trait</a>), that
type can be referenced by the user using an <strong>associated type
projection</strong> like <code>&lt;Option&lt;u32&gt; as IntoIterator&gt;::Item</code>. (Often,
though, people will use the shorthand syntax <code>T::Item</code> -- presently,
that syntax is expanded during
<a href="./type-checking.html">&quot;type collection&quot;</a> into the explicit form,
though that is something we may want to change in the future.)</p>
<p><a name="normalize"></a></p>
<p>In some cases, associated type projections can be <strong>normalized</strong> --
that is, simplified -- based on the types given in an impl. So, to
continue with our example, the impl of <code>IntoIterator</code> for <code>Option&lt;T&gt;</code>
declares (among other things) that <code>Item = T</code>:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; IntoIterator for Option&lt;T&gt; {
  type Item = T;
  ...
}
</code></pre>
<p>This means we can normalize the projection <code>&lt;Option&lt;u32&gt; as IntoIterator&gt;::Item</code> to just <code>u32</code>.</p>
<p>In this case, the projection was a &quot;monomorphic&quot; one -- that is, it
did not have any type parameters.  Monomorphic projections are special
because they can <strong>always</strong> be fully normalized -- but often we can
normalize other associated type projections as well. For example,
<code>&lt;Option&lt;?T&gt; as IntoIterator&gt;::Item</code> (where <code>?T</code> is an inference
variable) can be normalized to just <code>?T</code>.</p>
<p>In our logic, normalization is defined by a predicate
<code>Normalize</code>. The <code>Normalize</code> clauses arise only from
impls. For example, the <code>impl</code> of <code>IntoIterator</code> for <code>Option&lt;T&gt;</code> that
we saw above would be lowered to a program clause like so:</p>
<pre><code class="language-text">forall&lt;T&gt; {
    Normalize(&lt;Option&lt;T&gt; as IntoIterator&gt;::Item -&gt; T) :-
        Implemented(Option&lt;T&gt;: IntoIterator)
}
</code></pre>
<p>where in this case, the one <code>Implemented</code> condition is always true.</p>
<p>(An aside: since we do not permit quantification over traits, this is
really more like a family of program clauses, one for each associated
type.)</p>
<p>We could apply that rule to normalize either of the examples that
we've seen so far.</p>
<a class="header" href="print.html#skolemized-associated-types" id="skolemized-associated-types"><h2>Skolemized associated types</h2></a>
<p>Sometimes however we want to work with associated types that cannot be
normalized. For example, consider this function:</p>
<pre><code class="language-rust ignore">fn foo&lt;T: IntoIterator&gt;(...) { ... }
</code></pre>
<p>In this context, how would we normalize the type <code>T::Item</code>? Without
knowing what <code>T</code> is, we can't really do so. To represent this case, we
introduce a type called a <strong>skolemized associated type
projection</strong>. This is written like so <code>(IntoIterator::Item)&lt;T&gt;</code>. You
may note that it looks a lot like a regular type (e.g., <code>Option&lt;T&gt;</code>),
except that the &quot;name&quot; of the type is <code>(IntoIterator::Item)</code>. This is
not an accident: skolemized associated type projections work just like
ordinary types like <code>Vec&lt;T&gt;</code> when it comes to unification. That is,
they are only considered equal if (a) they are both references to the
same associated type, like <code>IntoIterator::Item</code> and (b) their type
arguments are equal.</p>
<p>Skolemized associated types are never written directly by the user.
They are used internally by the trait system only, as we will see
shortly.</p>
<a class="header" href="print.html#projection-equality" id="projection-equality"><h2>Projection equality</h2></a>
<p>So far we have seen two ways to answer the question of &quot;When can we
consider an associated type projection equal to another type?&quot;:</p>
<ul>
<li>the <code>Normalize</code> predicate could be used to transform associated type
projections when we knew which impl was applicable;</li>
<li><strong>skolemized</strong> associated types can be used when we don't.</li>
</ul>
<p>We now introduce the <code>ProjectionEq</code> predicate to bring those two cases
together. The <code>ProjectionEq</code> predicate looks like so:</p>
<pre><code class="language-text">ProjectionEq(&lt;T as IntoIterator&gt;::Item = U)
</code></pre>
<p>and we will see that it can be proven <em>either</em> via normalization or
skolemization. As part of lowering an associated type declaration from
some trait, we create two program clauses for <code>ProjectionEq</code>:</p>
<pre><code class="language-text">forall&lt;T, U&gt; {
    ProjectionEq(&lt;T as IntoIterator&gt;::Item = U) :-
        Normalize(&lt;T as IntoIterator&gt;::Item -&gt; U)
}

forall&lt;T&gt; {
    ProjectionEq(&lt;T as IntoIterator&gt;::Item = (IntoIterator::Item)&lt;T&gt;)
}
</code></pre>
<p>These are the only two <code>ProjectionEq</code> program clauses we ever make for
any given associated item.</p>
<a class="header" href="print.html#integration-with-unification" id="integration-with-unification"><h2>Integration with unification</h2></a>
<p>Now we are ready to discuss how associated type equality integrates
with unification. As described in the
<a href="./type-inference.html">type inference</a> section, unification is
basically a procedure with a signature like this:</p>
<pre><code class="language-text">Unify(A, B) = Result&lt;(Subgoals, RegionConstraints), NoSolution&gt;
</code></pre>
<p>In other words, we try to unify two things A and B. That procedure
might just fail, in which case we get back <code>Err(NoSolution)</code>. This
would happen, for example, if we tried to unify <code>u32</code> and <code>i32</code>.</p>
<p>The key point is that, on success, unification can also give back to
us a set of subgoals that still remain to be proven (it can also give
back region constraints, but those are not relevant here).</p>
<p>Whenever unification encounters an (unskolemized!) associated type
projection P being equated with some other type T, it always succeeds,
but it produces a subgoal <code>ProjectionEq(P = T)</code> that is propagated
back up. Thus it falls to the ordinary workings of the trait system
to process that constraint.</p>
<p>(If we unify two projections P1 and P2, then unification produces a
variable X and asks us to prove that <code>ProjectionEq(P1 = X)</code> and
<code>ProjectionEq(P2 = X)</code>. That used to be needed in an older system to
prevent cycles; I rather doubt it still is. -nmatsakis)</p>
<a class="header" href="print.html#implied-bounds" id="implied-bounds"><h1>Implied Bounds</h1></a>
<p><em>to be written</em></p>
<p>Cover:</p>
<ul>
<li>Why the <code>FromEnv</code> setup etc is the way it is</li>
<li>Perhaps move some of the material from 'lowering rules' in to here</li>
<li>Show various examples where you could go wrong</li>
</ul>
<a class="header" href="print.html#region-constraints-1" id="region-constraints-1"><h1>Region constraints</h1></a>
<p><em>to be written</em></p>
<a class="header" href="print.html#canonical-queries" id="canonical-queries"><h1>Canonical queries</h1></a>
<p>The &quot;start&quot; of the trait system is the <strong>canonical query</strong> (these are
both queries in the more general sense of the word -- something you
would like to know the answer to -- and in the
<a href="./query.html">rustc-specific sense</a>).  The idea is that the type
checker or other parts of the system, may in the course of doing their
thing want to know whether some trait is implemented for some type
(e.g., is <code>u32: Debug</code> true?). Or they may want to
<a href="./traits/associated-types.html">normalize some associated type</a>.</p>
<p>This section covers queries at a fairly high level of abstraction. The
subsections look a bit more closely at how these ideas are implemented
in rustc.</p>
<a class="header" href="print.html#the-traditional-interactive-prolog-query" id="the-traditional-interactive-prolog-query"><h2>The traditional, interactive Prolog query</h2></a>
<p>In a traditional Prolog system, when you start a query, the solver
will run off and start supplying you with every possible answer it can
find. So given something like this:</p>
<pre><code class="language-text">?- Vec&lt;i32&gt;: AsRef&lt;?U&gt;
</code></pre>
<p>The solver might answer:</p>
<pre><code class="language-text">Vec&lt;i32&gt;: AsRef&lt;[i32]&gt;
    continue? (y/n)
</code></pre>
<p>This <code>continue</code> bit is interesting. The idea in Prolog is that the
solver is finding <strong>all possible</strong> instantiations of your query that
are true. In this case, if we instantiate <code>?U = [i32]</code>, then the query
is true (note that a traditional Prolog interface does not, directly,
tell us a value for <code>?U</code>, but we can infer one by unifying the
response with our original query -- Rust's solver gives back a
substitution instead). If we were to hit <code>y</code>, the solver might then
give us another possible answer:</p>
<pre><code class="language-text">Vec&lt;i32&gt;: AsRef&lt;Vec&lt;i32&gt;&gt;
    continue? (y/n)
</code></pre>
<p>This answer derives from the fact that there is a reflexive impl
(<code>impl&lt;T&gt; AsRef&lt;T&gt; for T</code>) for <code>AsRef</code>. If were to hit <code>y</code> again,
then we might get back a negative response:</p>
<pre><code class="language-text">no
</code></pre>
<p>Naturally, in some cases, there may be no possible answers, and hence
the solver will just give me back <code>no</code> right away:</p>
<pre><code class="language-text">?- Box&lt;i32&gt;: Copy
    no
</code></pre>
<p>In some cases, there might be an infinite number of responses. So for
example if I gave this query, and I kept hitting <code>y</code>, then the solver
would never stop giving me back answers:</p>
<pre><code class="language-text">?- Vec&lt;?U&gt;: Clone
    Vec&lt;i32&gt;: Clone
        continue? (y/n)
    Vec&lt;Box&lt;i32&gt;&gt;: Clone
        continue? (y/n)
    Vec&lt;Box&lt;Box&lt;i32&gt;&gt;&gt;: Clone
        continue? (y/n)
    Vec&lt;Box&lt;Box&lt;Box&lt;i32&gt;&gt;&gt;&gt;: Clone
        continue? (y/n)
</code></pre>
<p>As you can imagine, the solver will gleefully keep adding another
layer of <code>Box</code> until we ask it to stop, or it runs out of memory.</p>
<p>Another interesting thing is that queries might still have variables
in them. For example:</p>
<pre><code class="language-text">?- Rc&lt;?T&gt;: Clone
</code></pre>
<p>might produce the answer:</p>
<pre><code class="language-text">Rc&lt;?T&gt;: Clone
    continue? (y/n)
</code></pre>
<p>After all, <code>Rc&lt;?T&gt;</code> is true <strong>no matter what type <code>?T</code> is</strong>.</p>
<p><a name="query-response"></a></p>
<a class="header" href="print.html#a-trait-query-in-rustc" id="a-trait-query-in-rustc"><h2>A trait query in rustc</h2></a>
<p>The trait queries in rustc work somewhat differently. Instead of
trying to enumerate <strong>all possible</strong> answers for you, they are looking
for an <strong>unambiguous</strong> answer. In particular, when they tell you the
value for a type variable, that means that this is the <strong>only possible
instantiation</strong> that you could use, given the current set of impls and
where-clauses, that would be provable. (Internally within the solver,
though, they can potentially enumerate all possible answers. See
<a href="./traits/slg.html">the description of the SLG solver</a> for details.)</p>
<p>The response to a trait query in rustc is typically a
<code>Result&lt;QueryResult&lt;T&gt;, NoSolution&gt;</code> (where the <code>T</code> will vary a bit
depending on the query itself). The <code>Err(NoSolution)</code> case indicates
that the query was false and had no answers (e.g., <code>Box&lt;i32&gt;: Copy</code>).
Otherwise, the <code>QueryResult</code> gives back information about the possible answer(s)
we did find. It consists of four parts:</p>
<ul>
<li><strong>Certainty:</strong> tells you how sure we are of this answer. It can have two
values:
<ul>
<li><code>Proven</code> means that the result is known to be true.
<ul>
<li>This might be the result for trying to prove <code>Vec&lt;i32&gt;: Clone</code>,
say, or <code>Rc&lt;?T&gt;: Clone</code>.</li>
</ul>
</li>
<li><code>Ambiguous</code> means that there were things we could not yet prove to
be either true <em>or</em> false, typically because more type information
was needed. (We'll see an example shortly.)
<ul>
<li>This might be the result for trying to prove <code>Vec&lt;?T&gt;: Clone</code>.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Var values:</strong> Values for each of the unbound inference variables
(like <code>?T</code>) that appeared in your original query. (Remember that in Prolog,
we had to infer these.)
<ul>
<li>As we'll see in the example below, we can get back var values even
for <code>Ambiguous</code> cases.</li>
</ul>
</li>
<li><strong>Region constraints:</strong> these are relations that must hold between
the lifetimes that you supplied as inputs. We'll ignore these here,
but see the
<a href="./traits/regions.html">section on handling regions in traits</a> for
more details.</li>
<li><strong>Value:</strong> The query result also comes with a value of type <code>T</code>. For
some specialized queries -- like normalizing associated types --
this is used to carry back an extra result, but it's often just
<code>()</code>.</li>
</ul>
<a class="header" href="print.html#examples" id="examples"><h3>Examples</h3></a>
<p>Let's work through an example query to see what all the parts mean.
Consider <a href="https://doc.rust-lang.org/std/borrow/trait.Borrow.html">the <code>Borrow</code> trait</a>. This trait has a number of
impls; among them, there are these two (for clarify, I've written the
<code>Sized</code> bounds explicitly):</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Borrow&lt;T&gt; for T where T: ?Sized
impl&lt;T&gt; Borrow&lt;[T]&gt; for Vec&lt;T&gt; where T: Sized
</code></pre>
<p><strong>Example 1.</strong> Imagine we are type-checking this (rather artificial)
bit of code:</p>
<pre><code class="language-rust ignore">fn foo&lt;A, B&gt;(a: A, vec_b: Option&lt;B&gt;) where A: Borrow&lt;B&gt; { }

fn main() {
    let mut t: Vec&lt;_&gt; = vec![]; // Type: Vec&lt;?T&gt;
    let mut u: Option&lt;_&gt; = None; // Type: Option&lt;?U&gt;
    foo(t, u); // Example 1: requires `Vec&lt;?T&gt;: Borrow&lt;?U&gt;`
    ...
}
</code></pre>
<p>As the comments indicate, we first create two variables <code>t</code> and <code>u</code>;
<code>t</code> is an empty vector and <code>u</code> is a <code>None</code> option. Both of these
variables have unbound inference variables in their type: <code>?T</code>
represents the elements in the vector <code>t</code> and <code>?U</code> represents the
value stored in the option <code>u</code>.  Next, we invoke <code>foo</code>; comparing the
signature of <code>foo</code> to its arguments, we wind up with <code>A = Vec&lt;?T&gt;</code> and
<code>B = ?U</code>.Therefore, the where clause on <code>foo</code> requires that <code>Vec&lt;?T&gt;: Borrow&lt;?U&gt;</code>. This is thus our first example trait query.</p>
<p>There are many possible solutions to the query <code>Vec&lt;?T&gt;: Borrow&lt;?U&gt;</code>;
for example:</p>
<ul>
<li><code>?U = Vec&lt;?T&gt;</code>,</li>
<li><code>?U = [?T]</code>,</li>
<li><code>?T = u32, ?U = [u32]</code></li>
<li>and so forth.</li>
</ul>
<p>Therefore, the result we get back would be as follows (I'm going to
ignore region constraints and the &quot;value&quot;):</p>
<ul>
<li>Certainty: <code>Ambiguous</code> -- we're not sure yet if this holds</li>
<li>Var values: <code>[?T = ?T, ?U = ?U]</code> -- we learned nothing about the values of
the variables</li>
</ul>
<p>In short, the query result says that it is too soon to say much about
whether this trait is proven. During type-checking, this is not an
immediate error: instead, the type checker would hold on to this
requirement (<code>Vec&lt;?T&gt;: Borrow&lt;?U&gt;</code>) and wait. As we'll see in the next
example, it may happen that <code>?T</code> and <code>?U</code> wind up constrained from
other sources, in which case we can try the trait query again.</p>
<p><strong>Example 2.</strong> We can now extend our previous example a bit,
and assign a value to <code>u</code>:</p>
<pre><code class="language-rust ignore">fn foo&lt;A, B&gt;(a: A, vec_b: Option&lt;B&gt;) where A: Borrow&lt;B&gt; { }

fn main() {
    // What we saw before:
    let mut t: Vec&lt;_&gt; = vec![]; // Type: Vec&lt;?T&gt;
    let mut u: Option&lt;_&gt; = None; // Type: Option&lt;?U&gt;
    foo(t, u); // `Vec&lt;?T&gt;: Borrow&lt;?U&gt;` =&gt; ambiguous

    // New stuff:
    u = Some(vec![]); // ?U = Vec&lt;?V&gt;
}
</code></pre>
<p>As a result of this assignment, the type of <code>u</code> is forced to be
<code>Option&lt;Vec&lt;?V&gt;&gt;</code>, where <code>?V</code> represents the element type of the
vector. This in turn implies that <code>?U</code> is <a href="./type-checking.html">unified</a> to <code>Vec&lt;?V&gt;</code>.</p>
<p>Let's suppose that the type checker decides to revisit the
&quot;as-yet-unproven&quot; trait obligation we saw before, <code>Vec&lt;?T&gt;: Borrow&lt;?U&gt;</code>. <code>?U</code> is no longer an unbound inference variable; it now
has a value, <code>Vec&lt;?V&gt;</code>. So, if we &quot;refresh&quot; the query with that value, we get:</p>
<pre><code class="language-text">Vec&lt;?T&gt;: Borrow&lt;Vec&lt;?V&gt;&gt;
</code></pre>
<p>This time, there is only one impl that applies, the reflexive impl:</p>
<pre><code class="language-text">impl&lt;T&gt; Borrow&lt;T&gt; for T where T: ?Sized
</code></pre>
<p>Therefore, the trait checker will answer:</p>
<ul>
<li>Certainty: <code>Proven</code></li>
<li>Var values: <code>[?T = ?T, ?V = ?T]</code></li>
</ul>
<p>Here, it is saying that we have indeed proven that the obligation
holds, and we also know that <code>?T</code> and <code>?V</code> are the same type (but we
don't know what that type is yet!).</p>
<p>(In fact, as the function ends here, the type checker would give an
error at this point, since the element types of <code>t</code> and <code>u</code> are still
not yet known, even though they are known to be the same.)</p>
<a class="header" href="print.html#canonicalization" id="canonicalization"><h1>Canonicalization</h1></a>
<p>Canonicalization is the process of <strong>isolating</strong> an inference value
from its context. It is a key part of implementing
<a href="./traits/canonical-queries.html">canonical queries</a>, and you may wish to read the parent chapter
to get more context.</p>
<p>Canonicalization is really based on a very simple concept: every
<a href="./type-inference.html#vars">inference variable</a> is always in one of
two states: either it is <strong>unbound</strong>, in which case we don't know yet
what type it is, or it is <strong>bound</strong>, in which case we do. So to
isolate some data-structure T that contains types/regions from its
environment, we just walk down and find the unbound variables that
appear in T; those variables get replaced with &quot;canonical variables&quot;,
starting from zero and numbered in a fixed order (left to right, for
the most part, but really it doesn't matter as long as it is
consistent).</p>
<p>So, for example, if we have the type <code>X = (?T, ?U)</code>, where <code>?T</code> and
<code>?U</code> are distinct, unbound inference variables, then the canonical
form of <code>X</code> would be <code>(?0, ?1)</code>, where <code>?0</code> and <code>?1</code> represent these
<strong>canonical placeholders</strong>. Note that the type <code>Y = (?U, ?T)</code> also
canonicalizes to <code>(?0, ?1)</code>. But the type <code>Z = (?T, ?T)</code> would
canonicalize to <code>(?0, ?0)</code> (as would <code>(?U, ?U)</code>). In other words, the
exact identity of the inference variables is not important -- unless
they are repeated.</p>
<p>We use this to improve caching as well as to detect cycles and other
things during trait resolution. Roughly speaking, the idea is that if
two trait queries have the same canonicalize form, then they will get
the same answer. That answer will be expressed in terms of the
canonical variables (<code>?0</code>, <code>?1</code>), which we can then map back to the
original variables (<code>?T</code>, <code>?U</code>).</p>
<a class="header" href="print.html#canonicalizing-the-query" id="canonicalizing-the-query"><h2>Canonicalizing the query</h2></a>
<p>To see how it works, imagine that we are asking to solve the following
trait query: <code>?A: Foo&lt;'static, ?B&gt;</code>, where <code>?A</code> and <code>?B</code> are unbound.
This query contains two unbound variables, but it also contains the
lifetime <code>'static</code>. The trait system generally ignores all lifetimes
and treats them equally, so when canonicalizing, we will <em>also</em>
replace any <a href="./appendix/background.html#free-vs-bound">free lifetime</a> with a
canonical variable. Therefore, we get the following result:</p>
<pre><code class="language-text">?0: Foo&lt;'?1, ?2&gt;
</code></pre>
<p>Sometimes we write this differently, like so:</p>
<pre><code class="language-text">for&lt;T,L,T&gt; { ?0: Foo&lt;'?1, ?2&gt; }
</code></pre>
<p>This <code>for&lt;&gt;</code> gives some information about each of the canonical
variables within.  In this case, each <code>T</code> indicates a type variable,
so <code>?0</code> and <code>?2</code> are types; the <code>L</code> indicates a lifetime varibale, so
<code>?1</code> is a lifetime. The <code>canonicalize</code> method <em>also</em> gives back a
<code>CanonicalVarValues</code> array OV with the &quot;original values&quot; for each
canonicalized variable:</p>
<pre><code class="language-text">[?A, 'static, ?B]
</code></pre>
<p>We'll need this vector OV later, when we process the query response.</p>
<a class="header" href="print.html#executing-the-query" id="executing-the-query"><h2>Executing the query</h2></a>
<p>Once we've constructed the canonical query, we can try to solve it.
To do so, we will wind up creating a fresh inference context and
<strong>instantiating</strong> the canonical query in that context. The idea is that
we create a substitution S from the canonical form containing a fresh
inference variable (of suitable kind) for each canonical variable.
So, for our example query:</p>
<pre><code class="language-text">for&lt;T,L,T&gt; { ?0: Foo&lt;'?1, ?2&gt; }
</code></pre>
<p>the substitution S might be:</p>
<pre><code class="language-text">S = [?A, '?B, ?C]
</code></pre>
<p>We can then replace the bound canonical variables (<code>?0</code>, etc) with
these inference variables, yielding the following fully instantiated
query:</p>
<pre><code class="language-text">?A: Foo&lt;'?B, ?C&gt;
</code></pre>
<p>Remember that substitution S though! We're going to need it later.</p>
<p>OK, now that we have a fresh inference context and an instantiated
query, we can go ahead and try to solve it. The trait solver itself is
explained in more detail in <a href="./traits/slg.html">another section</a>, but
suffice to say that it will compute a <a href="./traits/canonical-queries.html#query-response">certainty value</a> (<code>Proven</code> or
<code>Ambiguous</code>) and have side-effects on the inference variables we've
created. For example, if there were only one impl of <code>Foo</code>, like so:</p>
<pre><code class="language-rust ignore">impl&lt;'a, X&gt; Foo&lt;'a, X&gt; for Vec&lt;X&gt;
where X: 'a
{ ... }
</code></pre>
<p>then we might wind up with a certainty value of <code>Proven</code>, as well as
creating fresh inference variables <code>'?D</code> and <code>?E</code> (to represent the
parameters on the impl) and unifying as follows:</p>
<ul>
<li><code>'?B = '?D</code></li>
<li><code>?A = Vec&lt;?E&gt;</code></li>
<li><code>?C = ?E</code></li>
</ul>
<p>We would also accumulate the region constraint <code>?E: '?D</code>, due to the
where clause.</p>
<p>In order to create our final query result, we have to &quot;lift&quot; these
values out of the query's inference context and into something that
can be reapplied in our original inference context. We do that by
<strong>re-applying canonicalization</strong>, but to the <strong>query result</strong>.</p>
<a class="header" href="print.html#canonicalizing-the-query-result" id="canonicalizing-the-query-result"><h2>Canonicalizing the query result</h2></a>
<p>As discussed in <a href="./traits/canonical-queries.html#query-response">the parent section</a>, most trait queries wind up
with a result that brings together a &quot;certainty value&quot; <code>certainty</code>, a
result substitution <code>var_values</code>, and some region constraints. To
create this, we wind up re-using the substitution S that we created
when first instantiating our query. To refresh your memory, we had a query</p>
<pre><code class="language-text">for&lt;T,L,T&gt; { ?0: Foo&lt;'?1, ?2&gt; }
</code></pre>
<p>for which we made a substutition S:</p>
<pre><code class="language-text">S = [?A, '?B, ?C]
</code></pre>
<p>We then did some work which unified some of those variables with other things.
If we &quot;refresh&quot; S with the latest results, we get:</p>
<pre><code class="language-text">S = [Vec&lt;?E&gt;, '?D, ?E]
</code></pre>
<p>These are precisely the new values for the three input variables from
our original query. Note though that they include some new variables
(like <code>?E</code>). We can make those go away by canonicalizing again! We don't
just canonicalize S, though, we canonicalize the whole query response QR:</p>
<pre><code class="language-text">QR = {
    certainty: Proven,             // or whatever
    var_values: [Vec&lt;?E&gt;, '?D, ?E] // this is S
    region_constraints: [?E: '?D], // from the impl
    value: (),                     // for our purposes, just (), but
                                   // in some cases this might have
                                   // a type or other info
}
</code></pre>
<p>The result would be as follows:</p>
<pre><code class="language-text">Canonical(QR) = for&lt;T, L&gt; {
    certainty: Proven,
    var_values: [Vec&lt;?0&gt;, '?1, ?2]
    region_constraints: [?2: '?1],
    value: (),
}
</code></pre>
<p>(One subtle point: when we canonicalize the query <strong>result</strong>, we do not
use any special treatment for free lifetimes. Note that both
references to <code>'?D</code>, for example, were converted into the same
canonical variable (<code>?1</code>). This is in contrast to the original query,
where we canonicalized every free lifetime into a fresh canonical
variable.)</p>
<p>Now, this result must be reapplied in each context where needed.</p>
<a class="header" href="print.html#processing-the-canonicalized-query-result" id="processing-the-canonicalized-query-result"><h2>Processing the canonicalized query result</h2></a>
<p>In the previous section we produced a canonical query result. We now have
to apply that result in our original context. If you recall, way back in the
beginning, we were trying to prove this query:</p>
<pre><code class="language-text">?A: Foo&lt;'static, ?B&gt;
</code></pre>
<p>We canonicalized that into this:</p>
<pre><code class="language-text">for&lt;T,L,T&gt; { ?0: Foo&lt;'?1, ?2&gt; }
</code></pre>
<p>and now we got back a canonical response:</p>
<pre><code class="language-text">for&lt;T, L&gt; {
    certainty: Proven,
    var_values: [Vec&lt;?0&gt;, '?1, ?2]
    region_constraints: [?2: '?1],
    value: (),
}
</code></pre>
<p>We now want to apply that response to our context. Conceptually, how
we do that is to (a) instantiate each of the canonical variables in
the result with a fresh inference variable, (b) unify the values in
the result with the original values, and then (c) record the region
constraints for later. Doing step (a) would yield a result of</p>
<pre><code class="language-text">{
      certainty: Proven,
      var_values: [Vec&lt;?C&gt;, '?D, ?C]
                       ^^   ^^^ fresh inference variables
      region_constraints: [?C: '?D],
      value: (),
}
</code></pre>
<p>Step (b) would then unify:</p>
<pre><code class="language-text">?A with Vec&lt;?C&gt;
'static with '?D
?B with ?C
</code></pre>
<p>And finally the region constraint of <code>?C: 'static</code> would be recorded
for later verification.</p>
<p>(What we <em>actually</em> do is a mildly optimized variant of that: Rather
than eagerly instantiating all of the canonical values in the result
with variables, we instead walk the vector of values, looking for
cases where the value is just a canonical variable. In our example,
<code>values[2]</code> is <code>?C</code>, so that means we can deduce that <code>?C := ?B and</code>'?D := 'static`. This gives us a partial set of values. Anything for
which we do not find a value, we create an inference variable.)</p>
<a class="header" href="print.html#lowering-rules" id="lowering-rules"><h1>Lowering rules</h1></a>
<p>This section gives the complete lowering rules for Rust traits into
<a href="./traits/goals-and-clauses.html">program clauses</a>. It is a kind of reference. These rules
reference the <a href="./traits/goals-and-clauses.html#domain-goals">domain goals</a> defined in an earlier section.</p>
<a class="header" href="print.html#notation" id="notation"><h2>Notation</h2></a>
<p>The nonterminal <code>Pi</code> is used to mean some generic <em>parameter</em>, either a
named lifetime like <code>'a</code> or a type paramter like <code>A</code>.</p>
<p>The nonterminal <code>Ai</code> is used to mean some generic <em>argument</em>, which
might be a lifetime like <code>'a</code> or a type like <code>Vec&lt;A&gt;</code>.</p>
<p>When defining the lowering rules, we will give goals and clauses in
the <a href="./traits/goals-and-clauses.html">notation given in this section</a>.
We sometimes insert &quot;macros&quot; like <code>LowerWhereClause!</code> into these
definitions; these macros reference other sections within this chapter.</p>
<a class="header" href="print.html#rule-names-and-cross-references" id="rule-names-and-cross-references"><h2>Rule names and cross-references</h2></a>
<p>Each of these lowering rules is given a name, documented with a
comment like so:</p>
<pre><code>// Rule Foo-Bar-Baz
</code></pre>
<p>you can also search through the <code>librustc_traits</code> crate in rustc
to find the corresponding rules from the implementation.</p>
<a class="header" href="print.html#lowering-where-clauses" id="lowering-where-clauses"><h2>Lowering where clauses</h2></a>
<p>When used in a goal position, where clauses can be mapped directly to
<a href="./traits/goals-and-clauses.html#domain-goals">domain goals</a>, as follows:</p>
<ul>
<li><code>A0: Foo&lt;A1..An&gt;</code> maps to <code>Implemented(A0: Foo&lt;A1..An&gt;)</code>.</li>
<li><code>A0: Foo&lt;A1..An, Item = T&gt;</code> maps to
<code>ProjectionEq(&lt;A0 as Foo&lt;A1..An&gt;&gt;::Item = T)</code></li>
<li><code>T: 'r</code> maps to <code>Outlives(T, 'r)</code></li>
<li><code>'a: 'b</code> maps to <code>Outlives('a, 'b)</code></li>
</ul>
<p>In the rules below, we will use <code>WC</code> to indicate where clauses that
appear in Rust syntax; we will then use the same <code>WC</code> to indicate
where those where clauses appear as goals in the program clauses that
we are producing. In that case, the mapping above is used to convert
from the Rust syntax into goals.</p>
<a class="header" href="print.html#transforming-the-lowered-where-clauses" id="transforming-the-lowered-where-clauses"><h3>Transforming the lowered where clauses</h3></a>
<p>In addition, in the rules below, we sometimes do some transformations
on the lowered where clauses, as defined here:</p>
<ul>
<li><code>FromEnv(WC)</code> -- this indicates that:
<ul>
<li><code>Implemented(TraitRef)</code> becomes <code>FromEnv(TraitRef)</code></li>
<li><code>ProjectionEq(Projection = Ty)</code> becomes <code>FromEnv(Projection = Ty)</code></li>
<li>other where-clauses are left intact</li>
</ul>
</li>
<li><code>WellFormed(WC)</code> -- this indicates that:
<ul>
<li><code>Implemented(TraitRef)</code> becomes <code>WellFormed(TraitRef)</code></li>
<li><code>ProjectionEq(Projection = Ty)</code> becomes <code>WellFormed(Projection = Ty)</code></li>
</ul>
</li>
</ul>
<p><em>TODO</em>: I suspect that we want to alter the outlives relations too,
but Chalk isn't modeling those right now.</p>
<a class="header" href="print.html#lowering-traits" id="lowering-traits"><h2>Lowering traits</h2></a>
<p>Given a trait definition</p>
<pre><code class="language-rust ignore">trait Trait&lt;P1..Pn&gt; // P0 == Self
where WC
{
    // trait items
}
</code></pre>
<p>we will produce a number of declarations. This section is focused on
the program clauses for the trait header (i.e., the stuff outside the
<code>{}</code>); the <a href="print.html#trait-items">section on trait items</a> covers the stuff
inside the <code>{}</code>.</p>
<a class="header" href="print.html#trait-header" id="trait-header"><h3>Trait header</h3></a>
<p>From the trait itself we mostly make &quot;meta&quot; rules that setup the
relationships between different kinds of domain goals.  The first such
rule from the trait header creates the mapping between the <code>FromEnv</code>
and <code>Implemented</code> predicates:</p>
<pre><code class="language-text">// Rule Implemented-From-Env
forall&lt;Self, P1..Pn&gt; {
  Implemented(Self: Trait&lt;P1..Pn&gt;) :- FromEnv(Self: Trait&lt;P1..Pn&gt;)
}
</code></pre>
<p><a name="implied-bounds"></a></p>
<a class="header" href="print.html#implied-bounds-1" id="implied-bounds-1"><h4>Implied bounds</h4></a>
<p>The next few clauses have to do with implied bounds (see also
<a href="https://rust-lang.github.io/rfcs/2089-implied-bounds.html">RFC 2089</a>). For each trait, we produce two clauses:</p>
<pre><code class="language-text">// Rule Implied-Bound-From-Trait
//
// For each where clause WC:
forall&lt;Self, P1..Pn&gt; {
  FromEnv(WC) :- FromEnv(Self: Trait&lt;P1..Pn)
}
</code></pre>
<p>This clause says that if we are assuming that the trait holds, then we can also
assume that its where-clauses hold. It's perhaps useful to see an example:</p>
<pre><code class="language-rust ignore">trait Eq: PartialEq { ... }
</code></pre>
<p>In this case, the <code>PartialEq</code> supertrait is equivalent to a <code>where Self: PartialEq</code> where clause, in our simplified model. The program
clause above therefore states that if we can prove <code>FromEnv(T: Eq)</code> --
e.g., if we are in some function with <code>T: Eq</code> in its where clauses --
then we also know that <code>FromEnv(T: PartialEq)</code>. Thus the set of things
that follow from the environment are not only the <strong>direct where
clauses</strong> but also things that follow from them.</p>
<p>The next rule is related; it defines what it means for a trait reference
to be <strong>well-formed</strong>:</p>
<pre><code class="language-text">// Rule WellFormed-TraitRef
forall&lt;Self, P1..Pn&gt; {
  WellFormed(Self: Trait&lt;P1..Pn&gt;) :- Implemented(Self: Trait&lt;P1..Pn&gt;) &amp;&amp; WellFormed(WC)
}
</code></pre>
<p>This <code>WellFormed</code> rule states that <code>T: Trait</code> is well-formed if (a)
<code>T: Trait</code> is implemented and (b) all the where-clauses declared on
<code>Trait</code> are well-formed (and hence they are implemented). Remember
that the <code>WellFormed</code> predicate is
<a href="./traits/goals-and-clauses.html#coinductive">coinductive</a>; in this
case, it is serving as a kind of &quot;carrier&quot; that allows us to enumerate
all the where clauses that are transitively implied by <code>T: Trait</code>.</p>
<p>An example:</p>
<pre><code class="language-rust ignore">trait Foo: A + Bar { }
trait Bar: B + Foo { }
trait A { }
trait B { }
</code></pre>
<p>Here, the transitive set of implications for <code>T: Foo</code> are <code>T: A</code>, <code>T: Bar</code>, and
<code>T: B</code>.  And indeed if we were to try to prove <code>WellFormed(T: Foo)</code>, we would
have to prove each one of those:</p>
<ul>
<li><code>WellFormed(T: Foo)</code>
<ul>
<li><code>Implemented(T: Foo)</code></li>
<li><code>WellFormed(T: A)</code>
<ul>
<li><code>Implemented(T: A)</code></li>
</ul>
</li>
<li><code>WellFormed(T: Bar)</code>
<ul>
<li><code>Implemented(T: Bar)</code></li>
<li><code>WellFormed(T: B)</code>
<ul>
<li><code>Implemented(T: Bar)</code></li>
</ul>
</li>
<li><code>WellFormed(T: Foo)</code> -- cycle, true coinductively</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>This <code>WellFormed</code> predicate is only used when proving that impls are
well-formed -- basically, for each impl of some trait ref <code>TraitRef</code>,
we must show that <code>WellFormed(TraitRef)</code>. This in turn justifies the
implied bounds rules that allow us to extend the set of <code>FromEnv</code>
items.</p>
<p><a name="trait-items"></a></p>
<a class="header" href="print.html#lowering-trait-items" id="lowering-trait-items"><h2>Lowering trait items</h2></a>
<a class="header" href="print.html#associated-type-declarations" id="associated-type-declarations"><h3>Associated type declarations</h3></a>
<p>Given a trait that declares a (possibly generic) associated type:</p>
<pre><code class="language-rust ignore">trait Trait&lt;P1..Pn&gt; // P0 == Self
where WC
{
    type AssocType&lt;Pn+1..Pm&gt;: Bounds where WC1;
}
</code></pre>
<p>We will produce a number of program clauses. The first two define
the rules by which <code>ProjectionEq</code> can succeed; these two clauses are discussed
in detail in the <a href="./traits/associated-types.html">section on associated types</a>,
but reproduced here for reference:</p>
<pre><code class="language-text">// Rule ProjectionEq-Normalize
//
// ProjectionEq can succeed by normalizing:
forall&lt;Self, P1..Pn, Pn+1..Pm, U&gt; {
  ProjectionEq(&lt;Self as Trait&lt;P1..Pn&gt;&gt;::AssocType&lt;Pn+1..Pm&gt; = U) :-
      Normalize(&lt;Self as Trait&lt;P1..Pn&gt;&gt;::AssocType&lt;Pn+1..Pm&gt; -&gt; U)
}
</code></pre>
<pre><code class="language-text">// Rule ProjectionEq-Skolemize
//
// ProjectionEq can succeed by skolemizing, see &quot;associated type&quot;
// chapter for more:
forall&lt;Self, P1..Pn, Pn+1..Pm&gt; {
  ProjectionEq(
    &lt;Self as Trait&lt;P1..Pn&gt;&gt;::AssocType&lt;Pn+1..Pm&gt; =
    (Trait::AssocType)&lt;Self, P1..Pn, Pn+1..Pm&gt;
  )
}
</code></pre>
<p>The next rule covers implied bounds for the projection. In particular,
the <code>Bounds</code> declared on the associated type must have been proven to hold
to show that the impl is well-formed, and hence we can rely on them
elsewhere.</p>
<pre><code class="language-text">// Rule Implied-Bound-From-AssocTy
//
// For each `Bound` in `Bounds`:
forall&lt;Self, P1..Pn, Pn+1..Pm&gt; {
    FromEnv(&lt;Self as Trait&lt;P1..Pn&gt;&gt;::AssocType&lt;Pn+1..Pm&gt;&gt;: Bound) :-
      FromEnv(Self: Trait&lt;P1..Pn&gt;)
}
</code></pre>
<p>Next, we define the requirements for an instantiation of our associated
type to be well-formed...</p>
<pre><code class="language-text">// Rule WellFormed-AssocTy
forall&lt;Self, P1..Pn, Pn+1..Pm&gt; {
    WellFormed((Trait::AssocType)&lt;Self, P1..Pn, Pn+1..Pm&gt;) :-
      WC1, Implemented(Self: Trait&lt;P1..Pn&gt;)
}
</code></pre>
<p>...along with the reverse implications, when we can assume that it is
well-formed.</p>
<pre><code class="language-text">// Rule Implied-WC-From-AssocTy
//
// For each where clause WC1:
forall&lt;Self, P1..Pn, Pn+1..Pm&gt; {
    FromEnv(WC1) :- FromEnv((Trait::AssocType)&lt;Self, P1..Pn, Pn+1..Pm&gt;)
}
</code></pre>
<pre><code class="language-text">// Rule Implied-Trait-From-AssocTy
forall&lt;Self, P1..Pn, Pn+1..Pm&gt; {
    FromEnv(Self: Trait&lt;P1..Pn&gt;) :-
      FromEnv((Trait::AssocType)&lt;Self, P1..Pn, Pn+1..Pm&gt;)
}
</code></pre>
<a class="header" href="print.html#lowering-function-and-constant-declarations" id="lowering-function-and-constant-declarations"><h3>Lowering function and constant declarations</h3></a>
<p>Chalk didn't model functions and constants, but I would eventually like to
treat them exactly like normalization. See <a href="print.html#constant-vals">the section on function/constant
values below</a> for more details.</p>
<a class="header" href="print.html#lowering-impls" id="lowering-impls"><h2>Lowering impls</h2></a>
<p>Given an impl of a trait:</p>
<pre><code class="language-rust ignore">impl&lt;P0..Pn&gt; Trait&lt;A1..An&gt; for A0
where WC
{
    // zero or more impl items
}
</code></pre>
<p>Let <code>TraitRef</code> be the trait reference <code>A0: Trait&lt;A1..An&gt;</code>. Then we
will create the following rules:</p>
<pre><code class="language-text">// Rule Implemented-From-Impl
forall&lt;P0..Pn&gt; {
  Implemented(TraitRef) :- WC
}
</code></pre>
<p>In addition, we will lower all of the <em>impl items</em>.</p>
<a class="header" href="print.html#lowering-impl-items" id="lowering-impl-items"><h2>Lowering impl items</h2></a>
<a class="header" href="print.html#associated-type-values" id="associated-type-values"><h3>Associated type values</h3></a>
<p>Given an impl that contains:</p>
<pre><code class="language-rust ignore">impl&lt;P0..Pn&gt; Trait&lt;P1..Pn&gt; for P0
where WC_impl
{
    type AssocType&lt;Pn+1..Pm&gt; = T;
}
</code></pre>
<p>and our where clause <code>WC1</code> on the trait associated type from above, we
produce the following rule:</p>
<pre><code class="language-text">// Rule Normalize-From-Impl
forall&lt;P0..Pm&gt; {
  forall&lt;Pn+1..Pm&gt; {
    Normalize(&lt;P0 as Trait&lt;P1..Pn&gt;&gt;::AssocType&lt;Pn+1..Pm&gt; -&gt; T) :-
      Implemented(P0 as Trait) &amp;&amp; WC1
  }
}
</code></pre>
<p>Note that <code>WC_impl</code> and <code>WC1</code> both encode where-clauses that the impl can
rely on. (<code>WC_impl</code> is not used here, because it is implied by
<code>Implemented(P0 as Trait)</code>.)</p>
<p><a name="constant-vals"></a></p>
<a class="header" href="print.html#function-and-constant-values" id="function-and-constant-values"><h3>Function and constant values</h3></a>
<p>Chalk didn't model functions and constants, but I would eventually
like to treat them exactly like normalization. This presumably
involves adding a new kind of parameter (constant), and then having a
<code>NormalizeValue</code> domain goal. This is <em>to be written</em> because the
details are a bit up in the air.</p>
<a class="header" href="print.html#the-lowering-module-in-rustc" id="the-lowering-module-in-rustc"><h1>The lowering module in rustc</h1></a>
<p>The program clauses described in the
<a href="./traits/lowering-rules.html">lowering rules</a> section are actually
created in the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_traits/lowering/"><code>rustc_traits::lowering</code></a> module.</p>
<a class="header" href="print.html#the-program_clauses_for-query" id="the-program_clauses_for-query"><h2>The <code>program_clauses_for</code> query</h2></a>
<p>The main entry point is the <code>program_clauses_for</code> <a href="./query.html">query</a>, which --
given a def-id -- produces a set of Chalk program clauses. These
queries are tested using a
<a href="print.html#unit-tests">dedicated unit-testing mechanism, described below</a>.  The
query is invoked on a <code>DefId</code> that identifies something like a trait,
an impl, or an associated item definition. It then produces and
returns a vector of program clauses.</p>
<p><a name="unit-tests"></a></p>
<a class="header" href="print.html#unit-tests" id="unit-tests"><h2>Unit tests</h2></a>
<p>Unit tests are located in <a href="https://github.com/rust-lang/rust/tree/master/src/test/ui/chalkify"><code>src/test/ui/chalkify</code></a>. A good
example test is <a href="https://github.com/rust-lang/rust/tree/master/src/test/ui/chalkify/lower_impl.rs">the <code>lower_impl</code> test</a>. At the time of
this writing, it looked like this:</p>
<pre><code class="language-rust ignore">#![feature(rustc_attrs)]

trait Foo { }

#[rustc_dump_program_clauses] //~ ERROR Implemented(T: Foo) :-
impl&lt;T: 'static&gt; Foo for T where T: Iterator&lt;Item = i32&gt; { }

fn main() {
    println!(&quot;hello&quot;);
}
</code></pre>
<p>The <code>#[rustc_dump_program_clauses]</code> annotation can be attached to
anything with a def-id.  (It requires the <code>rustc_attrs</code> feature.) The
compiler will then invoke the <code>program_clauses_for</code> query on that
item, and emit compiler errors that dump the clauses produced. These
errors just exist for unit-testing, as we can then leverage the
standard <a href="https://rust-lang-nursery.github.io/rustc-guide/tests/adding.html#guide-to-the-ui-tests">ui test</a> mechanisms to check them. In this case, there is a
<code>//~ ERROR Implemented</code> annotation which is intentionally minimal (it
need only be a prefix of the error), but <a href="https://github.com/rust-lang/rust/tree/master/src/test/ui/chalkify/lower_impl.stderr">the stderr file</a> contains
the full details:</p>
<pre><code class="language-text">error: Implemented(T: Foo) :- ProjectionEq(&lt;T as std::iter::Iterator&gt;::Item == i32), TypeOutlives(T \
: 'static), Implemented(T: std::iter::Iterator), Implemented(T: std::marker::Sized).
  --&gt; $DIR/lower_impl.rs:15:1
   |
LL | #[rustc_dump_program_clauses] //~ ERROR Implemented(T: Foo) :-
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: aborting due to previous error
</code></pre>
<a class="header" href="print.html#well-formedness-checking" id="well-formedness-checking"><h1>Well-formedness checking</h1></a>
<p>This chapter is mostly <em>to be written</em>. WF checking, in short, has the
job of checking that the various declarations in a Rust program are
well-formed. This is the basis for implied bounds, and partly for that
reason, this checking can be surprisingly subtle! (For example, we
have to be sure that each impl proves the WF conditions declared on
the trait.)</p>
<a class="header" href="print.html#the-slg-solver" id="the-slg-solver"><h1>The SLG solver</h1></a>
<p>TODO: <a href="https://github.com/rust-lang-nursery/chalk/blob/master/chalk-engine/src/README.md">https://github.com/rust-lang-nursery/chalk/blob/master/chalk-engine/src/README.md</a></p>
<a class="header" href="print.html#an-overview-of-chalk" id="an-overview-of-chalk"><h1>An Overview of Chalk</h1></a>
<blockquote>
<p>Chalk is under heavy development, so if any of these links are broken or if
any of the information is inconsistent with the code or outdated, please
<a href="https://github.com/rust-lang-nursery/rustc-guide/issues">open an issue</a> so we can fix it. If you are able to fix the
issue yourself, we would love your contribution!</p>
</blockquote>
<p><a href="https://github.com/rust-lang-nursery/chalk">Chalk</a> recasts Rust's trait system explicitly in terms of logic
programming by &quot;lowering&quot; Rust code into a kind of logic program we can then
execute queries against. (See <a href="traits/lowering-to-logic.html"><em>Lowering to Logic</em></a> and
<a href="traits/lowering-rules.html"><em>Lowering Rules</em></a>) Its goal is to be an executable, highly
readable specification of the Rust trait system.</p>
<p>There are many expected benefits from this work. It will consolidate our
existing, somewhat ad-hoc implementation into something far more principled and
expressive, which should behave better in corner cases, and be much easier to
extend.</p>
<a class="header" href="print.html#resources" id="resources"><h2>Resources</h2></a>
<ul>
<li><a href="https://github.com/rust-lang-nursery/chalk">Chalk Source Code</a></li>
<li><a href="https://github.com/rust-lang-nursery/chalk/blob/master/GLOSSARY.md">Chalk Glossary</a></li>
<li>The traits section of the rustc guide (you are here)</li>
</ul>
<a class="header" href="print.html#blog-posts" id="blog-posts"><h3>Blog Posts</h3></a>
<ul>
<li><a href="http://smallcultfollowing.com/babysteps/blog/2017/01/26/lowering-rust-traits-to-logic/">Lowering Rust traits to logic</a></li>
<li><a href="http://smallcultfollowing.com/babysteps/blog/2017/03/25/unification-in-chalk-part-1/">Unification in Chalk, part 1</a></li>
<li><a href="http://smallcultfollowing.com/babysteps/blog/2017/04/23/unification-in-chalk-part-2/">Unification in Chalk, part 2</a></li>
<li><a href="http://aturon.github.io/blog/2017/04/24/negative-chalk/">Negative reasoning in Chalk</a></li>
<li><a href="http://smallcultfollowing.com/babysteps/blog/2017/05/25/query-structure-in-chalk/">Query structure in chalk</a></li>
<li><a href="http://smallcultfollowing.com/babysteps/blog/2017/09/12/tabling-handling-cyclic-queries-in-chalk/">Cyclic queries in chalk</a></li>
<li><a href="http://smallcultfollowing.com/babysteps/blog/2018/01/31/an-on-demand-slg-solver-for-chalk/">An on-demand SLG solver for chalk</a></li>
</ul>
<a class="header" href="print.html#parsing" id="parsing"><h2>Parsing</h2></a>
<p>Chalk is designed to be incorporated with the Rust compiler, so the syntax and
concepts it deals with heavily borrow from Rust. It is convenient for the sake
of testing to be able to run chalk on its own, so chalk includes a parser for a
Rust-like syntax. This syntax is orthogonal to the Rust AST and grammar. It is
not intended to look exactly like it or support the exact same syntax.</p>
<p>The parser takes that syntax and produces an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Tree (AST)</a>.
You can find the <a href="https://github.com/rust-lang-nursery/chalk/blob/master/chalk-parse/src/ast.rs">complete definition of the AST</a> in the source code.</p>
<p>The syntax contains things from Rust that we know and love, for example: traits,
impls, and struct definitions. Parsing is often the first &quot;phase&quot; of
transformation that a program goes through in order to become a format that
chalk can understand.</p>
<a class="header" href="print.html#lowering" id="lowering"><h2>Lowering</h2></a>
<p>After parsing, there is a &quot;lowering&quot; phase. This aims to convert traits/impls
into &quot;program clauses&quot;. A <a href="https://github.com/rust-lang-nursery/chalk/blob/94a1941a021842a5fcb35cd043145c8faae59f08/src/ir.rs#L721"><code>ProgramClause</code> (source code)</a> is
essentially one of the following:</p>
<ul>
<li>A <a href="https://github.com/rust-lang-nursery/chalk/blob/master/GLOSSARY.md#clause">clause</a> of the form <code>consequence :- conditions</code> where <code>:-</code> is read as
&quot;if&quot; and <code>conditions = cond1 &amp;&amp; cond2 &amp;&amp; ...</code></li>
<li>A universally quantified clause of the form
<code>forall&lt;T&gt; { consequence :- conditions }</code>
<ul>
<li><code>forall&lt;T&gt; { ... }</code> is used to represent <a href="https://en.wikipedia.org/wiki/Universal_quantification">universal quantification</a>. See the
section on <a href="./traits/lowering-to-logic.html#type-checking-generic-functions-beyond-horn-clauses">Lowering to logic</a> for more information.</li>
<li>A key thing to note about <code>forall</code> is that we don't allow you to &quot;quantify&quot;
over traits, only types and regions (lifetimes). That is, you can't make a
rule like <code>forall&lt;Trait&gt; { u32: Trait }</code> which would say &quot;<code>u32</code> implements
all traits&quot;. You can however say <code>forall&lt;T&gt; { T: Trait }</code> meaning &quot;<code>Trait</code>
is implemented by all types&quot;.</li>
<li><code>forall&lt;T&gt; { ... }</code> is represented in the code using the <a href="https://github.com/rust-lang-nursery/chalk/blob/94a1941a021842a5fcb35cd043145c8faae59f08/src/ir.rs#L661"><code>Binders&lt;T&gt;</code>
struct</a>.</li>
</ul>
</li>
</ul>
<p><em>See also: <a href="./traits/goals-and-clauses.html">Goals and Clauses</a></em></p>
<p>Lowering is the phase where we encode the rules of the trait system into logic.
For example, if we have the following Rust:</p>
<pre><code class="language-rust ignore">impl&lt;T: Clone&gt; Clone for Vec&lt;T&gt; {}
</code></pre>
<p>We generate the following program clause:</p>
<pre><code class="language-rust ignore">forall&lt;T&gt; { (Vec&lt;T&gt;: Clone) :- (T: Clone) }
</code></pre>
<p>This rule dictates that <code>Vec&lt;T&gt;: Clone</code> is only satisfied if <code>T: Clone</code> is also
satisfied (i.e. &quot;provable&quot;).</p>
<a class="header" href="print.html#well-formedness-checks" id="well-formedness-checks"><h3>Well-formedness checks</h3></a>
<p>As part of lowering from the AST to the internal IR, we also do some &quot;well
formedness&quot; checks. See the <a href="https://github.com/rust-lang-nursery/chalk/blob/94a1941a021842a5fcb35cd043145c8faae59f08/src/ir/lowering.rs#L230-L232">source code</a> for where
those are done. The call to <code>record_specialization_priorities</code> checks
&quot;coherence&quot; which means that it ensures that two impls of the same trait for the
same type cannot exist.</p>
<a class="header" href="print.html#intermediate-representation-ir" id="intermediate-representation-ir"><h2>Intermediate Representation (IR)</h2></a>
<p>The second intermediate representation in chalk is called, well, the &quot;ir&quot;. :)
The <a href="https://github.com/rust-lang-nursery/chalk/blob/master/src/ir.rs">IR source code</a> contains the complete definition. The
<code>ir::Program</code> struct contains some &quot;rust things&quot; but indexed and accessible in
a different way. This is sort of analogous to the <a href="hir.html">HIR</a> in Rust.</p>
<p>For example, if you have a type like <code>Foo&lt;Bar&gt;</code>, we would represent <code>Foo</code> as a
string in the AST but in <code>ir::Program</code>, we use numeric indices (<code>ItemId</code>).</p>
<p>In addition to <code>ir::Program</code> which has &quot;rust-like things&quot;, there is also
<code>ir::ProgramEnvironment</code> which is &quot;pure logic&quot;. The main field in that struct is
<code>program_clauses</code> which contains the <code>ProgramClause</code>s that we generated
previously.</p>
<a class="header" href="print.html#rules" id="rules"><h2>Rules</h2></a>
<p>The <code>rules</code> module works by iterating over every trait, impl, etc. and emitting
the rules that come from each one. See <a href="traits/lowering-rules.html">Lowering Rules</a> for the
most up-to-date reference on that.</p>
<p>The <code>ir::ProgramEnvironment</code> is created <a href="https://github.com/rust-lang-nursery/chalk/blob/94a1941a021842a5fcb35cd043145c8faae59f08/src/rules.rs#L9">in this module</a>.</p>
<a class="header" href="print.html#testing" id="testing"><h2>Testing</h2></a>
<p>TODO: Basically, <a href="https://github.com/rust-lang-nursery/chalk/blob/94a1941a021842a5fcb35cd043145c8faae59f08/src/solve/test.rs#L112-L148">there is a macro</a>
that will take chalk's Rust-like syntax and run it through the full pipeline
described above.
<a href="https://github.com/rust-lang-nursery/chalk/blob/94a1941a021842a5fcb35cd043145c8faae59f08/src/solve/test.rs#L83-L110">This</a>
is the function that is ultimately called.</p>
<a class="header" href="print.html#solver" id="solver"><h2>Solver</h2></a>
<p>See <a href="./traits/slg.html">The SLG Solver</a>.</p>
<a class="header" href="print.html#bibliography" id="bibliography"><h1>Bibliography</h1></a>
<p>If you'd like to read more background material, here are some
recommended texts and papers:</p>
<p><a href="https://www.amazon.com/Programming-Higher-Order-Logic-Dale-Miller/dp/052187940X">Programming with Higher-order Logic</a>, by Dale Miller and Gopalan
Nadathur, covers the key concepts of Lambda prolog. Although it's a
slim little volume, it's the kind of book where you learn something
new every time you open it.</p>
<p><a name="pphhf"></a></p>
<p><a href="https://dl.acm.org/citation.cfm?id=868380">&quot;A proof procedure for the logic of Hereditary Harrop formulas&quot;</a>,
by Gopalan Nadathur. This paper covers the basics of universes,
environments, and Lambda Prolog-style proof search. Quite readable.</p>
<p><a name="slg"></a></p>
<p><a href="https://dl.acm.org/citation.cfm?id=651202">&quot;A new formulation of tabled resolution with delay&quot;</a>, by
<a href="http://www3.cs.stonybrook.edu/%7Etswift/">Theresa Swift</a>. This paper gives a kind of abstract treatment of the
SLG formulation that is the basis for our on-demand solver.</p>
<a class="header" href="print.html#type-checking" id="type-checking"><h1>Type checking</h1></a>
<p>The <a href="https://github.com/rust-lang/rust/tree/master/src/librustc_typeck"><code>rustc_typeck</code></a> crate contains the source for &quot;type collection&quot;
and &quot;type checking&quot;, as well as a few other bits of related functionality. (It
draws heavily on the <a href="type-inference.html">type inference</a> and <a href="traits/resolution.html">trait solving</a>.)</p>
<a class="header" href="print.html#type-collection" id="type-collection"><h2>Type collection</h2></a>
<p>Type &quot;collection&quot; is the process of converting the types found in the HIR
(<code>hir::Ty</code>), which represent the syntactic things that the user wrote, into the
<strong>internal representation</strong> used by the compiler (<code>Ty&lt;'tcx&gt;</code>) -- we also do
similar conversions for where-clauses and other bits of the function signature.</p>
<p>To try and get a sense for the difference, consider this function:</p>
<pre><code class="language-rust ignore">struct Foo { }
fn foo(x: Foo, y: self::Foo) { ... }
//        ^^^     ^^^^^^^^^
</code></pre>
<p>Those two parameters <code>x</code> and <code>y</code> each have the same type: but they will have
distinct <code>hir::Ty</code> nodes. Those nodes will have different spans, and of course
they encode the path somewhat differently. But once they are &quot;collected&quot; into
<code>Ty&lt;'tcx&gt;</code> nodes, they will be represented by the exact same internal type.</p>
<p>Collection is defined as a bundle of <a href="query.html">queries</a> for computing information about
the various functions, traits, and other items in the crate being compiled.
Note that each of these queries is concerned with <em>interprocedural</em> things --
for example, for a function definition, collection will figure out the type and
signature of the function, but it will not visit the <em>body</em> of the function in
any way, nor examine type annotations on local variables (that's the job of
type <em>checking</em>).</p>
<p>For more details, see the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_typeck/collect/"><code>collect</code></a> module.</p>
<p><strong>TODO</strong>: actually talk about type checking...</p>
<a class="header" href="print.html#method-lookup" id="method-lookup"><h1>Method lookup</h1></a>
<p>Method lookup can be rather complex due to the interaction of a number
of factors, such as self types, autoderef, trait lookup, etc. This
file provides an overview of the process. More detailed notes are in
the code itself, naturally.</p>
<p>One way to think of method lookup is that we convert an expression of
the form:</p>
<pre><code class="language-rust ignore">receiver.method(...)
</code></pre>
<p>into a more explicit <a href="https://github.com/rust-lang/rfcs/blob/master/text/0132-ufcs.md">UFCS</a> form:</p>
<pre><code class="language-rust ignore">Trait::method(ADJ(receiver), ...) // for a trait call
ReceiverType::method(ADJ(receiver), ...) // for an inherent method call
</code></pre>
<p>Here <code>ADJ</code> is some kind of adjustment, which is typically a series of
autoderefs and then possibly an autoref (e.g., <code>&amp;**receiver</code>). However
we sometimes do other adjustments and coercions along the way, in
particular unsizing (e.g., converting from <code>[T; n]</code> to <code>[T]</code>).</p>
<p>Method lookup is divided into two major phases:</p>
<ol>
<li>Probing (<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_typeck/check/method/probe/"><code>probe.rs</code></a>). The probe phase is when we decide what method
to call and how to adjust the receiver.</li>
<li>Confirmation (<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_typeck/check/method/confirm/"><code>confirm.rs</code></a>). The confirmation phase &quot;applies&quot;
this selection, updating the side-tables, unifying type variables, and
otherwise doing side-effectful things.</li>
</ol>
<p>One reason for this division is to be more amenable to caching.  The
probe phase produces a &quot;pick&quot; (<code>probe::Pick</code>), which is designed to be
cacheable across method-call sites. Therefore, it does not include
inference variables or other information.</p>
<a class="header" href="print.html#the-probe-phase" id="the-probe-phase"><h2>The Probe phase</h2></a>
<a class="header" href="print.html#steps" id="steps"><h3>Steps</h3></a>
<p>The first thing that the probe phase does is to create a series of
<em>steps</em>. This is done by progressively dereferencing the receiver type
until it cannot be deref'd anymore, as well as applying an optional
&quot;unsize&quot; step. So if the receiver has type <code>Rc&lt;Box&lt;[T; 3]&gt;&gt;</code>, this
might yield:</p>
<pre><code class="language-rust ignore">Rc&lt;Box&lt;[T; 3]&gt;&gt;
Box&lt;[T; 3]&gt;
[T; 3]
[T]
</code></pre>
<a class="header" href="print.html#candidate-assembly-1" id="candidate-assembly-1"><h3>Candidate assembly</h3></a>
<p>We then search along those steps to create a list of <em>candidates</em>. A
<code>Candidate</code> is a method item that might plausibly be the method being
invoked. For each candidate, we'll derive a &quot;transformed self type&quot;
that takes into account explicit self.</p>
<p>Candidates are grouped into two kinds, inherent and extension.</p>
<p><strong>Inherent candidates</strong> are those that are derived from the
type of the receiver itself.  So, if you have a receiver of some
nominal type <code>Foo</code> (e.g., a struct), any methods defined within an
impl like <code>impl Foo</code> are inherent methods.  Nothing needs to be
imported to use an inherent method, they are associated with the type
itself (note that inherent impls can only be defined in the same
module as the type itself).</p>
<p>FIXME: Inherent candidates are not always derived from impls.  If you
have a trait object, such as a value of type <code>Box&lt;ToString&gt;</code>, then the
trait methods (<code>to_string()</code>, in this case) are inherently associated
with it. Another case is type parameters, in which case the methods of
their bounds are inherent. However, this part of the rules is subject
to change: when DST's &quot;impl Trait for Trait&quot; is complete, trait object
dispatch could be subsumed into trait matching, and the type parameter
behavior should be reconsidered in light of where clauses.</p>
<p>TODO: Is this FIXME still accurate?</p>
<p><strong>Extension candidates</strong> are derived from imported traits.  If I have
the trait <code>ToString</code> imported, and I call <code>to_string()</code> on a value of
type <code>T</code>, then we will go off to find out whether there is an impl of
<code>ToString</code> for <code>T</code>.  These kinds of method calls are called &quot;extension
methods&quot;.  They can be defined in any module, not only the one that
defined <code>T</code>.  Furthermore, you must import the trait to call such a
method.</p>
<p>So, let's continue our example. Imagine that we were calling a method
<code>foo</code> with the receiver <code>Rc&lt;Box&lt;[T; 3]&gt;&gt;</code> and there is a trait <code>Foo</code>
that defines it with <code>&amp;self</code> for the type <code>Rc&lt;U&gt;</code> as well as a method
on the type <code>Box</code> that defines <code>Foo</code> but with <code>&amp;mut self</code>. Then we
might have two candidates:</p>
<pre><code class="language-text">&amp;Rc&lt;Box&lt;[T; 3]&gt;&gt; from the impl of `Foo` for `Rc&lt;U&gt;` where `U=Box&lt;T; 3]&gt;
&amp;mut Box&lt;[T; 3]&gt;&gt; from the inherent impl on `Box&lt;U&gt;` where `U=[T; 3]`
</code></pre>
<a class="header" href="print.html#candidate-search" id="candidate-search"><h3>Candidate search</h3></a>
<p>Finally, to actually pick the method, we will search down the steps,
trying to match the receiver type against the candidate types. At
each step, we also consider an auto-ref and auto-mut-ref to see whether
that makes any of the candidates match. We pick the first step where
we find a match.</p>
<p>In the case of our example, the first step is <code>Rc&lt;Box&lt;[T; 3]&gt;&gt;</code>,
which does not itself match any candidate. But when we autoref it, we
get the type <code>&amp;Rc&lt;Box&lt;[T; 3]&gt;&gt;</code> which does match. We would then
recursively consider all where-clauses that appear on the impl: if
those match (or we cannot rule out that they do), then this is the
method we would pick. Otherwise, we would continue down the series of
steps.</p>
<a class="header" href="print.html#variance-of-type-and-lifetime-parameters" id="variance-of-type-and-lifetime-parameters"><h1>Variance of type and lifetime parameters</h1></a>
<p>For a more general background on variance, see the <a href="./appendix/background.html">background</a> appendix.</p>
<p>During type checking we must infer the variance of type and lifetime
parameters. The algorithm is taken from Section 4 of the paper <a href="https://people.cs.umass.edu/%7Eyannis/variance-extended2011.pdf">&quot;Taming the
Wildcards: Combining Definition- and Use-Site Variance&quot;</a> published in
PLDI'11 and written by Altidor et al., and hereafter referred to as The Paper.</p>
<p>This inference is explicitly designed <em>not</em> to consider the uses of
types within code. To determine the variance of type parameters
defined on type <code>X</code>, we only consider the definition of the type <code>X</code>
and the definitions of any types it references.</p>
<p>We only infer variance for type parameters found on <em>data types</em>
like structs and enums. In these cases, there is a fairly straightforward
explanation for what variance means. The variance of the type
or lifetime parameters defines whether <code>T&lt;A&gt;</code> is a subtype of <code>T&lt;B&gt;</code>
(resp. <code>T&lt;'a&gt;</code> and <code>T&lt;'b&gt;</code>) based on the relationship of <code>A</code> and <code>B</code>
(resp. <code>'a</code> and <code>'b</code>).</p>
<p>We do not infer variance for type parameters found on traits, functions,
or impls. Variance on trait parameters can indeed make sense
(and we used to compute it) but it is actually rather subtle in
meaning and not that useful in practice, so we removed it. See the
<a href="print.html#addendum">addendum</a> for some details. Variances on function/impl parameters, on the
other hand, doesn't make sense because these parameters are instantiated and
then forgotten, they don't persist in types or compiled byproducts.</p>
<blockquote>
<p><strong>Notation</strong></p>
<p>We use the notation of The Paper throughout this chapter:</p>
<ul>
<li><code>+</code> is <em>covariance</em>.</li>
<li><code>-</code> is <em>contravariance</em>.</li>
<li><code>*</code> is <em>bivariance</em>.</li>
<li><code>o</code> is <em>invariance</em>.</li>
</ul>
</blockquote>
<a class="header" href="print.html#the-algorithm" id="the-algorithm"><h2>The algorithm</h2></a>
<p>The basic idea is quite straightforward. We iterate over the types
defined and, for each use of a type parameter <code>X</code>, accumulate a
constraint indicating that the variance of <code>X</code> must be valid for the
variance of that use site. We then iteratively refine the variance of
<code>X</code> until all constraints are met. There is <em>always</em> a solution, because at
the limit we can declare all type parameters to be invariant and all
constraints will be satisfied.</p>
<p>As a simple example, consider:</p>
<pre><code class="language-rust ignore">enum Option&lt;A&gt; { Some(A), None }
enum OptionalFn&lt;B&gt; { Some(|B|), None }
enum OptionalMap&lt;C&gt; { Some(|C| -&gt; C), None }
</code></pre>
<p>Here, we will generate the constraints:</p>
<pre><code class="language-text">1. V(A) &lt;= +
2. V(B) &lt;= -
3. V(C) &lt;= +
4. V(C) &lt;= -
</code></pre>
<p>These indicate that (1) the variance of A must be at most covariant;
(2) the variance of B must be at most contravariant; and (3, 4) the
variance of C must be at most covariant <em>and</em> contravariant. All of these
results are based on a variance lattice defined as follows:</p>
<pre><code class="language-text">   *      Top (bivariant)
-     +
   o      Bottom (invariant)
</code></pre>
<p>Based on this lattice, the solution <code>V(A)=+</code>, <code>V(B)=-</code>, <code>V(C)=o</code> is the
optimal solution. Note that there is always a naive solution which
just declares all variables to be invariant.</p>
<p>You may be wondering why fixed-point iteration is required. The reason
is that the variance of a use site may itself be a function of the
variance of other type parameters. In full generality, our constraints
take the form:</p>
<pre><code class="language-text">V(X) &lt;= Term
Term := + | - | * | o | V(X) | Term x Term
</code></pre>
<p>Here the notation <code>V(X)</code> indicates the variance of a type/region
parameter <code>X</code> with respect to its defining class. <code>Term x Term</code>
represents the &quot;variance transform&quot; as defined in the paper:</p>
<blockquote>
<p>If the variance of a type variable <code>X</code> in type expression <code>E</code> is <code>V2</code>
and the definition-site variance of the [corresponding] type parameter
of a class <code>C</code> is <code>V1</code>, then the variance of <code>X</code> in the type expression
<code>C&lt;E&gt;</code> is <code>V3 = V1.xform(V2)</code>.</p>
</blockquote>
<a class="header" href="print.html#constraints" id="constraints"><h2>Constraints</h2></a>
<p>If I have a struct or enum with where clauses:</p>
<pre><code class="language-rust ignore">struct Foo&lt;T: Bar&gt; { ... }
</code></pre>
<p>you might wonder whether the variance of <code>T</code> with respect to <code>Bar</code> affects the
variance <code>T</code> with respect to <code>Foo</code>. I claim no.  The reason: assume that <code>T</code> is
invariant with respect to <code>Bar</code> but covariant with respect to <code>Foo</code>. And then
we have a <code>Foo&lt;X&gt;</code> that is upcast to <code>Foo&lt;Y&gt;</code>, where <code>X &lt;: Y</code>. However, while
<code>X : Bar</code>, <code>Y : Bar</code> does not hold.  In that case, the upcast will be illegal,
but not because of a variance failure, but rather because the target type
<code>Foo&lt;Y&gt;</code> is itself just not well-formed. Basically we get to assume
well-formedness of all types involved before considering variance.</p>
<a class="header" href="print.html#dependency-graph-management" id="dependency-graph-management"><h3>Dependency graph management</h3></a>
<p>Because variance is a whole-crate inference, its dependency graph
can become quite muddled if we are not careful. To resolve this, we refactor
into two queries:</p>
<ul>
<li><code>crate_variances</code> computes the variance for all items in the current crate.</li>
<li><code>variances_of</code> accesses the variance for an individual reading; it
works by requesting <code>crate_variances</code> and extracting the relevant data.</li>
</ul>
<p>If you limit yourself to reading <code>variances_of</code>, your code will only
depend then on the inference of that particular item.</p>
<p>Ultimately, this setup relies on the <a href="./incremental-compilation.html">red-green algorithm</a>. In particular,
every variance query effectively depends on all type definitions in the entire
crate (through <code>crate_variances</code>), but since most changes will not result in a
change to the actual results from variance inference, the <code>variances_of</code> query
will wind up being considered green after it is re-evaluated.</p>
<p><a name="addendum"></a></p>
<a class="header" href="print.html#addendum-variance-on-traits" id="addendum-variance-on-traits"><h2>Addendum: Variance on traits</h2></a>
<p>As mentioned above, we used to permit variance on traits. This was
computed based on the appearance of trait type parameters in
method signatures and was used to represent the compatibility of
vtables in trait objects (and also &quot;virtual&quot; vtables or dictionary
in trait bounds). One complication was that variance for
associated types is less obvious, since they can be projected out
and put to myriad uses, so it's not clear when it is safe to allow
<code>X&lt;A&gt;::Bar</code> to vary (or indeed just what that means). Moreover (as
covered below) all inputs on any trait with an associated type had
to be invariant, limiting the applicability. Finally, the
annotations (<code>MarkerTrait</code>, <code>PhantomFn</code>) needed to ensure that all
trait type parameters had a variance were confusing and annoying
for little benefit.</p>
<p>Just for historical reference, I am going to preserve some text indicating how
one could interpret variance and trait matching.</p>
<a class="header" href="print.html#variance-and-object-types" id="variance-and-object-types"><h3>Variance and object types</h3></a>
<p>Just as with structs and enums, we can decide the subtyping
relationship between two object types <code>&amp;Trait&lt;A&gt;</code> and <code>&amp;Trait&lt;B&gt;</code>
based on the relationship of <code>A</code> and <code>B</code>. Note that for object
types we ignore the <code>Self</code> type parameter -- it is unknown, and
the nature of dynamic dispatch ensures that we will always call a
function that is expected the appropriate <code>Self</code> type. However, we
must be careful with the other type parameters, or else we could
end up calling a function that is expecting one type but provided
another.</p>
<p>To see what I mean, consider a trait like so:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait ConvertTo&lt;A&gt; {
    fn convertTo(&amp;self) -&gt; A;
}
#}</code></pre></pre>
<p>Intuitively, If we had one object <code>O=&amp;ConvertTo&lt;Object&gt;</code> and another
<code>S=&amp;ConvertTo&lt;String&gt;</code>, then <code>S &lt;: O</code> because <code>String &lt;: Object</code>
(presuming Java-like &quot;string&quot; and &quot;object&quot; types, my go to examples
for subtyping). The actual algorithm would be to compare the
(explicit) type parameters pairwise respecting their variance: here,
the type parameter A is covariant (it appears only in a return
position), and hence we require that <code>String &lt;: Object</code>.</p>
<p>You'll note though that we did not consider the binding for the
(implicit) <code>Self</code> type parameter: in fact, it is unknown, so that's
good. The reason we can ignore that parameter is precisely because we
don't need to know its value until a call occurs, and at that time (as
you said) the dynamic nature of virtual dispatch means the code we run
will be correct for whatever value <code>Self</code> happens to be bound to for
the particular object whose method we called. <code>Self</code> is thus different
from <code>A</code>, because the caller requires that <code>A</code> be known in order to
know the return type of the method <code>convertTo()</code>. (As an aside, we
have rules preventing methods where <code>Self</code> appears outside of the
receiver position from being called via an object.)</p>
<a class="header" href="print.html#trait-variance-and-vtable-resolution" id="trait-variance-and-vtable-resolution"><h3>Trait variance and vtable resolution</h3></a>
<p>But traits aren't only used with objects. They're also used when
deciding whether a given impl satisfies a given trait bound. To set the
scene here, imagine I had a function:</p>
<pre><code class="language-rust ignore">fn convertAll&lt;A,T:ConvertTo&lt;A&gt;&gt;(v: &amp;[T]) { ... }
</code></pre>
<p>Now imagine that I have an implementation of <code>ConvertTo</code> for <code>Object</code>:</p>
<pre><code class="language-rust ignore">impl ConvertTo&lt;i32&gt; for Object { ... }
</code></pre>
<p>And I want to call <code>convertAll</code> on an array of strings. Suppose
further that for whatever reason I specifically supply the value of
<code>String</code> for the type parameter <code>T</code>:</p>
<pre><code class="language-rust ignore">let mut vector = vec![&quot;string&quot;, ...];
convertAll::&lt;i32, String&gt;(vector);
</code></pre>
<p>Is this legal? To put another way, can we apply the <code>impl</code> for
<code>Object</code> to the type <code>String</code>? The answer is yes, but to see why
we have to expand out what will happen:</p>
<ul>
<li>
<p><code>convertAll</code> will create a pointer to one of the entries in the
vector, which will have type <code>&amp;String</code></p>
</li>
<li>
<p>It will then call the impl of <code>convertTo()</code> that is intended
for use with objects. This has the type <code>fn(self: &amp;Object) -&gt; i32</code>.</p>
<p>It is OK to provide a value for <code>self</code> of type <code>&amp;String</code> because
<code>&amp;String &lt;: &amp;Object</code>.</p>
</li>
</ul>
<p>OK, so intuitively we want this to be legal, so let's bring this back
to variance and see whether we are computing the correct result. We
must first figure out how to phrase the question &quot;is an impl for
<code>Object,i32</code> usable where an impl for <code>String,i32</code> is expected?&quot;</p>
<p>Maybe it's helpful to think of a dictionary-passing implementation of
type classes. In that case, <code>convertAll()</code> takes an implicit parameter
representing the impl. In short, we <em>have</em> an impl of type:</p>
<pre><code class="language-text">V_O = ConvertTo&lt;i32&gt; for Object
</code></pre>
<p>and the function prototype expects an impl of type:</p>
<pre><code class="language-text">V_S = ConvertTo&lt;i32&gt; for String
</code></pre>
<p>As with any argument, this is legal if the type of the value given
(<code>V_O</code>) is a subtype of the type expected (<code>V_S</code>). So is <code>V_O &lt;: V_S</code>?
The answer will depend on the variance of the various parameters. In
this case, because the <code>Self</code> parameter is contravariant and <code>A</code> is
covariant, it means that:</p>
<pre><code class="language-text">V_O &lt;: V_S iff
    i32 &lt;: i32
    String &lt;: Object
</code></pre>
<p>These conditions are satisfied and so we are happy.</p>
<a class="header" href="print.html#variance-and-associated-types" id="variance-and-associated-types"><h3>Variance and associated types</h3></a>
<p>Traits with associated types -- or at minimum projection
expressions -- must be invariant with respect to all of their
inputs. To see why this makes sense, consider what subtyping for a
trait reference means:</p>
<pre><code class="language-text">&lt;T as Trait&gt; &lt;: &lt;U as Trait&gt;
</code></pre>
<p>means that if I know that <code>T as Trait</code>, I also know that <code>U as Trait</code>. Moreover, if you think of it as dictionary passing style,
it means that a dictionary for <code>&lt;T as Trait&gt;</code> is safe to use where
a dictionary for <code>&lt;U as Trait&gt;</code> is expected.</p>
<p>The problem is that when you can project types out from <code>&lt;T as Trait&gt;</code>, the relationship to types projected out of <code>&lt;U as Trait&gt;</code>
is completely unknown unless <code>T==U</code> (see #21726 for more
details). Making <code>Trait</code> invariant ensures that this is true.</p>
<p>Another related reason is that if we didn't make traits with
associated types invariant, then projection is no longer a
function with a single result. Consider:</p>
<pre><code class="language-rust ignore">trait Identity { type Out; fn foo(&amp;self); }
impl&lt;T&gt; Identity for T { type Out = T; ... }
</code></pre>
<p>Now if I have <code>&lt;&amp;'static () as Identity&gt;::Out</code>, this can be
validly derived as <code>&amp;'a ()</code> for any <code>'a</code>:</p>
<pre><code class="language-text">&lt;&amp;'a () as Identity&gt; &lt;: &lt;&amp;'static () as Identity&gt;
if &amp;'static () &lt; : &amp;'a ()   -- Identity is contravariant in Self
if 'static : 'a             -- Subtyping rules for relations
</code></pre>
<p>This change otoh means that <code>&lt;'static () as Identity&gt;::Out</code> is
always <code>&amp;'static ()</code> (which might then be upcast to <code>'a ()</code>,
separately). This was helpful in solving #21750.</p>
<a class="header" href="print.html#the-mir-mid-level-ir" id="the-mir-mid-level-ir"><h1>The MIR (Mid-level IR)</h1></a>
<p>MIR is Rust's <em>Mid-level Intermediate Representation</em>. It is
constructed from <a href="./hir.html">HIR</a>. MIR was introduced in
<a href="http://rust-lang.github.io/rfcs/1211-mir.html">RFC 1211</a>. It is a radically simplified form of Rust that is used for
certain flow-sensitive safety checks -- notably the borrow checker! --
and also for optimization and code generation.</p>
<p>If you'd like a very high-level introduction to MIR, as well as some
of the compiler concepts that it relies on (such as control-flow
graphs and desugaring), you may enjoy the
<a href="https://blog.rust-lang.org/2016/04/19/MIR.html">rust-lang blog post that introduced MIR</a>.</p>
<a class="header" href="print.html#introduction-to-mir" id="introduction-to-mir"><h2>Introduction to MIR</h2></a>
<p>MIR is defined in the <a href="https://github.com/rust-lang/rust/tree/master/src/librustc/mir"><code>src/librustc/mir/</code></a> module, but much of the code
that manipulates it is found in <a href="https://github.com/rust-lang/rust/tree/master/src/librustc_mir"><code>src/librustc_mir</code></a>.</p>
<p>Some of the key characteristics of MIR are:</p>
<ul>
<li>It is based on a <a href="./appendix/background.html#cfg">control-flow graph</a>.</li>
<li>It does not have nested expressions.</li>
<li>All types in MIR are fully explicit.</li>
</ul>
<a class="header" href="print.html#key-mir-vocabulary" id="key-mir-vocabulary"><h2>Key MIR vocabulary</h2></a>
<p>This section introduces the key concepts of MIR, summarized here:</p>
<ul>
<li><strong>Basic blocks</strong>: units of the control-flow graph, consisting of:
<ul>
<li><strong>statements:</strong> actions with one successor</li>
<li><strong>terminators:</strong> actions with potentially multiple successors; always at
the end of a block</li>
<li>(if you're not familiar with the term <em>basic block</em>, see the <a href="./appendix/background.html#cfg">background
chapter</a>)</li>
</ul>
</li>
<li><strong>Locals:</strong> Memory locations alloated on the stack (conceptually, at
least), such as function arguments, local variables, and
temporaries. These are identified by an index, written with a
leading underscore, like <code>_1</code>. There is also a special &quot;local&quot;
(<code>_0</code>) allocated to store the return value.</li>
<li><strong>Places:</strong> expressions that identify a location in memory, like <code>_1</code> or
<code>_1.f</code>.</li>
<li><strong>Rvalues:</strong> expressions that produce a value. The &quot;R&quot; stands for
the fact that these are the &quot;right-hand side&quot; of an assignment.
<ul>
<li><strong>Operands:</strong> the arguments to an rvalue, which can either be a
constant (like <code>22</code>) or a place (like <code>_1</code>).</li>
</ul>
</li>
</ul>
<p>You can get a feeling for how MIR is structed by translating simple
programs into MIR and reading the pretty printed output. In fact, the
playground makes this easy, since it supplies a MIR button that will
show you the MIR for your program. Try putting this program into play
(or <a href="https://play.rust-lang.org/?gist=30074856e62e74e91f06abd19bd72ece&amp;version=stable">clicking on this link</a>), and then clicking the &quot;MIR&quot;
button on the top:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut vec = Vec::new();
    vec.push(1);
    vec.push(2);
}
</code></pre></pre>
<p>You should see something like:</p>
<pre><code class="language-mir">// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn main() -&gt; () {
    ...
}
</code></pre>
<p>This is the MIR format for the <code>main</code> function.</p>
<p><strong>Variable declarations.</strong> If we drill in a bit, we'll see it begins
with a bunch of variable declarations. They look like this:</p>
<pre><code class="language-mir">let mut _0: ();                      // return place
scope 1 {
    let mut _1: std::vec::Vec&lt;i32&gt;;  // &quot;vec&quot; in scope 1 at src/main.rs:2:9: 2:16
}
scope 2 {
}
let mut _2: ();
let mut _3: &amp;mut std::vec::Vec&lt;i32&gt;;
let mut _4: ();
let mut _5: &amp;mut std::vec::Vec&lt;i32&gt;;
</code></pre>
<p>You can see that variables in MIR don't have names, they have indices,
like <code>_0</code> or <code>_1</code>.  We also intermingle the user's variables (e.g.,
<code>_1</code>) with temporary values (e.g., <code>_2</code> or <code>_3</code>). You can tell the
difference between user-defined variables have a comment that gives
you their original name (<code>// &quot;vec&quot; in scope 1...</code>). The &quot;scope&quot; blocks
(e.g., <code>scope 1 { .. }</code>) describe the lexical structure of the source
program (which names were in scope when).</p>
<p><strong>Basic blocks.</strong> Reading further, we see our first <strong>basic block</strong> (naturally
it may look slightly different when you view it, and I am ignoring some of the
comments):</p>
<pre><code class="language-mir">bb0: {
    StorageLive(_1);
    _1 = const &lt;std::vec::Vec&lt;T&gt;&gt;::new() -&gt; bb2;
}
</code></pre>
<p>A basic block is defined by a series of <strong>statements</strong> and a final
<strong>terminator</strong>.  In this case, there is one statement:</p>
<pre><code class="language-mir">StorageLive(_1);
</code></pre>
<p>This statement indicates that the variable <code>_1</code> is &quot;live&quot;, meaning
that it may be used later -- this will persist until we encounter a
<code>StorageDead(_1)</code> statement, which indicates that the variable <code>_1</code> is
done being used. These &quot;storage statements&quot; are used by LLVM to
allocate stack space.</p>
<p>The <strong>terminator</strong> of the block <code>bb0</code> is the call to <code>Vec::new</code>:</p>
<pre><code class="language-mir">_1 = const &lt;std::vec::Vec&lt;T&gt;&gt;::new() -&gt; bb2;
</code></pre>
<p>Terminators are different from statements because they can have more
than one successor -- that is, control may flow to different
places. Function calls like the call to <code>Vec::new</code> are always
terminators because of the possibility of unwinding, although in the
case of <code>Vec::new</code> we are able to see that indeed unwinding is not
possible, and hence we list only one succssor block, <code>bb2</code>.</p>
<p>If we look ahead to <code>bb2</code>, we will see it looks like this:</p>
<pre><code class="language-mir">bb2: {
    StorageLive(_3);
    _3 = &amp;mut _1;
    _2 = const &lt;std::vec::Vec&lt;T&gt;&gt;::push(move _3, const 1i32) -&gt; [return: bb3, unwind: bb4];
}
</code></pre>
<p>Here there are two statements: another <code>StorageLive</code>, introducing the <code>_3</code>
temporary, and then an assignment:</p>
<pre><code class="language-mir">_3 = &amp;mut _1;
</code></pre>
<p>Assignments in general have the form:</p>
<pre><code class="language-text">&lt;Place&gt; = &lt;Rvalue&gt;
</code></pre>
<p>A place is an expression like <code>_3</code>, <code>_3.f</code> or <code>*_3</code> -- it denotes a
location in memory.  An <strong>Rvalue</strong> is an expression that creates a
value: in this case, the rvalue is a mutable borrow expression, which
looks like <code>&amp;mut &lt;Place&gt;</code>. So we can kind of define a grammar for
rvalues like so:</p>
<pre><code class="language-text">&lt;Rvalue&gt;  = &amp; (mut)? &lt;Place&gt;
          | &lt;Operand&gt; + &lt;Operand&gt;
          | &lt;Operand&gt; - &lt;Operand&gt;
          | ...

&lt;Operand&gt; = Constant
          | copy Place
          | move Place
</code></pre>
<p>As you can see from this grammar, rvalues cannot be nested -- they can
only reference places and constants. Moreover, when you use a place,
we indicate whether we are <strong>copying it</strong> (which requires that the
place have a type <code>T</code> where <code>T: Copy</code>) or <strong>moving it</strong> (which works
for a place of any type). So, for example, if we had the expression <code>x = a + b + c</code> in Rust, that would get compile to two statements and a
temporary:</p>
<pre><code class="language-mir">TMP1 = a + b
x = TMP1 + c
</code></pre>
<p>(<a href="https://play.rust-lang.org/?gist=1751196d63b2a71f8208119e59d8a5b6&amp;version=stable">Try it and see</a>, though you may want to do release mode to skip
over the overflow checks.)</p>
<a class="header" href="print.html#mir-data-types" id="mir-data-types"><h2>MIR data types</h2></a>
<p>The MIR data types are defined in the <a href="https://github.com/rust-lang/rust/tree/master/src/librustc/mir"><code>src/librustc/mir/</code></a>
module.  Each of the key concepts mentioned in the previous section
maps in a fairly straightforward way to a Rust type.</p>
<p>The main MIR data type is <code>Mir</code>. It contains the data for a single
function (along with sub-instances of Mir for &quot;promoted constants&quot;,
but <a href="print.html#promoted">you can read about those below</a>).</p>
<ul>
<li><strong>Basic blocks</strong>: The basic blocks are stored in the field
<code>basic_blocks</code>; this is a vector of <code>BasicBlockData</code>
structures. Nobody ever references a basic block directly: instead,
we pass around <code>BasicBlock</code> values, which are
<a href="appendix/glossary.html">newtype'd</a> indices into this vector.</li>
<li><strong>Statements</strong> are represented by the type <code>Statement</code>.</li>
<li><strong>Terminators</strong> are represented by the <code>Terminator</code>.</li>
<li><strong>Locals</strong> are represented by a <a href="appendix/glossary.html">newtype'd</a> index type <code>Local</code>. The
data for a local variable is found in the <code>Mir</code> (the <code>local_decls</code>
vector). There is also a special constant <code>RETURN_PLACE</code> identifying
the special &quot;local&quot; representing the return value.</li>
<li><strong>Places</strong> are identified by the enum <code>Place</code>. There are a few variants:
<ul>
<li>Local variables like <code>_1</code></li>
<li>Static variables <code>FOO</code></li>
<li><strong>Projections</strong>, which are fields or other things that &quot;project
out&quot; from a base place. So e.g. the place <code>_1.f</code> is a projection,
with <code>f</code> being the &quot;projection element and <code>_1</code> being the base
path. <code>*_1</code> is also a projection, with the <code>*</code> being represented
by the <code>ProjectionElem::Deref</code> element.</li>
</ul>
</li>
<li><strong>Rvalues</strong> are represented by the enum <code>Rvalue</code>.</li>
<li><strong>Operands</strong> are represented by the enum <code>Operand</code>.</li>
</ul>
<a class="header" href="print.html#representing-constants" id="representing-constants"><h2>Representing constants</h2></a>
<p><em>to be written</em></p>
<p><a name="promoted"></a></p>
<a class="header" href="print.html#promoted-constants" id="promoted-constants"><h3>Promoted constants</h3></a>
<p><em>to be written</em></p>
<a class="header" href="print.html#mir-construction" id="mir-construction"><h1>MIR construction</h1></a>
<a class="header" href="print.html#mir-visitor" id="mir-visitor"><h1>MIR visitor</h1></a>
<p>The MIR visitor is a convenient tool for traversing the MIR and either
looking for things or making changes to it. The visitor traits are
defined in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/mir/visit/index.html">the <code>rustc::mir::visit</code> module</a> -- there are two of
them, generated via a single macro: <code>Visitor</code> (which operates on a
<code>&amp;Mir</code> and gives back shared references) and <code>MutVisitor</code> (which
operates on a <code>&amp;mut Mir</code> and gives back mutable references).</p>
<p>To implement a visitor, you have to create a type that represents
your visitor. Typically, this type wants to &quot;hang on&quot; to whatever
state you will need while processing MIR:</p>
<pre><code class="language-rust ignore">struct MyVisitor&lt;...&gt; {
    tcx: TyCtxt&lt;'cx, 'tcx, 'tcx&gt;,
    ...
}
</code></pre>
<p>and you then implement the <code>Visitor</code> or <code>MutVisitor</code> trait for that type:</p>
<pre><code class="language-rust ignore">impl&lt;'tcx&gt; MutVisitor&lt;'tcx&gt; for NoLandingPads {
    fn visit_foo(&amp;mut self, ...) {
        ...
        self.super_foo(...);
    }
}
</code></pre>
<p>As shown above, within the impl, you can override any of the
<code>visit_foo</code> methods (e.g., <code>visit_terminator</code>) in order to write some
code that will execute whenever a <code>foo</code> is found. If you want to
recursively walk the contents of the <code>foo</code>, you then invoke the
<code>super_foo</code> method. (NB. You never want to override <code>super_foo</code>.)</p>
<p>A very simple example of a visitor can be found in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/transform/no_landing_pads/struct.NoLandingPads.html"><code>NoLandingPads</code></a>.
That visitor doesn't even require any state: it just visits all
terminators and removes their <code>unwind</code> successors.</p>
<a class="header" href="print.html#traversal" id="traversal"><h2>Traversal</h2></a>
<p>In addition the visitor, <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/mir/traversal/index.html">the <code>rustc::mir::traversal</code> module</a>
contains useful functions for walking the MIR CFG in
<a href="https://en.wikipedia.org/wiki/Tree_traversal">different standard orders</a> (e.g. pre-order, reverse
post-order, and so forth).</p>
<a class="header" href="print.html#mir-passes" id="mir-passes"><h1>MIR passes</h1></a>
<p>If you would like to get the MIR for a function (or constant, etc),
you can use the <code>optimized_mir(def_id)</code> query. This will give you back
the final, optimized MIR. For foreign def-ids, we simply read the MIR
from the other crate's metadata. But for local def-ids, the query will
construct the MIR and then iteratively optimize it by applying a
series of passes. This section describes how those passes work and how
you can extend them.</p>
<p>To produce the <code>optimized_mir(D)</code> for a given def-id <code>D</code>, the MIR
passes through several suites of optimizations, each represented by a
query. Each suite consists of multiple optimizations and
transformations. These suites represent useful intermediate points
where we want to access the MIR for type checking or other purposes:</p>
<ul>
<li><code>mir_build(D)</code> – not a query, but this constructs the initial MIR</li>
<li><code>mir_const(D)</code> – applies some simple transformations to make MIR ready for
constant evaluation;</li>
<li><code>mir_validated(D)</code> – applies some more transformations, making MIR ready for
borrow checking;</li>
<li><code>optimized_mir(D)</code> – the final state, after all optimizations have been
performed.</li>
</ul>
<a class="header" href="print.html#seeing-how-the-mir-changes-as-the-compiler-executes" id="seeing-how-the-mir-changes-as-the-compiler-executes"><h3>Seeing how the MIR changes as the compiler executes</h3></a>
<p><code>-Zdump-mir=F</code> is a handy compiler options that will let you view the MIR for
each function at each stage of compilation. <code>-Zdump-mir</code> takes a <strong>filter</strong> <code>F</code>
which allows you to control which functions and which passes you are
interesting in. For example:</p>
<pre><code class="language-bash">&gt; rustc -Zdump-mir=foo ...
</code></pre>
<p>This will dump the MIR for any function whose name contains <code>foo</code>; it
will dump the MIR both before and after every pass. Those files will
be created in the <code>mir_dump</code> directory. There will likely be quite a
lot of them!</p>
<pre><code class="language-bash">&gt; cat &gt; foo.rs
fn main() {
    println!(&quot;Hello, world!&quot;);
}
^D
&gt; rustc -Zdump-mir=main foo.rs
&gt; ls mir_dump/* | wc -l
     161
</code></pre>
<p>The files have names like <code>rustc.main.000-000.CleanEndRegions.after.mir</code>. These
names have a number of parts:</p>
<pre><code class="language-text">rustc.main.000-000.CleanEndRegions.after.mir
      ---- --- --- --------------- ----- either before or after
      |    |   |   name of the pass
      |    |   index of dump within the pass (usually 0, but some passes dump intermediate states)
      |    index of the pass
      def-path to the function etc being dumped
</code></pre>
<p>You can also make more selective filters. For example, <code>main &amp; CleanEndRegions</code>
will select for things that reference <em>both</em> <code>main</code> and the pass
<code>CleanEndRegions</code>:</p>
<pre><code class="language-bash">&gt; rustc -Zdump-mir='main &amp; CleanEndRegions' foo.rs
&gt; ls mir_dump
rustc.main.000-000.CleanEndRegions.after.mir	rustc.main.000-000.CleanEndRegions.before.mir
</code></pre>
<p>Filters can also have <code>|</code> parts to combine multiple sets of
<code>&amp;</code>-filters. For example <code>main &amp; CleanEndRegions | main &amp; NoLandingPads</code> will select <em>either</em> <code>main</code> and <code>CleanEndRegions</code> <em>or</em>
<code>main</code> and <code>NoLandingPads</code>:</p>
<pre><code class="language-bash">&gt; rustc -Zdump-mir='main &amp; CleanEndRegions | main &amp; NoLandingPads' foo.rs
&gt; ls mir_dump
rustc.main-promoted[0].002-000.NoLandingPads.after.mir
rustc.main-promoted[0].002-000.NoLandingPads.before.mir
rustc.main-promoted[0].002-006.NoLandingPads.after.mir
rustc.main-promoted[0].002-006.NoLandingPads.before.mir
rustc.main-promoted[1].002-000.NoLandingPads.after.mir
rustc.main-promoted[1].002-000.NoLandingPads.before.mir
rustc.main-promoted[1].002-006.NoLandingPads.after.mir
rustc.main-promoted[1].002-006.NoLandingPads.before.mir
rustc.main.000-000.CleanEndRegions.after.mir
rustc.main.000-000.CleanEndRegions.before.mir
rustc.main.002-000.NoLandingPads.after.mir
rustc.main.002-000.NoLandingPads.before.mir
rustc.main.002-006.NoLandingPads.after.mir
rustc.main.002-006.NoLandingPads.before.mir
</code></pre>
<p>(Here, the <code>main-promoted[0]</code> files refer to the MIR for &quot;promoted constants&quot;
that appeared within the <code>main</code> function.)</p>
<a class="header" href="print.html#implementing-and-registering-a-pass" id="implementing-and-registering-a-pass"><h3>Implementing and registering a pass</h3></a>
<p>A <code>MirPass</code> is some bit of code that processes the MIR, typically --
but not always -- transforming it along the way somehow. For example,
it might perform an optimization. The <code>MirPass</code> trait itself is found
in in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/transform/">the <code>rustc_mir::transform</code> module</a>, and it
basically consists of one method, <code>run_pass</code>, that simply gets an
<code>&amp;mut Mir</code> (along with the tcx and some information about where it
came from). The MIR is therefore modified in place (which helps to
keep things efficient).</p>
<p>A good example of a basic MIR pass is <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/transform/no_landing_pads/struct.NoLandingPads.html"><code>NoLandingPads</code></a>, which walks
the MIR and removes all edges that are due to unwinding -- this is
used when configured with <code>panic=abort</code>, which never unwinds. As you
can see from its source, a MIR pass is defined by first defining a
dummy type, a struct with no fields, something like:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct MyPass;
#}</code></pre></pre>
<p>for which you then implement the <code>MirPass</code> trait. You can then insert
this pass into the appropriate list of passes found in a query like
<code>optimized_mir</code>, <code>mir_validated</code>, etc. (If this is an optimization, it
should go into the <code>optimized_mir</code> list.)</p>
<p>If you are writing a pass, there's a good chance that you are going to
want to use a <a href="mir/visitor.html">MIR visitor</a>. MIR visitors are a handy way to walk all
the parts of the MIR, either to search for something or to make small
edits.</p>
<a class="header" href="print.html#stealing" id="stealing"><h3>Stealing</h3></a>
<p>The intermediate queries <code>mir_const()</code> and <code>mir_validated()</code> yield up
a <code>&amp;'tcx Steal&lt;Mir&lt;'tcx&gt;&gt;</code>, allocated using
<code>tcx.alloc_steal_mir()</code>. This indicates that the result may be
<strong>stolen</strong> by the next suite of optimizations – this is an
optimization to avoid cloning the MIR. Attempting to use a stolen
result will cause a panic in the compiler. Therefore, it is important
that you do not read directly from these intermediate queries except as
part of the MIR processing pipeline.</p>
<p>Because of this stealing mechanism, some care must also be taken to
ensure that, before the MIR at a particular phase in the processing
pipeline is stolen, anyone who may want to read from it has already
done so. Concretely, this means that if you have some query <code>foo(D)</code>
that wants to access the result of <code>mir_const(D)</code> or
<code>mir_validated(D)</code>, you need to have the successor pass &quot;force&quot;
<code>foo(D)</code> using <code>ty::queries::foo::force(...)</code>. This will force a query
to execute even though you don't directly require its result.</p>
<p>As an example, consider MIR const qualification. It wants to read the
result produced by the <code>mir_const()</code> suite. However, that result will
be <strong>stolen</strong> by the <code>mir_validated()</code> suite. If nothing was done,
then <code>mir_const_qualif(D)</code> would succeed if it came before
<code>mir_validated(D)</code>, but fail otherwise. Therefore, <code>mir_validated(D)</code>
will <strong>force</strong> <code>mir_const_qualif</code> before it actually steals, thus
ensuring that the reads have already happened (remember that
<a href="./query.html">queries are memoized</a>, so executing a query twice
simply loads from a cache the second time):</p>
<pre><code class="language-text">mir_const(D) --read-by--&gt; mir_const_qualif(D)
     |                       ^
  stolen-by                  |
     |                    (forces)
     v                       |
mir_validated(D) ------------+
</code></pre>
<p>This mechanism is a bit dodgy. There is a discussion of more elegant
alternatives in <a href="https://github.com/rust-lang/rust/issues/41710">rust-lang/rust#41710</a>.</p>
<a class="header" href="print.html#mir-borrow-check" id="mir-borrow-check"><h1>MIR borrow check</h1></a>
<p>The borrow check is Rust's &quot;secret sauce&quot; -- it is tasked with
enforcing a number of properties:</p>
<ul>
<li>That all variables are initialized before they are used.</li>
<li>That you can't move the same value twice.</li>
<li>That you can't move a value while it is borrowed.</li>
<li>That you can't access a place while it is mutably borrowed (except through
the reference).</li>
<li>That you can't mutate a place while it is shared borrowed.</li>
<li>etc</li>
</ul>
<p>At the time of this writing, the code is in a state of transition. The
&quot;main&quot; borrow checker still works by processing <a href="hir.html">the HIR</a>,
but that is being phased out in favor of the MIR-based borrow checker.
Doing borrow checking on MIR has two key advantages:</p>
<ul>
<li>The MIR is <em>far</em> less complex than the HIR; the radical desugaring
helps prevent bugs in the borrow checker. (If you're curious, you
can see
<a href="https://github.com/rust-lang/rust/issues/47366">a list of bugs that the MIR-based borrow checker fixes here</a>.)</li>
<li>Even more importantly, using the MIR enables <a href="http://rust-lang.github.io/rfcs/2094-nll.html">&quot;non-lexical lifetimes&quot;</a>,
which are regions derived from the control-flow graph.</li>
</ul>
<a class="header" href="print.html#major-phases-of-the-borrow-checker" id="major-phases-of-the-borrow-checker"><h3>Major phases of the borrow checker</h3></a>
<p>The borrow checker source is found in
<a href="https://github.com/rust-lang/rust/tree/master/src/librustc_mir/borrow_check">the <code>rustc_mir::borrow_check</code> module</a>. The main entry point is
the <code>mir_borrowck</code> query. At the time of this writing, MIR borrowck can operate
in several modes, but this text will describe only the mode when NLL is enabled
(what you get with <code>#![feature(nll)]</code>).</p>
<p>The overall flow of the borrow checker is as follows:</p>
<ul>
<li>We first create a <strong>local copy</strong> C of the MIR. In the coming steps,
we will modify this copy in place to modify the types and things to
include references to the new regions that we are computing.</li>
<li>We then invoke <code>nll::replace_regions_in_mir</code> to modify this copy C.
Among other things, this function will replace all of the regions in
the MIR with fresh <a href="./appendix/glossary.html">inference variables</a>.
<ul>
<li>(More details can be found in <a href="./mir/regionck.html">the regionck section</a>.)</li>
</ul>
</li>
<li>Next, we perform a number of <a href="./appendix/background.html#dataflow">dataflow
analyses</a>
that compute what data is moved and when. The results of these analyses
are needed to do both borrow checking and region inference.</li>
<li>Using the move data, we can then compute the values of all the regions in the
MIR.
<ul>
<li>(More details can be found in <a href="./mir/regionck.html">the NLL section</a>.)</li>
</ul>
</li>
<li>Finally, the borrow checker itself runs, taking as input (a) the
results of move analysis and (b) the regions computed by the region
checker. This allows us to figure out which loans are still in scope
at any particular point.</li>
</ul>
<a class="header" href="print.html#mir-based-region-checking-nll" id="mir-based-region-checking-nll"><h1>MIR-based region checking (NLL)</h1></a>
<p>The MIR-based region checking code is located in
<a href="https://github.com/rust-lang/rust/tree/master/src/librustc_mir/borrow_check/nll">the <code>rustc_mir::borrow_check::nll</code> module</a>. (NLL, of course,
stands for &quot;non-lexical lifetimes&quot;, a term that will hopefully be
deprecated once they become the standard kind of lifetime.)</p>
<p>The MIR-based region analysis consists of two major functions:</p>
<ul>
<li><code>replace_regions_in_mir</code>, invoked first, has two jobs:
<ul>
<li>First, it finds the set of regions that appear within the
signature of the function (e.g., <code>'a</code> in <code>fn foo&lt;'a&gt;(&amp;'a u32) { ... }</code>). These are called the &quot;universal&quot; or &quot;free&quot; regions -- in
particular, they are the regions that <a href="appendix/background.html#free-vs-bound">appear free</a> in the
function body.</li>
<li>Second, it replaces all the regions from the function body with
fresh inference variables. This is because (presently) those
regions are the results of lexical region inference and hence are
not of much interest. The intention is that -- eventually -- they
will be &quot;erased regions&quot; (i.e., no information at all), since we
won't be doing lexical region inference at all.</li>
</ul>
</li>
<li><code>compute_regions</code>, invoked second: this is given as argument the
results of move analysis. It has the job of computing values for all
the inference variabes that <code>replace_regions_in_mir</code> introduced.
<ul>
<li>To do that, it first runs the <a href="print.html#mirtypeck">MIR type checker</a>. This
is basically a normal type-checker but specialized to MIR, which
is much simpler than full Rust of course. Running the MIR type
checker will however create <strong>outlives constraints</strong> between
region variables (e.g., that one variable must outlive another
one) to reflect the subtyping relationships that arise.</li>
<li>It also adds <strong>liveness constraints</strong> that arise from where variables
are used.</li>
<li>More details to come, though the <a href="http://rust-lang.github.io/rfcs/2094-nll.html">NLL RFC</a> also includes fairly thorough
(and hopefully readable) coverage.</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#universal-regions" id="universal-regions"><h2>Universal regions</h2></a>
<p><em>to be written</em> -- explain the <code>UniversalRegions</code> type</p>
<a class="header" href="print.html#region-variables-and-constraints" id="region-variables-and-constraints"><h2>Region variables and constraints</h2></a>
<p><em>to be written</em> -- describe the <code>RegionInferenceContext</code> and
the role of <code>liveness_constraints</code> vs other <code>constraints</code>, plus</p>
<a class="header" href="print.html#closures" id="closures"><h2>Closures</h2></a>
<p><em>to be written</em></p>
<p><a name="mirtypeck"></a></p>
<a class="header" href="print.html#the-mir-type-check" id="the-mir-type-check"><h2>The MIR type-check</h2></a>
<a class="header" href="print.html#representing-the-values-of-a-region-variable" id="representing-the-values-of-a-region-variable"><h2>Representing the &quot;values&quot; of a region variable</h2></a>
<p>The value of a region can be thought of as a <strong>set</strong>; we call the
domain of this set a <code>RegionElement</code>. In the code, the value for all
regions is maintained in
<a href="https://github.com/rust-lang/rust/tree/master/src/librustc_mir/borrow_check/nll/region_infer/">the <code>rustc_mir::borrow_check::nll::region_infer</code> module</a>. For
each region we maintain a set storing what elements are present in its
value (to make this efficient, we give each kind of element an index,
the <code>RegionElementIndex</code>, and use sparse bitsets).</p>
<p>The kinds of region elements are as follows:</p>
<ul>
<li>Each <strong>location</strong> in the MIR control-flow graph: a location is just
the pair of a basic block and an index. This identifies the point
<strong>on entry</strong> to the statement with that index (or the terminator, if
the index is equal to <code>statements.len()</code>).</li>
<li>There is an element <code>end('a)</code> for each universal region <code>'a</code>,
corresponding to some portion of the caller's (or caller's caller,
etc) control-flow graph.</li>
<li>Similarly, there is an element denoted <code>end('static)</code> corresponding
to the remainder of program execution after this function returns.</li>
<li>There is an element <code>!1</code> for each skolemized region <code>!1</code>. This
corresponds (intuitively) to some unknown set of other elements --
for details on skolemization, see the section
<a href="print.html#skol">skolemization and universes</a>.</li>
</ul>
<a class="header" href="print.html#causal-tracking" id="causal-tracking"><h2>Causal tracking</h2></a>
<p><em>to be written</em> -- describe how we can extend the values of a variable
with causal tracking etc</p>
<p><a name="skol"></a></p>
<a class="header" href="print.html#skolemization-and-universes" id="skolemization-and-universes"><h2>Skolemization and universes</h2></a>
<p>(This section describes ongoing work that hasn't landed yet.)</p>
<p>From time to time we have to reason about regions that we can't
concretely know. For example, consider this program:</p>
<pre><code class="language-rust ignore">// A function that needs a static reference
fn foo(x: &amp;'static u32) { }

fn bar(f: for&lt;'a&gt; fn(&amp;'a u32)) {
       // ^^^^^^^^^^^^^^^^^^^ a function that can accept **any** reference
    let x = 22;
    f(&amp;x);
}

fn main() {
    bar(foo);
}
</code></pre>
<p>This program ought not to type-check: <code>foo</code> needs a static reference
for its argument, and <code>bar</code> wants to be given a function that that
accepts <strong>any</strong> reference (so it can call it with something on its
stack, for example). But <em>how</em> do we reject it and <em>why</em>?</p>
<a class="header" href="print.html#subtyping-and-skolemization" id="subtyping-and-skolemization"><h3>Subtyping and skolemization</h3></a>
<p>When we type-check <code>main</code>, and in particular the call <code>bar(foo)</code>, we
are going to wind up with a subtyping relationship like this one:</p>
<pre><code class="language-text">fn(&amp;'static u32) &lt;: for&lt;'a&gt; fn(&amp;'a u32)
----------------    -------------------
the type of `foo`   the type `bar` expects
</code></pre>
<p>We handle this sort of subtyping by taking the variables that are
bound in the supertype and <strong>skolemizing</strong> them: this means that we
replace them with
<a href="appendix/background.html#quantified">universally quantified</a>
representatives, written like <code>!1</code>. We call these regions &quot;skolemized
regions&quot; -- they represent, basically, &quot;some unknown region&quot;.</p>
<p>Once we've done that replacement, we have the following relation:</p>
<pre><code class="language-text">fn(&amp;'static u32) &lt;: fn(&amp;'!1 u32)
</code></pre>
<p>The key idea here is that this unknown region <code>'!1</code> is not related to
any other regions. So if we can prove that the subtyping relationship
is true for <code>'!1</code>, then it ought to be true for any region, which is
what we wanted.</p>
<p>So let's work through what happens next. To check if two functions are
subtypes, we check if their arguments have the desired relationship
(fn arguments are <a href="./appendix/background.html#variance">contravariant</a>, so
we swap the left and right here):</p>
<pre><code class="language-text">&amp;'!1 u32 &lt;: &amp;'static u32
</code></pre>
<p>According to the basic subtyping rules for a reference, this will be
true if <code>'!1: 'static</code>. That is -- if &quot;some unknown region <code>!1</code>&quot; lives
outlives <code>'static</code>. Now, this <em>might</em> be true -- after all, <code>'!1</code>
could be <code>'static</code> -- but we don't <em>know</em> that it's true. So this
should yield up an error (eventually).</p>
<a class="header" href="print.html#what-is-a-universe" id="what-is-a-universe"><h3>What is a universe</h3></a>
<p>In the previous section, we introduced the idea of a skolemized
region, and we denoted it <code>!1</code>. We call this number <code>1</code> the <strong>universe
index</strong>. The idea of a &quot;universe&quot; is that it is a set of names that
are in scope within some type or at some point. Universes are formed
into a tree, where each child extends its parents with some new names.
So the <strong>root universe</strong> conceptually contains global names, such as
the the lifetime <code>'static</code> or the type <code>i32</code>. In the compiler, we also
put generic type parameters into this root universe (in this sense,
there is not just one root universe, but one per item). So consider
this function <code>bar</code>:</p>
<pre><code class="language-rust ignore">struct Foo { }

fn bar&lt;'a, T&gt;(t: &amp;'a T) {
    ...
}
</code></pre>
<p>Here, the root universe would consist of the lifetimes <code>'static</code> and
<code>'a</code>.  In fact, although we're focused on lifetimes here, we can apply
the same concept to types, in which case the types <code>Foo</code> and <code>T</code> would
be in the root universe (along with other global types, like <code>i32</code>).
Basically, the root universe contains all the names that
<a href="./appendix/background.html#free-vs-bound">appear free</a> in the body of <code>bar</code>.</p>
<p>Now let's extend <code>bar</code> a bit by adding a variable <code>x</code>:</p>
<pre><code class="language-rust ignore">fn bar&lt;'a, T&gt;(t: &amp;'a T) {
    let x: for&lt;'b&gt; fn(&amp;'b u32) = ...;
}
</code></pre>
<p>Here, the name <code>'b</code> is not part of the root universe. Instead, when we
&quot;enter&quot; into this <code>for&lt;'b&gt;</code> (e.g., by skolemizing it), we will create
a child universe of the root, let's call it U1:</p>
<pre><code class="language-text">U0 (root universe)
│
└─ U1 (child universe)
</code></pre>
<p>The idea is that this child universe U1 extends the root universe U0
with a new name, which we are identifying by its universe number:
<code>!1</code>.</p>
<p>Now let's extend <code>bar</code> a bit by adding one more variable, <code>y</code>:</p>
<pre><code class="language-rust ignore">fn bar&lt;'a, T&gt;(t: &amp;'a T) {
    let x: for&lt;'b&gt; fn(&amp;'b u32) = ...;
    let y: for&lt;'c&gt; fn(&amp;'b u32) = ...;
}
</code></pre>
<p>When we enter <em>this</em> type, we will again create a new universe, which
we'll call <code>U2</code>. Its parent will be the root universe, and U1 will be
its sibling:</p>
<pre><code class="language-text">U0 (root universe)
│
├─ U1 (child universe)
│
└─ U2 (child universe)
</code></pre>
<p>This implies that, while in U2, we can name things from U0 or U2, but
not U1.</p>
<p><strong>Giving existential variables a universe.</strong> Now that we have this
notion of universes, we can use it to extend our type-checker and
things to prevent illegal names from leaking out. The idea is that we
give each inference (existential) variable -- whether it be a type or
a lifetime -- a universe. That variable's value can then only
reference names visible from that universe. So for example is a
lifetime variable is created in U0, then it cannot be assigned a value
of <code>!1</code> or <code>!2</code>, because those names are not visible from the universe
U0.</p>
<p><strong>Representing universes with just a counter.</strong> You might be surprised
to see that the compiler doesn't keep track of a full tree of
universes. Instead, it just keeps a counter -- and, to determine if
one universe can see another one, it just checks if the index is
greater. For example, U2 can see U0 because 2 &gt;= 0. But U0 cannot see
U2, because 0 &gt;= 2 is false.</p>
<p>How can we get away with this? Doesn't this mean that we would allow
U2 to also see U1? The answer is that, yes, we would, <strong>if that
question ever arose</strong>.  But because of the structure of our type
checker etc, there is no way for that to happen. In order for
something happening in the universe U1 to &quot;communicate&quot; with something
happening in U2, they would have to have a shared inference variable X
in common. And because everything in U1 is scoped to just U1 and its
children, that inference variable X would have to be in U0. And since
X is in U0, it cannot name anything from U1 (or U2). This is perhaps easiest
to see by using a kind of generic &quot;logic&quot; example:</p>
<pre><code class="language-text">exists&lt;X&gt; {
   forall&lt;Y&gt; { ... /* Y is in U1 ... */ }
   forall&lt;Z&gt; { ... /* Z is in U2 ... */ }
}
</code></pre>
<p>Here, the only way for the two foralls to interact would be through X,
but neither Y nor Z are in scope when X is declared, so its value
cannot reference either of them.</p>
<a class="header" href="print.html#universes-and-skolemized-region-elements" id="universes-and-skolemized-region-elements"><h3>Universes and skolemized region elements</h3></a>
<p>But where does that error come from?  The way it happens is like this.
When we are constructing the region inference context, we can tell
from the type inference context how many skolemized variables exist
(the <code>InferCtxt</code> has an internal counter). For each of those, we
create a corresponding universal region variable <code>!n</code> and a &quot;region
element&quot; <code>skol(n)</code>. This corresponds to &quot;some unknown set of other
elements&quot;. The value of <code>!n</code> is <code>{skol(n)}</code>.</p>
<p>At the same time, we also give each existential variable a
<strong>universe</strong> (also taken from the <code>InferCtxt</code>). This universe
determines which skolemized elements may appear in its value: For
example, a variable in universe U3 may name <code>skol(1)</code>, <code>skol(2)</code>, and
<code>skol(3)</code>, but not <code>skol(4)</code>. Note that the universe of an inference
variable controls what region elements <strong>can</strong> appear in its value; it
does not say region elements <strong>will</strong> appear.</p>
<a class="header" href="print.html#skolemization-and-outlives-constraints" id="skolemization-and-outlives-constraints"><h3>Skolemization and outlives constraints</h3></a>
<p>In the region inference engine, outlives constraints have the form:</p>
<pre><code class="language-text">V1: V2 @ P
</code></pre>
<p>where <code>V1</code> and <code>V2</code> are region indices, and hence map to some region
variable (which may be universally or existentially quantified). The
<code>P</code> here is a &quot;point&quot; in the control-flow graph; it's not important
for this section. This variable will have a universe, so let's call
those universes <code>U(V1)</code> and <code>U(V2)</code> respectively. (Actually, the only
one we are going to care about is <code>U(V1)</code>.)</p>
<p>When we encounter this constraint, the ordinary procedure is to start
a DFS from <code>P</code>. We keep walking so long as the nodes we are walking
are present in <code>value(V2)</code> and we add those nodes to <code>value(V1)</code>. If
we reach a return point, we add in any <code>end(X)</code> elements. That part
remains unchanged.</p>
<p>But then <em>after that</em> we want to iterate over the skolemized <code>skol(x)</code>
elements in V2 (each of those must be visible to <code>U(V2)</code>, but we
should be able to just assume that is true, we don't have to check
it). We have to ensure that <code>value(V1)</code> outlives each of those
skolemized elements.</p>
<p>Now there are two ways that could happen. First, if <code>U(V1)</code> can see
the universe <code>x</code> (i.e., <code>x &lt;= U(V1)</code>), then we can just add <code>skol(x)</code>
to <code>value(V1)</code> and be done. But if not, then we have to approximate:
we may not know what set of elements <code>skol(x)</code> represents, but we
should be able to compute some sort of <strong>upper bound</strong> B for it --
some region B that outlives <code>skol(x)</code>. For now, we'll just use
<code>'static</code> for that (since it outlives everything) -- in the future, we
can sometimes be smarter here (and in fact we have code for doing this
already in other contexts). Moreover, since <code>'static</code> is in the root
universe U0, we know that all variables can see it -- so basically if
we find that <code>value(V2)</code> contains <code>skol(x)</code> for some universe <code>x</code>
that <code>V1</code> can't see, then we force <code>V1</code> to <code>'static</code>.</p>
<a class="header" href="print.html#extending-the-universal-regions-check" id="extending-the-universal-regions-check"><h3>Extending the &quot;universal regions&quot; check</h3></a>
<p>After all constraints have been propagated, the NLL region inference
has one final check, where it goes over the values that wound up being
computed for each universal region and checks that they did not get
'too large'. In our case, we will go through each skolemized region
and check that it contains <em>only</em> the <code>skol(u)</code> element it is known to
outlive. (Later, we might be able to know that there are relationships
between two skolemized regions and take those into account, as we do
for universal regions from the fn signature.)</p>
<p>Put another way, the &quot;universal regions&quot; check can be considered to be
checking constraints like:</p>
<pre><code class="language-text">{skol(1)}: V1
</code></pre>
<p>where <code>{skol(1)}</code> is like a constant set, and V1 is the variable we
made to represent the <code>!1</code> region.</p>
<a class="header" href="print.html#back-to-our-example" id="back-to-our-example"><h2>Back to our example</h2></a>
<p>OK, so far so good. Now let's walk through what would happen with our
first example:</p>
<pre><code class="language-text">fn(&amp;'static u32) &lt;: fn(&amp;'!1 u32) @ P  // this point P is not imp't here
</code></pre>
<p>The region inference engine will create a region element domain like this:</p>
<pre><code class="language-text">{ CFG; end('static); skol(1) }
    ---  ------------  ------- from the universe `!1`
    |    'static is always in scope
    all points in the CFG; not especially relevant here
</code></pre>
<p>It will always create two universal variables, one representing
<code>'static</code> and one representing <code>'!1</code>. Let's call them Vs and V1. They
will have initial values like so:</p>
<pre><code class="language-text">Vs = { CFG; end('static) } // it is in U0, so can't name anything else
V1 = { skol(1) }
</code></pre>
<p>From the subtyping constraint above, we would have an outlives constraint like</p>
<pre><code class="language-text">'!1: 'static @ P
</code></pre>
<p>To process this, we would grow the value of V1 to include all of Vs:</p>
<pre><code class="language-text">Vs = { CFG; end('static) }
V1 = { CFG; end('static), skol(1) }
</code></pre>
<p>At that point, constraint propagation is complete, because all the
outlives relationships are satisfied. Then we would go to the &quot;check
universal regions&quot; portion of the code, which would test that no
universal region grew too large.</p>
<p>In this case, <code>V1</code> <em>did</em> grow too large -- it is not known to outlive
<code>end('static)</code>, nor any of the CFG -- so we would report an error.</p>
<a class="header" href="print.html#another-example" id="another-example"><h2>Another example</h2></a>
<p>What about this subtyping relationship?</p>
<pre><code class="language-text">for&lt;'a&gt; fn(&amp;'a u32, &amp;'a u32)
    &lt;:
for&lt;'b, 'c&gt; fn(&amp;'b u32, &amp;'c u32)
</code></pre>
<p>Here we would skolemize the supertype, as before, yielding:</p>
<pre><code class="language-text">for&lt;'a&gt; fn(&amp;'a u32, &amp;'a u32)
    &lt;:
fn(&amp;'!1 u32, &amp;'!2 u32)
</code></pre>
<p>then we instantiate the variable on the left-hand side with an
existential in universe U2, yielding the following (<code>?n</code> is a notation
for an existential variable):</p>
<pre><code class="language-text">fn(&amp;'?3 u32, &amp;'?3 u32)
    &lt;:
fn(&amp;'!1 u32, &amp;'!2 u32)
</code></pre>
<p>Then we break this down further:</p>
<pre><code class="language-text">&amp;'!1 u32 &lt;: &amp;'?3 u32
&amp;'!2 u32 &lt;: &amp;'?3 u32
</code></pre>
<p>and even further, yield up our region constraints:</p>
<pre><code class="language-text">'!1: '?3
'!2: '?3
</code></pre>
<p>Note that, in this case, both <code>'!1</code> and <code>'!2</code> have to outlive the
variable <code>'?3</code>, but the variable <code>'?3</code> is not forced to outlive
anything else. Therefore, it simply starts and ends as the empty set
of elements, and hence the type-check succeeds here.</p>
<p>(This should surprise you a little. It surprised me when I first realized it.
We are saying that if we are a fn that <strong>needs both of its arguments to have
the same region</strong>, we can accept being called with <strong>arguments with two
distinct regions</strong>. That seems intuitively unsound. But in fact, it's fine, as
I tried to explain in <a href="https://github.com/rust-lang/rust/issues/32330#issuecomment-202536977">this issue</a> on the Rust issue
tracker long ago.  The reason is that even if we get called with arguments of
two distinct lifetimes, those two lifetimes have some intersection (the call
itself), and that intersection can be our value of <code>'a</code> that we use as the
common lifetime of our arguments. -nmatsakis)</p>
<a class="header" href="print.html#final-example" id="final-example"><h2>Final example</h2></a>
<p>Let's look at one last example. We'll extend the previous one to have
a return type:</p>
<pre><code class="language-text">for&lt;'a&gt; fn(&amp;'a u32, &amp;'a u32) -&gt; &amp;'a u32
    &lt;:
for&lt;'b, 'c&gt; fn(&amp;'b u32, &amp;'c u32) -&gt; &amp;'b u32
</code></pre>
<p>Despite seeming very similar to the previous example, this case is going to get
an error. That's good: the problem is that we've gone from a fn that promises
to return one of its two arguments, to a fn that is promising to return the
first one. That is unsound. Let's see how it plays out.</p>
<p>First, we skolemize the supertype:</p>
<pre><code class="language-text">for&lt;'a&gt; fn(&amp;'a u32, &amp;'a u32) -&gt; &amp;'a u32
    &lt;:
fn(&amp;'!1 u32, &amp;'!2 u32) -&gt; &amp;'!1 u32
</code></pre>
<p>Then we instantiate the subtype with existentials (in U2):</p>
<pre><code class="language-text">fn(&amp;'?3 u32, &amp;'?3 u32) -&gt; &amp;'?3 u32
    &lt;:
fn(&amp;'!1 u32, &amp;'!2 u32) -&gt; &amp;'!1 u32
</code></pre>
<p>And now we create the subtyping relationships:</p>
<pre><code class="language-text">&amp;'!1 u32 &lt;: &amp;'?3 u32 // arg 1
&amp;'!2 u32 &lt;: &amp;'?3 u32 // arg 2
&amp;'?3 u32 &lt;: &amp;'!1 u32 // return type
</code></pre>
<p>And finally the outlives relationships. Here, let V1, V2, and V3 be the
variables we assign to <code>!1</code>, <code>!2</code>, and <code>?3</code> respectively:</p>
<pre><code class="language-text">V1: V3
V2: V3
V3: V1
</code></pre>
<p>Those variables will have these initial values:</p>
<pre><code class="language-text">V1 in U1 = {skol(1)}
V2 in U2 = {skol(2)}
V3 in U2 = {}
</code></pre>
<p>Now because of the <code>V3: V1</code> constraint, we have to add <code>skol(1)</code> into <code>V3</code> (and
indeed it is visible from <code>V3</code>), so we get:</p>
<pre><code class="language-text">V3 in U2 = {skol(1)}
</code></pre>
<p>then we have this constraint <code>V2: V3</code>, so we wind up having to enlarge
<code>V2</code> to include <code>skol(1)</code> (which it can also see):</p>
<pre><code class="language-text">V2 in U2 = {skol(1), skol(2)}
</code></pre>
<p>Now contraint propagation is done, but when we check the outlives
relationships, we find that <code>V2</code> includes this new element <code>skol(1)</code>,
so we report an error.</p>
<a class="header" href="print.html#mir-optimizations" id="mir-optimizations"><h1>MIR optimizations</h1></a>
<a class="header" href="print.html#constant-evaluation" id="constant-evaluation"><h1>Constant Evaluation</h1></a>
<p>Constant evaluation is the process of computing values at compile time. For a
specific item (constant/static/array length) this happens after the MIR for the
item is borrow-checked and optimized. In many cases trying to const evaluate an
item will trigger the computation of its MIR for the first time.</p>
<p>Prominent examples are</p>
<ul>
<li>The initializer of a <code>static</code></li>
<li>Array length
<ul>
<li>needs to be known to reserve stack or heap space</li>
</ul>
</li>
<li>Enum variant discriminants
<ul>
<li>needs to be known to prevent two variants from having the same
discriminant</li>
</ul>
</li>
<li>Patterns
<ul>
<li>need to be known to check for overlapping patterns</li>
</ul>
</li>
</ul>
<p>Additionally constant evaluation can be used to reduce the workload or binary
size at runtime by precomputing complex operations at compiletime and only
storing the result.</p>
<p>Constant evaluation can be done by calling the <code>const_eval</code> query of <code>TyCtxt</code>.</p>
<p>The <code>const_eval</code> query takes a <a href="./param_env.html"><code>ParamEnv</code></a> of environment in
which the constant is evaluated (e.g. the function within which the constant is
used) and a <code>GlobalId</code>. The <code>GlobalId</code> is made up of an
<code>Instance</code> referring to a constant or static or of an
<code>Instance</code> of a function and an index into the function's <code>Promoted</code> table.</p>
<p>Constant evaluation returns a <code>Result</code> with either the error, or the simplest
representation of the constant. &quot;simplest&quot; meaning if it is representable as an
integer or fat pointer, it will directly yield the value (via <code>Value::ByVal</code> or
<code>Value::ByValPair</code>), instead of referring to the <a href="./miri.html"><code>miri</code></a> virtual
memory allocation (via <code>Value::ByRef</code>). This means that the <code>const_eval</code>
function cannot be used to create miri-pointers to the evaluated constant or
static. If you need that, you need to directly work with the functions in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/interpret/const_eval/">src/librustc_mir/interpret/const_eval.rs</a>.</p>
<a class="header" href="print.html#miri" id="miri"><h1>Miri</h1></a>
<p>Miri (<strong>MIR</strong> <strong>I</strong>nterpreter) is a virtual machine for executing MIR without
compiling to machine code. It is usually invoked via <code>tcx.const_eval</code>.</p>
<p>If you start out with a constant</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
const FOO: usize = 1 &lt;&lt; 12;
#}</code></pre></pre>
<p>rustc doesn't actually invoke anything until the constant is either used or
placed into metadata.</p>
<p>Once you have a use-site like</p>
<pre><code class="language-rust ignore">type Foo = [u8; FOO - 42];
</code></pre>
<p>The compiler needs to figure out the length of the array before being able to
create items that use the type (locals, constants, function arguments, ...).</p>
<p>To obtain the (in this case empty) parameter environment, one can call
<code>let param_env = tcx.param_env(length_def_id);</code>. The <code>GlobalId</code> needed is</p>
<pre><code class="language-rust ignore">let gid = GlobalId {
    promoted: None,
    instance: Instance::mono(length_def_id),
};
</code></pre>
<p>Invoking <code>tcx.const_eval(param_env.and(gid))</code> will now trigger the creation of
the MIR of the array length expression. The MIR will look something like this:</p>
<pre><code class="language-mir">const Foo::{{initializer}}: usize = {
    let mut _0: usize;                   // return pointer
    let mut _1: (usize, bool);

    bb0: {
        _1 = CheckedSub(const Unevaluated(FOO, Slice([])), const 42usize);
        assert(!(_1.1: bool), &quot;attempt to subtract with overflow&quot;) -&gt; bb1;
    }

    bb1: {
        _0 = (_1.0: usize);
        return;
    }
}
</code></pre>
<p>Before the evaluation, a virtual memory location (in this case essentially a
<code>vec![u8; 4]</code> or <code>vec![u8; 8]</code>) is created for storing the evaluation result.</p>
<p>At the start of the evaluation, <code>_0</code> and <code>_1</code> are
<code>Value::ByVal(PrimVal::Undef)</code>. When the initialization of <code>_1</code> is invoked, the
value of the <code>FOO</code> constant is required, and triggers another call to
<code>tcx.const_eval</code>, which will not be shown here. If the evaluation of FOO is
successful, 42 will be subtracted by its value <code>4096</code> and the result stored in
<code>_1</code> as <code>Value::ByValPair(PrimVal::Bytes(4054), PrimVal::Bytes(0))</code>. The first
part of the pair is the computed value, the second part is a bool that's true if
an overflow happened.</p>
<p>The next statement asserts that said boolean is <code>0</code>. In case the assertion
fails, its error message is used for reporting a compile-time error.</p>
<p>Since it does not fail, <code>Value::ByVal(PrimVal::Bytes(4054))</code> is stored in the
virtual memory was allocated before the evaluation. <code>_0</code> always refers to that
location directly.</p>
<p>After the evaluation is done, the virtual memory allocation is interned into the
<code>TyCtxt</code>. Future evaluations of the same constants will not actually invoke
miri, but just extract the value from the interned allocation.</p>
<p>The <code>tcx.const_eval</code> function has one additional feature: it will not return a
<code>ByRef(interned_allocation_id)</code>, but a <code>ByVal(computed_value)</code> if possible. This
makes using the result much more convenient, as no further queries need to be
executed in order to get at something as simple as a <code>usize</code>.</p>
<a class="header" href="print.html#datastructures" id="datastructures"><h2>Datastructures</h2></a>
<p>Miri's core datastructures can be found in
<a href="https://github.com/rust-lang/rust/blob/master/src/librustc/mir/interpret">librustc/mir/interpret</a>.
This is mainly the error enum and the <code>Value</code> and <code>PrimVal</code> types. A <code>Value</code> can
be either <code>ByVal</code> (a single <code>PrimVal</code>), <code>ByValPair</code> (two <code>PrimVal</code>s, usually fat
pointers or two element tuples) or <code>ByRef</code>, which is used for anything else and
refers to a virtual allocation. These allocations can be accessed via the
methods on <code>tcx.interpret_interner</code>.</p>
<p>If you are expecting a numeric result, you can use <code>unwrap_u64</code> (panics on
anything that can't be representad as a <code>u64</code>) or <code>to_raw_bits</code> which results
in an <code>Option&lt;u128&gt;</code> yielding the <code>ByVal</code> if possible.</p>
<a class="header" href="print.html#allocations" id="allocations"><h2>Allocations</h2></a>
<p>A miri allocation is either a byte sequence of the memory or an <code>Instance</code> in
the case of function pointers. Byte sequences can additionally contain
relocations that mark a group of bytes as a pointer to another allocation. The
actual bytes at the relocation refer to the offset inside the other allocation.</p>
<p>These allocations exist so that references and raw pointers have something to
point to. There is no global linear heap in which things are allocated, but each
allocation (be it for a local variable, a static or a (future) heap allocation)
gets its own little memory with exactly the required size. So if you have a
pointer to an allocation for a local variable <code>a</code>, there is no possible (no
matter how unsafe) operation that you can do that would ever change said pointer
to a pointer to <code>b</code>.</p>
<a class="header" href="print.html#interpretation" id="interpretation"><h2>Interpretation</h2></a>
<p>Although the main entry point to constant evaluation is the <code>tcx.const_eval</code>
query, there are additional functions in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/interpret/const_eval/">librustc_mir/interpret/const_eval.rs</a>
that allow accessing the fields of a <code>Value</code> (<code>ByRef</code> or otherwise). You should
never have to access an <code>Allocation</code> directly except for translating it to the
compilation target (at the moment just LLVM).</p>
<p>Miri starts by creating a virtual stack frame for the current constant that is
being evaluated. There's essentially no difference between a constant and a
function with no arguments, except that constants do not allow local (named)
variables at the time of writing this guide.</p>
<p>A stack frame is defined by the <code>Frame</code> type in
<a href="https://github.com/rust-lang/rust/blob/master/src/librustc_mir/interpret/eval_context.rs">librustc_mir/interpret/eval_context.rs</a>
and contains all the local
variables memory (<code>None</code> at the start of evaluation). Each frame refers to the
evaluation of either the root constant or subsequent calls to <code>const fn</code>. The
evaluation of another constant simply calls <code>tcx.const_eval</code>, which produces an
entirely new and independent stack frame.</p>
<p>The frames are just a <code>Vec&lt;Frame&gt;</code>, there's no way to actually refer to a
<code>Frame</code>'s memory even if horrible shenigans are done via unsafe code. The only
memory that can be referred to are <code>Allocation</code>s.</p>
<p>Miri now calls the <code>step</code> method (in
<a href="https://github.com/rust-lang/rust/blob/master/src/librustc_mir/interpret/step.rs">librustc_mir/interpret/step.rs</a>
) until it either returns an error or has no further statements to execute. Each
statement will now initialize or modify the locals or the virtual memory
referred to by a local. This might require evaluating other constants or
statics, which just recursively invokes <code>tcx.const_eval</code>.</p>
<a class="header" href="print.html#parameter-environment" id="parameter-environment"><h1>Parameter Environment</h1></a>
<p>When working with associated and/or or generic items (types, constants,
functions/methods) it is often relevant to have more information about the
<code>Self</code> or generic parameters. Trait bounds and similar information is encoded in
the <code>ParamEnv</code>. Often this is not enough information to obtain things like the
type's <code>Layout</code>, but you can do all kinds of other checks on it (e.g. whether a
type implements <code>Copy</code>) or you can evaluate an associated constant whose value
does not depend on anything from the parameter environment.</p>
<p>For example if you have a function</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo&lt;T: Copy&gt;(t: T) {
}
#}</code></pre></pre>
<p>the parameter environment for that function is <code>[T: Copy]</code>. This means any
evaluation within this function will, when accessing the type <code>T</code>, know about
its <code>Copy</code> bound via the parameter environment.</p>
<p>Although you can obtain a valid <code>ParamEnv</code> for any item via
<code>tcx.param_env(def_id)</code>, this <code>ParamEnv</code> can be too generic for your use case.
Using the <code>ParamEnv</code> from the surrounding context can allow you to evaluate more
things.</p>
<p>Another great thing about <code>ParamEnv</code> is that you can use it to bundle the thing
depending on generic parameters (e.g. a <code>Ty</code>) by calling <code>param_env.and(ty)</code>.
This will produce a <code>ParamEnvAnd&lt;Ty&gt;</code>, making clear that you should probably not
be using the inner value without taking care to also use the <code>ParamEnv</code>.</p>
<a class="header" href="print.html#generating-llvm-ir" id="generating-llvm-ir"><h1>Generating LLVM IR</h1></a>
<a class="header" href="print.html#emitting-diagnostics" id="emitting-diagnostics"><h1>Emitting Diagnostics</h1></a>
<p>A lot of effort has been put into making <code>rustc</code> have great error messages.
This chapter is about how to emit compile errors and lints from the compiler.</p>
<a class="header" href="print.html#span" id="span"><h2><code>Span</code></h2></a>
<p><code>Span</code> is the primary data structure in <code>rustc</code> used to represent a location in
the code being compiled. <code>Span</code>s are attached to most constructs in HIR and MIR,
allowing for easier error reporting whenever an error comes up.</p>
<p>A <code>Span</code> can be looked up in a <code>CodeMap</code> to get a &quot;snippet&quot; useful for
displaying errors with <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/codemap/struct.CodeMap.html#method.span_to_snippet"><code>span_to_snippet</code> and other similar methods</a>
on the <code>CodeMap</code>.</p>
<a class="header" href="print.html#error-messages" id="error-messages"><h2>Error messages</h2></a>
<p>The <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/index.html"><code>rustc_errors</code></a> crate defines most of the utilities used for
reporting errors.</p>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/session/struct.Session.html"><code>Session</code></a> and <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/parse/struct.ParseSess.html"><code>ParseSess</code></a> have
methods (or fields with methods) that allow reporting errors. These methods
usually have names like <code>span_err</code> or <code>struct_span_err</code> or <code>span_warn</code>, etc...
There are lots of them; they emit different types of &quot;errors&quot;, such as
warnings, errors, fatal errors, suggestions, etc.</p>
<p>In general, there are two class of such methods: ones that emit an error
directly and ones that allow finer control over what to emit. For example,
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/session/struct.Session.html#method.span_err"><code>span_err</code></a> emits the given error message at the given <code>Span</code>, but
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/session/struct.Session.html#method.struct_span_err"><code>struct_span_err</code></a> instead returns a
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/diagnostic_builder/struct.DiagnosticBuilder.html"><code>DiagnosticBuilder</code></a>.</p>
<p><code>DiagnosticBuilder</code> allows you to add related notes and suggestions to an error
before emitting it by calling the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/diagnostic_builder/struct.DiagnosticBuilder.html#method.emit"><code>emit</code></a> method. See the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/diagnostic_builder/struct.DiagnosticBuilder.html">docs</a> for more info on what you can do.</p>
<pre><code class="language-rust ignore">// Get a DiagnosticBuilder. This does _not_ emit an error yet.
let mut err = sess.struct_span_err(sp, &quot;oh no! this is an error!&quot;);

// In some cases, you might need to check if `sp` is generated by a macro to
// avoid printing weird errors about macro-generated code.

if let Some(snippet) = sess.codemap().span_to_snippet(sp) {
    // Use the snippet to generate a suggested fix
    err.span_suggestion(suggestion_sp, &quot;try using a qux here&quot;, format!(&quot;qux {}&quot;, snip));
} else {
    // If we weren't able to generate a snippet, then emit a &quot;help&quot; message
    // instead of a concrete &quot;suggestion&quot;. In practice this is unlikely to be
    // reached.
    err.span_help(suggestion_sp, &quot;you could use a qux here instead&quot;);
}

// emit the error
err.emit();
</code></pre>
<a class="header" href="print.html#suggestions" id="suggestions"><h2>Suggestions</h2></a>
<p>We would like to make edition transitions as smooth as possible. To that end,
<code>rustfix</code> can use compiler suggestions to automatically fix code. For example,
we could use <code>rustfix</code> to mechanically apply the <code>qux</code> suggestion from the
previous example. However, not all suggestions are mechanically applicable.  We
use the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/struct.DiagnosticBuilder.html#method.span_suggestion_with_applicability"><code>span_suggestion_with_applicability</code></a> method of
<code>DiagnosticBuilder</code> to inform the emitter of whether a suggestion is
mechanically applicable or not.  This information, in turn, is outputed by
rustc when the error format is <code>json</code>, which is used by <code>rustfix</code>.</p>
<p>For example, to make our <code>qux</code> suggestion machine-applicable, we would do:</p>
<pre><code class="language-rust ignore">let mut err = sess.struct_span_err(sp, &quot;oh no! this is an error!&quot;);

if let Some(snippet) = sess.codemap().span_to_snippet(sp) {
    // Add applicability info!
    err.span_suggestion_with_applicability(
        suggestion_sp,
        &quot;try using a qux here&quot;,
        format!(&quot;qux {}&quot;, snip),
        Applicability::MachineApplicable,
    );
} else {
    err.span_help(suggestion_sp, &quot;you could use a qux here instead&quot;);
}

err.emit();
</code></pre>
<p>This might emit an error like</p>
<pre><code class="language-console">$ rustc mycode.rs
error[E0999]: oh no! this is an error!
 --&gt; mycode.rs:3:5
  |
3 |     sad()
  |     ^ help: try using a qux here: `qux sad()`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0999`.
</code></pre>
<p>In some cases, like when the suggestion spans multiple lines or when there are
multiple suggestions, the suggestions are displayed on their own:</p>
<pre><code class="language-console">error[E0999]: oh no! this is an error!
 --&gt; mycode.rs:3:5
  |
3 |     sad()
  |     ^
help: try using a qux here:
  |
3 |     qux sad()
  |     ^^^

error: aborting due to previous error

For more information about this error, try `rustc --explain E0999`.
</code></pre>
<p>There are a few other <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/enum.Applicability.html"><code>Applicability</code></a> possibilities:</p>
<ul>
<li><code>MachineApplicable</code>: Can be applied mechanically.</li>
<li><code>HasPlaceholders</code>: Cannot be applied mechanically and has placeholder text in
the suggestions. For example, &quot;Try adding a type: `let x: &lt;type&gt;`&quot;.</li>
<li><code>MaybeIncorrect</code>: Cannot be applied mechanically because the suggestion may
or may not be a good one.</li>
<li><code>Unspecified</code>: Cannot be applied mechanically because we don't know which
of the above cases it falls into.</li>
</ul>
<a class="header" href="print.html#lints" id="lints"><h2>Lints</h2></a>
<p>The compiler linting infrastructure is defined in the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/lint/index.html"><code>rustc::lint</code></a>
module.</p>
<a class="header" href="print.html#declaring-a-lint" id="declaring-a-lint"><h3>Declaring a lint</h3></a>
<p>The built-in compiler lints are defined in the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/index.html"><code>rustc_lint</code></a>
crate.</p>
<p>Each lint is defined as a <code>struct</code> that implements the <code>LintPass</code> <code>trait</code>. The
trait implementation allows you to check certain syntactic constructs the
linter walks the source code. You can then choose to emit lints in a very
similar way to compile errors. Finally, you register the lint to actually get
it to be run by the compiler by using the <code>declare_lint!</code> macro.</p>
<p>For example, the following lint checks for uses
of <code>while true { ... }</code> and suggests using <code>loop { ... }</code> instead.</p>
<pre><code class="language-rust ignore">// Declare a lint called `WHILE_TRUE`
declare_lint! {
    WHILE_TRUE,

    // warn-by-default
    Warn,

    // This string is the lint description
    &quot;suggest using `loop { }` instead of `while true { }`&quot;
}

// Define a struct and `impl LintPass` for it.
#[derive(Copy, Clone)]
pub struct WhileTrue;

impl LintPass for WhileTrue {
    fn get_lints(&amp;self) -&gt; LintArray {
        lint_array!(WHILE_TRUE)
    }
}

// LateLintPass has lots of methods. We only override the definition of
// `check_expr` for this lint because that's all we need, but you could
// override other methods for your own lint. See the rustc docs for a full
// list of methods.
impl&lt;'a, 'tcx&gt; LateLintPass&lt;'a, 'tcx&gt; for WhileTrue {
    fn check_expr(&amp;mut self, cx: &amp;LateContext, e: &amp;hir::Expr) {
        if let hir::ExprWhile(ref cond, ..) = e.node {
            if let hir::ExprLit(ref lit) = cond.node {
                if let ast::LitKind::Bool(true) = lit.node {
                    if lit.span.ctxt() == SyntaxContext::empty() {
                        let msg = &quot;denote infinite loops with `loop { ... }`&quot;;
                        let condition_span = cx.tcx.sess.codemap().def_span(e.span);
                        let mut err = cx.struct_span_lint(WHILE_TRUE, condition_span, msg);
                        err.span_suggestion_short(condition_span, &quot;use `loop`&quot;, &quot;loop&quot;.to_owned());
                        err.emit();
                    }
                }
            }
        }
    }
}
</code></pre>
<a class="header" href="print.html#edition-gated-lints" id="edition-gated-lints"><h3>Edition-gated Lints</h3></a>
<p>Sometimes we want to change the behavior of a lint in a new edition. To do this,
we just add the transition to our invocation of <code>declare_lint!</code>:</p>
<pre><code class="language-rust ignore">declare_lint! {
    pub ANONYMOUS_PARAMETERS,
    Allow,
    &quot;detects anonymous parameters&quot;,
    Edition::Edition2018 =&gt; Warn,
}
</code></pre>
<p>This makes the <code>ANONYMOUS_PARAMETERS</code> lint allow-by-default in the 2015 edition
but warn-by-default in the 2018 edition.</p>
<p>Lints that represent an incompatibility (i.e. error) in the upcoming edition
should also be registered as <code>FutureIncompatibilityLint</code>s in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/fn.register_builtins.html"><code>register_builtins</code></a> function in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/index.html"><code>rustc_lint::lib</code></a>.</p>
<a class="header" href="print.html#lint-groups" id="lint-groups"><h3>Lint Groups</h3></a>
<p>Lints can be turned on in groups. These groups are declared in the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/fn.register_builtins.html"><code>register_builtins</code></a> function in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/index.html"><code>rustc_lint::lib</code></a>. The
<code>add_lint_group!</code> macro is used to declare a new group.</p>
<p>For example,</p>
<pre><code class="language-rust ignore">    add_lint_group!(sess,
                    &quot;nonstandard_style&quot;,
                    NON_CAMEL_CASE_TYPES,
                    NON_SNAKE_CASE,
                    NON_UPPER_CASE_GLOBALS);
</code></pre>
<p>This defines the <code>nonstandard_style</code> group which turns on the listed lints. A
user can turn on these lints by using <code>!#[warn(nonstandard_style)]</code>.</p>
<a class="header" href="print.html#appendix-a-a-tutorial-on-creating-a-drop-in-replacement-for-rustc" id="appendix-a-a-tutorial-on-creating-a-drop-in-replacement-for-rustc"><h1>Appendix A: A tutorial on creating a drop-in replacement for rustc</h1></a>
<blockquote>
<p><strong>Note:</strong> This is a copy of <code>@nrc</code>'s amazing <a href="https://github.com/nrc/stupid-stats">stupid-stats</a>. You should find
a copy of the code on the GitHub repository although due to the compiler's
constantly evolving nature, there is no guarantee it'll compile on the first
go.</p>
</blockquote>
<p>Many tools benefit from being a drop-in replacement for a compiler. By this, I
mean that any user of the tool can use <code>mytool</code> in all the ways they would
normally use <code>rustc</code> - whether manually compiling a single file or as part of a
complex make project or Cargo build, etc. That could be a lot of work;
rustc, like most compilers, takes a large number of command line arguments which
can affect compilation in complex and interacting ways. Emulating all of this
behaviour in your tool is annoying at best, especically if you are making many
of the same calls into librustc that the compiler is.</p>
<p>The kind of things I have in mind are tools like rustdoc or a future rustfmt.
These want to operate as closely as possible to real compilation, but have
totally different outputs (documentation and formatted source code,
respectively). Another use case is a customised compiler. Say you want to add a
custom code generation phase after macro expansion, then creating a new tool
should be easier than forking the compiler (and keeping it up to date as the
compiler evolves).</p>
<p>I have gradually been trying to improve the API of librustc to make creating a
drop-in tool easier to produce (many others have also helped improve these
interfaces over the same time frame). It is now pretty simple to make a tool
which is as close to rustc as you want it to be. In this tutorial I'll show
how.</p>
<p>Note/warning, everything I talk about in this tutorial is internal API for
rustc. It is all extremely unstable and likely to change often and in
unpredictable ways. Maintaining a tool which uses these APIs will be non-
trivial, although hopefully easier than maintaining one that does similar things
without using them.</p>
<p>This tutorial starts with a very high level view of the rustc compilation
process and of some of the code that drives compilation. Then I'll describe how
that process can be customised. In the final section of the tutorial, I'll go
through an example - stupid-stats - which shows how to build a drop-in tool.</p>
<a class="header" href="print.html#overview-of-the-compilation-process" id="overview-of-the-compilation-process"><h2>Overview of the compilation process</h2></a>
<p>Compilation using rustc happens in several phases. We start with parsing, this
includes lexing. The output of this phase is an AST (abstract syntax tree).
There is a single AST for each crate (indeed, the entire compilation process
operates over a single crate). Parsing abstracts away details about individual
files which will all have been read in to the AST in this phase. At this stage
the AST includes all macro uses, attributes will still be present, and nothing
will have been eliminated due to <code>cfg</code>s.</p>
<p>The next phase is configuration and macro expansion. This can be thought of as a
function over the AST. The unexpanded AST goes in and an expanded AST comes out.
Macros and syntax extensions are expanded, and <code>cfg</code> attributes will cause some
code to disappear. The resulting AST won't have any macros or macro uses left
in.</p>
<p>The code for these first two phases is in <a href="https://github.com/rust-lang/rust/tree/master/src/libsyntax">libsyntax</a>.</p>
<p>After this phase, the compiler allocates ids to each node in the AST
(technically not every node, but most of them). If we are writing out
dependencies, that happens now.</p>
<p>The next big phase is analysis. This is the most complex phase and
uses the bulk of the code in rustc. This includes name resolution, type
checking, borrow checking, type and lifetime inference, trait selection, method
selection, linting, and so forth. Most error detection is done in this phase
(although parse errors are found during parsing). The 'output' of this phase is
a bunch of side tables containing semantic information about the source program.
The analysis code is in <a href="https://github.com/rust-lang/rust/tree/master/src/librustc">librustc</a>
and a bunch of other crates with the 'librustc_' prefix.</p>
<p>Next is translation, this translates the AST (and all those side tables) into
LLVM IR (intermediate representation). We do this by calling into the LLVM
libraries, rather than actually writing IR directly to a file. The code for
this is in <a href="https://github.com/rust-lang/rust/tree/master/src/librustc_trans">librustc_trans</a>.</p>
<p>The next phase is running the LLVM backend. This runs LLVM's optimisation passes
on the generated IR and then generates machine code. The result is object files.
This phase is all done by LLVM, it is not really part of the rust compiler. The
interface between LLVM and rustc is in <a href="https://github.com/rust-lang/rust/tree/master/src/librustc_llvm">librustc_llvm</a>.</p>
<p>Finally, we link the object files into an executable. Again we outsource this to
other programs and it's not really part of the rust compiler. The interface is
in <a href="https://github.com/rust-lang/rust/tree/master/src/librustc_back">librustc_back</a>
(which also contains some things used primarily during translation).</p>
<p>All these phases are coordinated by the driver. To see the exact sequence, look
at <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_driver/driver/fn.compile_input.html">the <code>compile_input</code> function in <code>librustc_driver</code></a>.
The driver handles all the highest level coordination of compilation -
1. handling command-line arguments
2. maintaining compilation state (primarily in the <code>Session</code>)
3. calling the appropriate code to run each phase of compilation
4. handles high level coordination of pretty printing and testing.
To create a drop-in compiler replacement or a compiler replacement,
we leave most of compilation alone and customise the driver using its APIs.</p>
<a class="header" href="print.html#the-driver-customisation-apis" id="the-driver-customisation-apis"><h2>The driver customisation APIs</h2></a>
<p>There are two primary ways to customise compilation - high level control of the
driver using <code>CompilerCalls</code> and controlling each phase of compilation using a
<code>CompileController</code>. The former lets you customise handling of command line
arguments etc., the latter lets you stop compilation early or execute code
between phases.</p>
<a class="header" href="print.html#compilercalls" id="compilercalls"><h3><code>CompilerCalls</code></h3></a>
<p><code>CompilerCalls</code> is a trait that you implement in your tool. It contains a fairly
ad-hoc set of methods to hook in to the process of processing command line
arguments and driving the compiler. For details, see the comments in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_driver/index.html">librustc_driver/lib.rs</a>.
I'll summarise the methods here.</p>
<p><code>early_callback</code> and <code>late_callback</code> let you call arbitrary code at different
points - early is after command line arguments have been parsed, but before
anything is done with them; late is pretty much the last thing before
compilation starts, i.e., after all processing of command line arguments, etc.
is done. Currently, you get to choose whether compilation stops or continues at
each point, but you don't get to change anything the driver has done. You can
record some info for later, or perform other actions of your own.</p>
<p><code>some_input</code> and <code>no_input</code> give you an opportunity to modify the primary input
to the compiler (usually the input is a file containing the top module for a
crate, but it could also be a string). You could record the input or perform
other actions of your own.</p>
<p>Ignore <code>parse_pretty</code>, it is unfortunate and hopefully will get improved. There
is a default implementation, so you can pretend it doesn't exist.</p>
<p><code>build_controller</code> returns a <code>CompileController</code> object for more fine-grained
control of compilation, it is described next.</p>
<p>We might add more options in the future.</p>
<a class="header" href="print.html#compilercontroller" id="compilercontroller"><h3><code>CompilerController</code></h3></a>
<p><code>CompilerController</code> is a struct consisting of <code>PhaseController</code>s and flags.
Currently, there is only flag, <code>make_glob_map</code> which signals whether to produce
a map of glob imports (used by save-analysis and potentially other tools). There
are probably flags in the session that should be moved here.</p>
<p>There is a <code>PhaseController</code> for each of the phases described in the above
summary of compilation (and we could add more in the future for finer-grained
control). They are all <code>after_</code> a phase because they are checked at the end of a
phase (again, that might change), e.g., <code>CompilerController::after_parse</code>
controls what happens immediately after parsing (and before macro expansion).</p>
<p>Each <code>PhaseController</code> contains a flag called <code>stop</code> which indicates whether
compilation should stop or continue, and a callback to be executed at the point
indicated by the phase. The callback is called whether or not compilation
continues.</p>
<p>Information about the state of compilation is passed to these callbacks in a
<code>CompileState</code> object. This contains all the information the compiler has. Note
that this state information is immutable - your callback can only execute code
using the compiler state, it can't modify the state. (If there is demand, we
could change that). The state available to a callback depends on where during
compilation the callback is called. For example, after parsing there is an AST
but no semantic analysis (because the AST has not been analysed yet). After
translation, there is translation info, but no AST or analysis info (since these
have been consumed/forgotten).</p>
<a class="header" href="print.html#an-example---stupid-stats" id="an-example---stupid-stats"><h2>An example - stupid-stats</h2></a>
<p>Our example tool is very simple, it simply collects some simple and not very
useful statistics about a program; it is called stupid-stats. You can find
the (more heavily commented) complete source for the example on <a href="https://github.com/nick29581/stupid-stats/blob/master/src">Github</a>.
To build, just do <code>cargo build</code>. To run on a file <code>foo.rs</code>, do <code>cargo run foo.rs</code> (assuming you have a Rust program called <code>foo.rs</code>. You can also pass any
command line arguments that you would normally pass to rustc). When you run it
you'll see output similar to</p>
<pre><code class="language-text">In crate: foo,

Found 12 uses of `println!`;
The most common number of arguments is 1 (67% of all functions);
25% of functions have four or more arguments.
</code></pre>
<p>To make things easier, when we talk about functions, we're excluding methods and
closures.</p>
<p>You can also use the executable as a drop-in replacement for rustc, because
after all, that is the whole point of this exercise. So, however you use rustc
in your makefile setup, you can use <code>target/stupid</code> (or whatever executable you
end up with) instead. That might mean setting an environment variable or it
might mean renaming your executable to <code>rustc</code> and setting your PATH. Similarly,
if you're using Cargo, you'll need to rename the executable to rustc and set the
PATH. Alternatively, you should be able to use
<a href="https://github.com/brson/multirust">multirust</a> to get around all the PATH stuff
(although I haven't actually tried that).</p>
<p>(Note that this example prints to stdout. I'm not entirely sure what Cargo does
with stdout from rustc under different circumstances. If you don't see any
output, try inserting a <code>panic!</code> after the <code>println!</code>s to error out, then Cargo
should dump stupid-stats' stdout to Cargo's stdout).</p>
<p>Let's start with the <code>main</code> function for our tool, it is pretty simple:</p>
<pre><code class="language-rust ignore">fn main() {
    let args: Vec&lt;_&gt; = std::env::args().collect();
    rustc_driver::run_compiler(&amp;args, &amp;mut StupidCalls::new());
    std::env::set_exit_status(0);
}
</code></pre>
<p>The first line grabs any command line arguments. The second line calls the
compiler driver with those arguments. The final line sets the exit code for the
program.</p>
<p>The only interesting thing is the <code>StupidCalls</code> object we pass to the driver.
This is our implementation of the <code>CompilerCalls</code> trait and is what will make
this tool different from rustc.</p>
<p><code>StupidCalls</code> is a mostly empty struct:</p>
<pre><code class="language-rust ignore">struct StupidCalls {
    default_calls: RustcDefaultCalls,
}
</code></pre>
<p>This tool is so simple that it doesn't need to store any data here, but usually
you would. We embed a <code>RustcDefaultCalls</code> object to delegate to in our impl when
we want exactly the same behaviour as the Rust compiler. Mostly you don't want
to do that (or at least don't need to) in a tool. However, Cargo calls rustc
with the <code>--print file-names</code>, so we delegate in <code>late_callback</code> and <code>no_input</code>
to keep Cargo happy.</p>
<p>Most of the rest of the impl of <code>CompilerCalls</code> is trivial:</p>
<pre><code class="language-rust ignore">impl&lt;'a&gt; CompilerCalls&lt;'a&gt; for StupidCalls {
    fn early_callback(&amp;mut self,
                        _: &amp;getopts::Matches,
                        _: &amp;config::Options,
                        _: &amp;diagnostics::registry::Registry,
                        _: ErrorOutputType)
                      -&gt; Compilation {
        Compilation::Continue
    }

    fn late_callback(&amp;mut self,
                     t: &amp;TransCrate,
                     m: &amp;getopts::Matches,
                     s: &amp;Session,
                     c: &amp;CrateStore,
                     i: &amp;Input,
                     odir: &amp;Option&lt;PathBuf&gt;,
                     ofile: &amp;Option&lt;PathBuf&gt;)
                     -&gt; Compilation {
        self.default_calls.late_callback(t, m, s, c, i, odir, ofile);
        Compilation::Continue
    }

    fn some_input(&amp;mut self,
                  input: Input,
                  input_path: Option&lt;Path&gt;)
                  -&gt; (Input, Option&lt;Path&gt;) {
        (input, input_path)
    }

    fn no_input(&amp;mut self,
                m: &amp;getopts::Matches,
                o: &amp;config::Options,
                odir: &amp;Option&lt;Path&gt;,
                ofile: &amp;Option&lt;Path&gt;,
                r: &amp;diagnostics::registry::Registry)
                -&gt; Option&lt;(Input, Option&lt;Path&gt;)&gt; {
        self.default_calls.no_input(m, o, odir, ofile, r);

        // This is not optimal error handling.
        panic!(&quot;No input supplied to stupid-stats&quot;);
    }

    fn build_controller(&amp;mut self, _: &amp;Session) -&gt; driver::CompileController&lt;'a&gt; {
        ...
    }
}
</code></pre>
<p>We don't do anything for either of the callbacks, nor do we change the input if
the user supplies it. If they don't, we just <code>panic!</code>, this is the simplest way
to handle the error, but not very user-friendly, a real tool would give a
constructive message or perform a default action.</p>
<p>In <code>build_controller</code> we construct our <code>CompileController</code>. We only want to
parse, and we want to inspect macros before expansion, so we make compilation
stop after the first phase (parsing). The callback after that phase is where the
tool does it's actual work by walking the AST. We do that by creating an AST
visitor and making it walk the AST from the top (the crate root). Once we've
walked the crate, we print the stats we've collected:</p>
<pre><code class="language-rust ignore">fn build_controller(&amp;mut self, _: &amp;Session) -&gt; driver::CompileController&lt;'a&gt; {
    // We mostly want to do what rustc does, which is what basic() will return.
    let mut control = driver::CompileController::basic();
    // But we only need the AST, so we can stop compilation after parsing.
    control.after_parse.stop = Compilation::Stop;

    // And when we stop after parsing we'll call this closure.
    // Note that this will give us an AST before macro expansions, which is
    // not usually what you want.
    control.after_parse.callback = box |state| {
        // Which extracts information about the compiled crate...
        let krate = state.krate.unwrap();

        // ...and walks the AST, collecting stats.
        let mut visitor = StupidVisitor::new();
        visit::walk_crate(&amp;mut visitor, krate);

        // And finally prints out the stupid stats that we collected.
        let cratename = match attr::find_crate_name(&amp;krate.attrs[]) {
            Some(name) =&gt; name.to_string(),
            None =&gt; String::from_str(&quot;unknown_crate&quot;),
        };
        println!(&quot;In crate: {},\n&quot;, cratename);
        println!(&quot;Found {} uses of `println!`;&quot;, visitor.println_count);

        let (common, common_percent, four_percent) = visitor.compute_arg_stats();
        println!(&quot;The most common number of arguments is {} ({:.0}% of all functions);&quot;,
                 common, common_percent);
        println!(&quot;{:.0}% of functions have four or more arguments.&quot;, four_percent);
    };

    control
}
</code></pre>
<p>That is all it takes to create your own drop-in compiler replacement or custom
compiler! For the sake of completeness I'll go over the rest of the stupid-stats
tool.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct StupidVisitor {
    println_count: usize,
    arg_counts: Vec&lt;usize&gt;,
}
#}</code></pre></pre>
<p>The <code>StupidVisitor</code> struct just keeps track of the number of <code>println!</code>s it has
seen and the count for each number of arguments. It implements
<code>syntax::visit::Visitor</code> to walk the AST. Mostly we just use the default
methods, these walk the AST taking no action. We override <code>visit_item</code> and
<code>visit_mac</code> to implement custom behaviour when we walk into items (items include
functions, modules, traits, structs, and so forth, we're only interested in
functions) and macros:</p>
<pre><code class="language-rust ignore">impl&lt;'v&gt; visit::Visitor&lt;'v&gt; for StupidVisitor {
    fn visit_item(&amp;mut self, i: &amp;'v ast::Item) {
        match i.node {
            ast::Item_::ItemFn(ref decl, _, _, _, _) =&gt; {
                // Record the number of args.
                self.increment_args(decl.inputs.len());
            }
            _ =&gt; {}
        }

        // Keep walking.
        visit::walk_item(self, i)
    }

    fn visit_mac(&amp;mut self, mac: &amp;'v ast::Mac) {
        // Find its name and check if it is &quot;println&quot;.
        let ast::Mac_::MacInvocTT(ref path, _, _) = mac.node;
        if path_to_string(path) == &quot;println&quot; {
            self.println_count += 1;
        }

        // Keep walking.
        visit::walk_mac(self, mac)
    }
}
</code></pre>
<p>The <code>increment_args</code> method increments the correct count in
<code>StupidVisitor::arg_counts</code>. After we're done walking, <code>compute_arg_stats</code> does
some pretty basic maths to come up with the stats we want about arguments.</p>
<a class="header" href="print.html#what-next" id="what-next"><h2>What next?</h2></a>
<p>These APIs are pretty new and have a long way to go until they're really good.
If there are improvements you'd like to see or things you'd like to be able to
do, let me know in a comment or <a href="https://github.com/rust-lang/rust/issues">GitHub issue</a>.
In particular, it's not clear to me exactly what extra flexibility is required.
If you have an existing tool that would be suited to this setup, please try it
out and let me know if you have problems.</p>
<p>It'd be great to see Rustdoc converted to using these APIs, if that is possible
(although long term, I'd prefer to see Rustdoc run on the output from save-
analysis, rather than doing its own analysis). Other parts of the compiler
(e.g., pretty printing, testing) could be refactored to use these APIs
internally (I already changed save-analysis to use <code>CompilerController</code>). I've
been experimenting with a prototype rustfmt which also uses these APIs.</p>
<a class="header" href="print.html#appendix-b-background-topics" id="appendix-b-background-topics"><h1>Appendix B: Background topics</h1></a>
<p>This section covers a numbers of common compiler terms that arise in
this guide. We try to give the general definition while providing some
Rust-specific context.</p>
<p><a name="cfg"></a></p>
<a class="header" href="print.html#what-is-a-control-flow-graph" id="what-is-a-control-flow-graph"><h2>What is a control-flow graph?</h2></a>
<p>A control-flow graph is a common term from compilers. If you've ever
used a flow-chart, then the concept of a control-flow graph will be
pretty familiar to you. It's a representation of your program that
exposes the underlying control flow in a very clear way.</p>
<p>A control-flow graph is structured as a set of <strong>basic blocks</strong>
connected by edges. The key idea of a basic block is that it is a set
of statements that execute &quot;together&quot; -- that is, whenever you branch
to a basic block, you start at the first statement and then execute
all the remainder. Only at the end of the block is there the
possibility of branching to more than one place (in MIR, we call that
final statement the <strong>terminator</strong>):</p>
<pre><code class="language-mir">bb0: {
    statement0;
    statement1;
    statement2;
    ...
    terminator;
}
</code></pre>
<p>Many expressions that you are used to in Rust compile down to multiple
basic blocks. For example, consider an if statement:</p>
<pre><code class="language-rust ignore">a = 1;
if some_variable {
    b = 1;
} else {
    c = 1;
}
d = 1;
</code></pre>
<p>This would compile into four basic blocks:</p>
<pre><code class="language-mir">BB0: {
    a = 1;
    if some_variable { goto BB1 } else { goto BB2 }
}

BB1: {
    b = 1;
    goto BB3;
}

BB2: {
    c = 1;
    goto BB3;
}

BB3: {
    d = 1;
    ...;
}
</code></pre>
<p>When using a control-flow graph, a loop simply appears as a cycle in
the graph, and the <code>break</code> keyword translates into a path out of that
cycle.</p>
<p><a name="dataflow"></a></p>
<a class="header" href="print.html#what-is-a-dataflow-analysis" id="what-is-a-dataflow-analysis"><h2>What is a dataflow analysis?</h2></a>
<p><a href="https://cs.au.dk/%7Eamoeller/spa/"><em>Static Program Analysis</em></a> by Anders Møller
and Michael I. Schwartzbach is an incredible resource!</p>
<p><em>to be written</em></p>
<p><a name="quantified"></a></p>
<a class="header" href="print.html#what-is-universally-quantified-what-about-existentially-quantified" id="what-is-universally-quantified-what-about-existentially-quantified"><h2>What is &quot;universally quantified&quot;? What about &quot;existentially quantified&quot;?</h2></a>
<p><em>to be written</em></p>
<p><a name="variance"></a></p>
<a class="header" href="print.html#what-is-co--and-contra-variance" id="what-is-co--and-contra-variance"><h2>What is co- and contra-variance?</h2></a>
<p>Check out the subtyping chapter from the
<a href="https://doc.rust-lang.org/nomicon/subtyping.html">Rust Nomicon</a>.</p>
<p>See the <a href="./variance.html">variance</a> chapter of this guide for more info on how
the type checker handles variance.</p>
<p><a name="free-vs-bound"></a></p>
<a class="header" href="print.html#what-is-a-free-region-or-a-free-variable-what-about-bound-region" id="what-is-a-free-region-or-a-free-variable-what-about-bound-region"><h2>What is a &quot;free region&quot; or a &quot;free variable&quot;? What about &quot;bound region&quot;?</h2></a>
<p>Let's describe the concepts of free vs bound in terms of program
variables, since that's the thing we're most familiar with.</p>
<ul>
<li>Consider this expression, which creates a closure: <code>|a, b| a + b</code>. Here, the <code>a</code> and <code>b</code> in <code>a + b</code> refer to the arguments
that the closure will be given when it is called. We say that the
<code>a</code> and <code>b</code> there are <strong>bound</strong> to the closure, and that the closure
signature <code>|a, b|</code> is a <strong>binder</strong> for the names <code>a</code> and <code>b</code>
(because any references to <code>a</code> or <code>b</code> within refer to the variables
that it introduces).</li>
<li>Consider this expression: <code>a + b</code>. In this expression, <code>a</code> and <code>b</code>
refer to local variables that are defined <em>outside</em> of the
expression. We say that those variables <strong>appear free</strong> in the
expression (i.e., they are <strong>free</strong>, not <strong>bound</strong> (tied up)).</li>
</ul>
<p>So there you have it: a variable &quot;appears free&quot; in some
expression/statement/whatever if it refers to something defined
outside of that expressions/statement/whatever. Equivalently, we can
then refer to the &quot;free variables&quot; of an expression -- which is just
the set of variables that &quot;appear free&quot;.</p>
<p>So what does this have to do with regions? Well, we can apply the
analogous concept to type and regions. For example, in the type <code>&amp;'a u32</code>, <code>'a</code> appears free.  But in the type <code>for&lt;'a&gt; fn(&amp;'a u32)</code>, it
does not.</p>
<a class="header" href="print.html#appendix-c-glossary" id="appendix-c-glossary"><h1>Appendix C: Glossary</h1></a>
<p>The compiler uses a number of...idiosyncratic abbreviations and things. This
glossary attempts to list them and give you a few pointers for understanding
them better.</p>
<table><thead><tr><th>Term                    </th><th> Meaning</th></tr></thead><tbody>
<tr><td>AST                     </td><td>  the abstract syntax tree produced by the syntax crate; reflects user syntax very closely.</td></tr>
<tr><td>binder                  </td><td>  a &quot;binder&quot; is a place where a variable or type is declared; for example, the <code>&lt;T&gt;</code> is a binder for the generic type parameter <code>T</code> in <code>fn foo&lt;T&gt;(..)</code>, and |<code>a</code>|<code>...</code> is a binder for the parameter <code>a</code>. See <a href="./appendix/background.html#free-vs-bound">the background chapter for more</a></td></tr>
<tr><td>bound variable          </td><td>  a &quot;bound variable&quot; is one that is declared within an expression/term. For example, the variable <code>a</code> is bound within the closure expession |<code>a</code>|<code>a * 2</code>. See <a href="./appendix/background.html#free-vs-bound">the background chapter for more</a></td></tr>
<tr><td>codegen unit            </td><td>  when we produce LLVM IR, we group the Rust code into a number of codegen units. Each of these units is processed by LLVM independently from one another, enabling parallelism. They are also the unit of incremental re-use.</td></tr>
<tr><td>completeness            </td><td>  completeness is a technical term in type theory. Completeness means that every type-safe program also type-checks. Having both soundness and completeness is very hard, and usually soundness is more important. (see &quot;soundness&quot;).</td></tr>
<tr><td>control-flow graph      </td><td>  a representation of the control-flow of a program; see <a href="./appendix/background.html#cfg">the background chapter for more</a></td></tr>
<tr><td>cx                      </td><td>  we tend to use &quot;cx&quot; as an abbrevation for context. See also <code>tcx</code>, <code>infcx</code>, etc.</td></tr>
<tr><td>DAG                     </td><td>  a directed acyclic graph is used during compilation to keep track of dependencies between queries. (<a href="incremental-compilation.html">see more</a>)</td></tr>
<tr><td>data-flow analysis      </td><td>  a static analysis that figures out what properties are true at each point in the control-flow of a program; see <a href="./appendix/background.html#dataflow">the background chapter for more</a></td></tr>
<tr><td>DefId                   </td><td>  an index identifying a definition (see <code>librustc/hir/def_id.rs</code>). Uniquely identifies a <code>DefPath</code>.</td></tr>
<tr><td>Double pointer          </td><td>  a pointer with additional metadata. See &quot;fat pointer&quot; for more.</td></tr>
<tr><td>Fat pointer             </td><td>  a two word value carrying the address of some value, along with some further information necessary to put the value to use. Rust includes two kinds of &quot;fat pointers&quot;: references to slices, and trait objects. A reference to a slice carries the starting address of the slice and its length. A trait object carries a value's address and a pointer to the trait's implementation appropriate to that value. &quot;Fat pointers&quot; are also known as &quot;wide pointers&quot;, and &quot;double pointers&quot;.</td></tr>
<tr><td>free variable           </td><td>  a &quot;free variable&quot; is one that is not bound within an expression or term; see <a href="./appendix/background.html#free-vs-bound">the background chapter for more</a></td></tr>
<tr><td>'gcx                    </td><td>  the lifetime of the global arena (<a href="ty.html">see more</a>)</td></tr>
<tr><td>generics                </td><td>  the set of generic type parameters defined on a type or item</td></tr>
<tr><td>HIR                     </td><td>  the High-level IR, created by lowering and desugaring the AST (<a href="hir.html">see more</a>)</td></tr>
<tr><td>HirId                   </td><td>  identifies a particular node in the HIR by combining a def-id with an &quot;intra-definition offset&quot;.</td></tr>
<tr><td>HIR Map                 </td><td>  The HIR map, accessible via tcx.hir, allows you to quickly navigate the HIR and convert between various forms of identifiers.</td></tr>
<tr><td>ICE                     </td><td>  internal compiler error. When the compiler crashes.</td></tr>
<tr><td>ICH                     </td><td>  incremental compilation hash. ICHs are used as fingerprints for things such as HIR and crate metadata, to check if changes have been made. This is useful in incremental compilation to see if part of a crate has changed and should be recompiled.</td></tr>
<tr><td>inference variable      </td><td>  when doing type or region inference, an &quot;inference variable&quot; is a kind of special type/region that represents what you are trying to infer. Think of X in algebra. For example, if we are trying to infer the type of a variable in a program, we create an inference variable to represent that unknown type.</td></tr>
<tr><td>infcx                   </td><td>  the inference context (see <code>librustc/infer</code>)</td></tr>
<tr><td>IR                      </td><td>  Intermediate Representation. A general term in compilers. During compilation, the code is transformed from raw source (ASCII text) to various IRs. In Rust, these are primarily HIR, MIR, and LLVM IR. Each IR is well-suited for some set of computations. For example, MIR is well-suited for the borrow checker, and LLVM IR is well-suited for codegen because LLVM accepts it.</td></tr>
<tr><td>local crate             </td><td>  the crate currently being compiled.</td></tr>
<tr><td>LTO                     </td><td>  Link-Time Optimizations. A set of optimizations offered by LLVM that occur just before the final binary is linked. These include optmizations like removing functions that are never used in the final program, for example. <em>ThinLTO</em> is a variant of LTO that aims to be a bit more scalable and efficient, but possibly sacrifices some optimizations. You may also read issues in the Rust repo about &quot;FatLTO&quot;, which is the loving nickname given to non-Thin LTO. LLVM documentation: <a href="https://llvm.org/docs/LinkTimeOptimization.html">here</a> and <a href="https://clang.llvm.org/docs/ThinLTO.html">here</a></td></tr>
<tr><td><a href="https://llvm.org/">LLVM</a>                  </td><td>  (actually not an acronym :P) an open-source compiler backend. It accepts LLVM IR and outputs native binaries. Various languages (e.g. Rust) can then implement a compiler front-end that output LLVM IR and use LLVM to compile to all the platforms LLVM supports.</td></tr>
<tr><td>MIR                     </td><td>  the Mid-level IR that is created after type-checking for use by borrowck and trans (<a href="./mir/index.html">see more</a>)</td></tr>
<tr><td>miri                    </td><td>  an interpreter for MIR used for constant evaluation (<a href="./miri.html">see more</a>)</td></tr>
<tr><td>normalize               </td><td>  a general term for converting to a more canonical form, but in the case of rustc typically refers to <a href="./traits/associated-types.html#normalize">associated type normalization</a></td></tr>
<tr><td>newtype                 </td><td>  a &quot;newtype&quot; is a wrapper around some other type (e.g., <code>struct Foo(T)</code> is a &quot;newtype&quot; for <code>T</code>). This is commonly used in Rust to give a stronger type for indices.</td></tr>
<tr><td>NLL                     </td><td> <a href="./mir/regionck.html">non-lexical lifetimes</a>, an extension to Rust's borrowing system to make it be based on the control-flow graph.</td></tr>
<tr><td>node-id or NodeId       </td><td>  an index identifying a particular node in the AST or HIR; gradually being phased out and replaced with <code>HirId</code>.</td></tr>
<tr><td>obligation              </td><td>  something that must be proven by the trait system (<a href="traits/resolution.html">see more</a>)</td></tr>
<tr><td>projection              </td><td>  a general term for a &quot;relative path&quot;, e.g. <code>x.f</code> is a &quot;field projection&quot;, and <code>T::Item</code> is an <a href="./traits/goals-and-clauses.html#trait-ref">&quot;associated type projection&quot;</a></td></tr>
<tr><td>promoted constants      </td><td>  constants extracted from a function and lifted to static scope; see <a href="./mir/index.html#promoted">this section</a> for more details.</td></tr>
<tr><td>provider                </td><td>  the function that executes a query (<a href="query.html">see more</a>)</td></tr>
<tr><td>quantified              </td><td>  in math or logic, existential and universal quantification are used to ask questions like &quot;is there any type T for which is true?&quot; or &quot;is this true for all types T?&quot;; see <a href="./appendix/background.html#quantified">the background chapter for more</a></td></tr>
<tr><td>query                   </td><td>  perhaps some sub-computation during compilation (<a href="query.html">see more</a>)</td></tr>
<tr><td>region                  </td><td>  another term for &quot;lifetime&quot; often used in the literature and in the borrow checker.</td></tr>
<tr><td>sess                    </td><td>  the compiler session, which stores global data used throughout compilation</td></tr>
<tr><td>side tables             </td><td>  because the AST and HIR are immutable once created, we often carry extra information about them in the form of hashtables, indexed by the id of a particular node.</td></tr>
<tr><td>sigil                   </td><td>  like a keyword but composed entirely of non-alphanumeric tokens. For example, <code>&amp;</code> is a sigil for references.</td></tr>
<tr><td>skolemization           </td><td>  a way of handling subtyping around &quot;for-all&quot; types (e.g., <code>for&lt;'a&gt; fn(&amp;'a u32)</code>) as well as solving higher-ranked trait bounds (e.g., <code>for&lt;'a&gt; T: Trait&lt;'a&gt;</code>). See <a href="./mir/regionck.html#skol">the chapter on skolemization and universes</a> for more details.</td></tr>
<tr><td>soundness               </td><td>  soundness is a technical term in type theory. Roughly, if a type system is sound, then if a program type-checks, it is type-safe; i.e. I can never (in safe rust) force a value into a variable of the wrong type. (see &quot;completeness&quot;).</td></tr>
<tr><td>span                    </td><td>  a location in the user's source code, used for error reporting primarily. These are like a file-name/line-number/column tuple on steroids: they carry a start/end point, and also track macro expansions and compiler desugaring. All while being packed into a few bytes (really, it's an index into a table). See the Span datatype for more.</td></tr>
<tr><td>substs                  </td><td>  the substitutions for a given generic type or item (e.g. the <code>i32</code>, <code>u32</code> in <code>HashMap&lt;i32, u32&gt;</code>)</td></tr>
<tr><td>tcx                     </td><td>  the &quot;typing context&quot;, main data structure of the compiler (<a href="ty.html">see more</a>)</td></tr>
<tr><td>'tcx                    </td><td>  the lifetime of the currently active inference context (<a href="ty.html">see more</a>)</td></tr>
<tr><td>trait reference         </td><td>  the name of a trait along with a suitable set of input type/lifetimes (<a href="./traits/goals-and-clauses.html#trait-ref">see more</a>)</td></tr>
<tr><td>token                   </td><td>  the smallest unit of parsing. Tokens are produced after lexing (<a href="the-parser.html">see more</a>).</td></tr>
<tr><td><a href="https://llvm.org/docs/LangRef.html#thread-local-storage-models">TLS</a>                   </td><td>  Thread-Local Storage. Variables may be defined so that each thread has its own copy (rather than all threads sharing the variable). This has some interactions with LLVM. Not all platforms support TLS.</td></tr>
<tr><td>trans                   </td><td>  the code to translate MIR into LLVM IR.</td></tr>
<tr><td>trait reference         </td><td>  a trait and values for its type parameters (<a href="ty.html">see more</a>).</td></tr>
<tr><td>ty                      </td><td>  the internal representation of a type (<a href="ty.html">see more</a>).</td></tr>
<tr><td>UFCS                    </td><td>  Universal Function Call Syntax. An unambiguous syntax for calling a method (<a href="type-checking.html">see more</a>).</td></tr>
<tr><td>variance                </td><td>  variance determines how changes to a generic type/lifetime parameter affect subtyping; for example, if <code>T</code> is a subtype of <code>U</code>, then <code>Vec&lt;T&gt;</code> is a subtype <code>Vec&lt;U&gt;</code> because <code>Vec</code> is <em>covariant</em> in its generic parameter. See <a href="./appendix/background.html#variance">the background chapter</a> for a more general explanation. See the <a href="./variance.html">variance chapter</a> for an explanation of how type checking handles variance.</td></tr>
<tr><td>Wide pointer            </td><td>  a pointer with additional metadata. See &quot;fat pointer&quot; for more.</td></tr>
</tbody></table>
<a class="header" href="print.html#appendix-d-code-index" id="appendix-d-code-index"><h1>Appendix D: Code Index</h1></a>
<p>rustc has a lot of important data structures. This is an attempt to give some
guidance on where to learn more about some of the key data structures of the
compiler.</p>
<table><thead><tr><th>Item            </th><th>  Kind    </th><th> Short description           </th><th> Chapter            </th><th> Declaration</th></tr></thead><tbody>
<tr><td><code>CodeMap</code> </td><td> struct </td><td> The CodeMap maps the AST nodes to their source code </td><td> <a href="the-parser.html">The parser</a> </td><td> <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/codemap/struct.CodeMap.html">src/libsyntax/codemap.rs</a></td></tr>
<tr><td><code>CompileState</code> </td><td> struct </td><td> State that is passed to a callback at each compiler pass </td><td> <a href="rustc-driver.html">The Rustc Driver</a> </td><td> <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_driver/driver/struct.CompileState.html">src/librustc_driver/driver.rs</a></td></tr>
<tr><td><code>DiagnosticBuilder</code> </td><td> struct </td><td> A struct for building up compiler diagnostics, such as errors or lints </td><td> <a href="diag.html">Emitting Diagnostics</a> </td><td> <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/struct.DiagnosticBuilder.html">src/librustc_errors/diagnostic_builder.rs</a></td></tr>
<tr><td><code>DocContext</code> </td><td> struct </td><td> A state container used by rustdoc when crawling through a crate to gather its documentation </td><td> <a href="rustdoc.html">Rustdoc</a> </td><td> <a href="https://github.com/rust-lang/rust/blob/master/src/librustdoc/core.rs">src/librustdoc/core.rs</a></td></tr>
<tr><td><code>ast::Crate</code> </td><td> struct </td><td> Syntax-level representation of a parsed crate </td><td> <a href="the-parser.html">The parser</a> </td><td> <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ast/struct.Crate.html">src/librustc/hir/mod.rs</a></td></tr>
<tr><td><code>hir::Crate</code> </td><td> struct </td><td> More abstract, compiler-friendly form of a crate's AST </td><td> <a href="hir.html">The Hir</a> </td><td> <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/hir/struct.Crate.html">src/librustc/hir/mod.rs</a></td></tr>
<tr><td><code>ParseSess</code> </td><td> struct </td><td> This struct contains information about a parsing session </td><td> <a href="the-parser.html">the Parser</a> </td><td> <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/parse/struct.ParseSess.html">src/libsyntax/parse/mod.rs</a></td></tr>
<tr><td><code>Session</code> </td><td> struct </td><td> The data associated with a compilation session </td><td> <a href="the-parser.html">the Parser</a>, <a href="rustc-driver.html">The Rustc Driver</a> </td><td> <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/session/struct.Session.html">src/librustc/session/mod.html</a></td></tr>
<tr><td><code>Span</code> </td><td> struct  </td><td> A location in the user's source code, used for error reporting primarily </td><td> <a href="diag.html">Emitting Diagnostics</a> </td><td> <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax_pos/struct.Span.html">src/libsyntax_pos/span_encoding.rs</a></td></tr>
<tr><td><code>StringReader</code> </td><td> struct </td><td> This is the lexer used during parsing. It consumes characters from the raw source code being compiled and produces a series of tokens for use by the rest of the parser </td><td> <a href="the-parser.html">The parser</a> </td><td>  <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/parse/lexer/struct.StringReader.html">src/libsyntax/parse/lexer/mod.rs</a></td></tr>
<tr><td><code>TraitDef</code> </td><td> struct </td><td> This struct contains a trait's definition with type information </td><td> <a href="ty.html">The <code>ty</code> modules</a> </td><td>  <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/ty/trait_def/struct.TraitDef.html">src/librustc/ty/trait_def.rs</a></td></tr>
<tr><td><code>Ty&lt;'tcx&gt;</code> </td><td> struct </td><td> This is the internal representation of a type used for type checking </td><td> <a href="type-checking.html">Type checking</a> </td><td> <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/ty/type.Ty.html">src/librustc/ty/mod.rs</a></td></tr>
<tr><td><code>TyCtxt&lt;'cx, 'tcx, 'tcx&gt;</code> </td><td> type </td><td> The &quot;typing context&quot;. This is the central data structure in the compiler. It is the context that you use to perform all manner of queries. </td><td> <a href="ty.html">The <code>ty</code> modules</a> </td><td> <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/ty/struct.TyCtxt.html">src/librustc/ty/context.rs</a></td></tr>
</tbody></table>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        <script type="text/javascript">
            document.addEventListener('DOMContentLoaded', function() {
                window.print();
            })
        </script>
        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

    </body>
</html>
